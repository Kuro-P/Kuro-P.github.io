---
title: 前端模块化
date: 2019-01-03 11:19:05
tags: [JavaScript]
categories: [前端, JavaScript]
---
目前JS模块化规范主要三种：浏览器端的 __AMD__、__CMD__ 规范和nodeJS端的 __commonJS__ 规范。经常被exports、modules.exports、export、require绕懵，遂来探一探究竟。

#### AMD规范 (requireJS) 浏览器端 异步加载模块 提前执行
AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
RequireJS 帮开发者解决了各个js文件的依赖问题，让开发者在页面引入多个js时，不必考虑各个js的依赖关系，用 `define` 定义模块，用 `require` 引入。

#### CMD规范 (SeaJS) 浏览器端 异步加载模块 延迟执行
CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。
CMD 跟 AMD 很像，也使用 `define` 来定义模块，它俩主要是依赖加载的时间点不一样。相比于 AMD 依赖前置，CDM 加载采用就近原则。

#### commonJS 服务端 同步加载模块 
nodeJS的模块引用使用的就是 commonJS 的规范，因为服务端第三方库大多已存于本地，加载速度较快，使用同步加载比较理想。它使用 `module.exports` 或者是 `exports` 来导出，使用 `require` 引入。
* browserify 使浏览器端可以直接使用 require
* webpack 使浏览器端 js 既实现了 AMD 规范也实现了 commonJS 规范

#### ES6 的 export 和 import 
ES6 将模块进行了标准化，整合 commonJS 和 AMD 规范，使用 `export` 或者 `export default` 来暴露模块，使用 `import` 导入。

经过上述总结，大多第三方库声明模块的代码也就不难理解了
````javascript
    if (typeof define === 'function') { // 兼容 requireJS AMD、CMD规范   
        define(function () {
            return moduleName;
        });
    } else if (typeof exports !== 'undefined') { // 兼容 webpack 引入方式(commonJS) 
        module.exports = moduleName; 
    } else {
        this.moduleName = moduleName; // 普通引入，注册到全局
    }
````

#### 参考资料
[前端模块化详解(完整版)](https://github.com/ljianshu/Blog/issues/48)
[关于commonjs，AMD，CMD之间的异同](https://www.cnblogs.com/omelette/p/6652472.html)