{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/README.md","path":"README.md","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"fbaa8154c2fd3a8f1b1e5c7c14b155a4f55a9f66","modified":1604478570872},{"_id":"source/README.md","hash":"4d64a4be880145dc767a0f2b35ae07130934caec","modified":1604478570873},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1604478570904},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1604478570904},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1604478570905},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1604478570905},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1604478570905},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1604478570905},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1604478570905},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1604478570906},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1604478570906},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1604478570906},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1604478570906},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1604478570906},{"_id":"themes/next/_config.yml","hash":"eaf3308e1630e127fa99c5737883fdcfcaa4cbfa","modified":1604478570906},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1604478570907},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1604478570907},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1604478570921},{"_id":"source/_posts/.DS_Store","hash":"648644df3521a13c7adce06fa4dc50fe8ad678e0","modified":1604478570873},{"_id":"source/_posts/2018年终总结.md","hash":"c0867d75f3a9d9a231117bf8b90c50a511bf75b7","modified":1604478570873},{"_id":"source/_posts/2019年终总结.md","hash":"a5f5bda7b7cbbd55ad1eccd617fd3679c7f1a2c6","modified":1604478570873},{"_id":"source/_posts/2020年终总结.md","hash":"90cdac38c81f031fe40e52933189a8f176b50ce8","modified":1609900122640},{"_id":"source/_posts/Flink-初探.md","hash":"a37a0672131d623db787f294f95c15280b8cdaf1","modified":1604478570873},{"_id":"source/_posts/Hexo-基础使用.md","hash":"25629d1afdc1a9d9f7fc7e2cf9dd4855996acc8e","modified":1604478570874},{"_id":"source/_posts/IP地址和子网划分.md","hash":"43b01d944ed0f12807f272c216bcbbaa1d1e779b","modified":1604478570874},{"_id":"source/_posts/Linux命令行与shell脚本学习.md","hash":"6a04b4ff5e4866c842dfd485aaa49f604dbef8f3","modified":1607755123774},{"_id":"source/_posts/MarkDown语法小记.md","hash":"97801ee3d364a3735c9014a0f07b8b1c8ae2ffc3","modified":1604478570874},{"_id":"source/_posts/PWA-Service-Worker-小结（一）各类缓存对比.md","hash":"2722aa52ddea3d068ffea7d2f8c4dc3aa2c139d3","modified":1604478570875},{"_id":"source/_posts/PWA-Service-Worker-小结（二）实践.md","hash":"3e85584bcf86c26a133f9d3c4a21c2670fbef968","modified":1604478570876},{"_id":"source/_posts/Prometheus监控应用性能.md","hash":"54384e482f1aae5afd9a568eeaed3f13d2e3efcb","modified":1604478570876},{"_id":"source/_posts/z-index小结.md","hash":"4f34d69b09a6664fcf53c62598b85de27ba5be13","modified":1604478570878},{"_id":"source/_posts/《看见》-柴静.md","hash":"17672484d6ed9b3f5442ff2e1fb9ada4397f866d","modified":1604478570878},{"_id":"source/_posts/《计算机网络》-http-部分读书笔记.md","hash":"9c478ed4d9576ee10a69b53dfd9d476f2fa2842b","modified":1604478570878},{"_id":"source/_posts/【译】Can-NodeJS-use-ES6-import-syntax.md","hash":"fc75e0bce2adf002870d918709cfa2e1e3b491b4","modified":1607754440329},{"_id":"source/_posts/【译】从-ES2016-到-ES2020-的所有特性.md","hash":"e3280533ab247af613b415c2f482197af2376df8","modified":1604478570879},{"_id":"source/_posts/使用 Performance APi 进行前端性能监控.md","hash":"038ea93092de46ab0838b723cbc6613cb108fa47","modified":1604478570879},{"_id":"source/_posts/前端模块化.md","hash":"9c652ffd06c8dca19b81a8db2eb710b464bcd6cf","modified":1607667461464},{"_id":"source/_posts/同时使用两个账号分别操作Github和Gitlab.md","hash":"e540f4540550b124d9eeabdefaa66e136a7e1768","modified":1604478570880},{"_id":"source/_posts/微信小程序从0到1.md","hash":"aabd340e579dc19616345bb45d8b1a07c8f64b65","modified":1616399452897},{"_id":"source/_posts/微信授权流程.md","hash":"4badbefbfcbf80758ff3ea50f4869bcc080e8c03","modified":1604478570881},{"_id":"source/_posts/正则表达式学习笔记.md","hash":"2db41bf31060d72a42f0ccb663dfaed79e87c0df","modified":1604478570883},{"_id":"source/about/index.md","hash":"ace7ff2476c8558a16baac2612de712df0196519","modified":1604478570883},{"_id":"source/categories/index.md","hash":"210af89c8ddb41767b93a5476b2f0bfb7f126578","modified":1604478570883},{"_id":"source/tags/index.md","hash":"117af0f5864f1fb77308532c10afd7c796d3c1cf","modified":1604478570883},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1604478570905},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1604478570905},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1604478570905},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1604478570905},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1604478570907},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1604478570907},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1604478570907},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1604478570907},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1604478570907},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1604478570907},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1604478570907},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1604478570908},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1604478570908},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1604478570908},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1604478570908},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1604478570908},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1604478570908},{"_id":"themes/next/languages/zh-Hans.yml","hash":"18efe049e97b499507de776649813d3828bef134","modified":1604478570908},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1604478570908},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1604478570909},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1604478570909},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1604478570920},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1604478570920},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1604478570920},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1604478570921},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1604478570921},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1604478570921},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1604478570921},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1604478570921},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1604478570922},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1604478571003},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1604478571003},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1604478571003},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1604478570947},{"_id":"source/_posts/PWA-Service-Worker-小结（一）各类缓存对比/CDN&&Nginx.jpg","hash":"4a01a5df01bc6198dd539a2917767c924cc561e8","modified":1604478570875},{"_id":"source/_posts/PWA-Service-Worker-小结（一）各类缓存对比/web应用缓存位置图.png","hash":"d7baa3458ab7c1b0c2445828dc3025f8e3f7ccff","modified":1604478570875},{"_id":"source/_posts/PWA-Service-Worker-小结（一）各类缓存对比/协商缓存命中过程.png","hash":"0f471929b52bb025498ffaed9c214db2961bb400","modified":1604478570876},{"_id":"source/_posts/PWA-Service-Worker-小结（二）实践/Service-Worker-Lifecycle.png","hash":"b801bcfb4112648500133eee45b1a377d3a34b31","modified":1604478570876},{"_id":"source/_posts/z-index小结/stacking-order.png","hash":"3364e6e9cc70ce7b8264ff8cd0e2cfa1bdf820dd","modified":1604478570878},{"_id":"source/_posts/同时使用两个账号分别操作Github和Gitlab/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1604478570880},{"_id":"source/_posts/同时使用两个账号分别操作Github和Gitlab/enter-passphrase.png","hash":"5ab1bc937fa5dd48ab38cd1e78c8b48d70c4933b","modified":1604478570880},{"_id":"source/_posts/同时使用两个账号分别操作Github和Gitlab/test-ssh-connect.png","hash":"3d2a10a7ab19235e215ae66efbf24c9ef2a1b825","modified":1604478570880},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1604478570909},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1604478570909},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1604478570909},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1604478570909},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1604478570910},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1604478570910},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1604478570910},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1604478570910},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1604478570910},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1604478570910},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1604478570910},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1604478570910},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1604478570911},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1604478570911},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1604478570911},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1604478570912},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1604478570912},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1604478570913},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1604478570918},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1604478570918},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1604478570918},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1604478570918},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1604478570918},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1604478570918},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1604478570919},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1604478570922},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1604478570922},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1604478570922},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1604478570923},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1604478570923},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1604478570923},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1604478570923},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1604478570923},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1604478570924},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1604478570947},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1604478570947},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1604478570947},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1604478570948},{"_id":"themes/next/source/images/avatar.jpeg","hash":"157d6b7c4638a84211cdaaa337dfb960d6939048","modified":1604478570948},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1604478570949},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1604478570949},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1604478570950},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1604478570950},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1604478570950},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1604478570950},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1604478570951},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1604478570951},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1604478570951},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1604478570951},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1604478570951},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1604478570951},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1604478570951},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1604478570951},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1604478570952},{"_id":"source/_posts/Linux命令行与shell脚本学习/file-permissions.png","hash":"34f6f19127840ef3503441821afed1362c7de51a","modified":1604478570874},{"_id":"source/_posts/Prometheus监控应用性能/flowChart.png","hash":"a5d0eb6f25eef534ab0706a265a0919e6a642a3c","modified":1604478570878},{"_id":"source/_posts/Prometheus监控应用性能/architecture.png","hash":"9de69ee9f98ab5cdb790cc74957e8cd74e81657b","modified":1604478570877},{"_id":"source/_posts/使用 Performance APi 进行前端性能监控/performance.png","hash":"dfd42f426cd812d386633f709f028946737724d2","modified":1604478570879},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1604478570912},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1604478570912},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1604478570937},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1604478570938},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1604478570938},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1604478570946},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1604478570947},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1604478570910},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1604478570910},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1604478570911},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1604478570911},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1604478570911},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1604478570911},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1604478570911},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1604478570911},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1604478570912},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1604478570912},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1604478570912},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1604478570912},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1604478570913},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1604478570913},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1604478570914},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1604478570914},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1604478570914},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1604478570914},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1604478570915},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1604478570915},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1604478570915},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1604478570915},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1604478570915},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1604478570915},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1604478570916},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1604478570916},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1604478570916},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1604478570916},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1604478570917},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1604478570917},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1604478570917},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1604478570917},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1604478570917},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1604478570919},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1604478570919},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1604478570920},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1604478570920},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1604478570937},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1604478570937},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1604478570938},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1604478570938},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1604478570946},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1604478570946},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1604478570946},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1604478570946},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1604478570952},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1604478570952},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1604478570953},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1604478570953},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1604478570953},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1604478570953},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1604478570953},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1604478570953},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1604478570954},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1604478570954},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1604478570955},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1604478570958},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1604478570960},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1604478570960},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1604478570963},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1604478570964},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1604478570964},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1604478570964},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1604478570965},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1604478570965},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1604478570965},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1604478570965},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1604478570966},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1604478570974},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1604478570976},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1604478570976},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1604478570977},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1604478570978},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1604478570978},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1604478570979},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1604478570980},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1604478570981},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1604478570981},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1604478570982},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1604478570983},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1604478570983},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1604478570984},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1604478570985},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1604478570985},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1604478570985},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1604478570985},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1604478570986},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1604478570987},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1604478570987},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1604478570988},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1604478570988},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1604478570989},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1604478570990},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1604478570991},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1604478570992},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1604478570999},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1604478570999},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1604478571002},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1604478571002},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1604478571002},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1604478570915},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1604478570975},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1604478570919},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1604478570919},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1604478570924},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1604478570924},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1604478570924},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1604478570924},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1604478570925},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1604478570928},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1604478570932},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1604478570936},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1604478570936},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1604478570936},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1604478570936},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1604478570936},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1604478570937},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1604478570937},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1604478570938},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1604478570939},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1604478570939},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1604478570940},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1604478570940},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1604478570940},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1604478570941},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1604478570941},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1604478570942},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1604478570942},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1604478570942},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1604478570942},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1604478570942},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1604478570943},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1604478570943},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1604478570943},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1604478570943},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1604478570944},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1604478570944},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1604478570954},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1604478570957},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1604478570957},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1604478570960},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1604478570960},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1604478570960},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1604478570961},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1604478570961},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1604478570961},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1604478570962},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1604478570962},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1604478570962},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1604478570964},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1604478570964},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1604478570966},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1604478570967},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1604478570967},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1604478570997},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1604478570998},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1604478570956},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1604478570972},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1604478571001},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1604478570925},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1604478570925},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1604478570925},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1604478570926},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1604478570926},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1604478570926},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1604478570927},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1604478570927},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1604478570927},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1604478570927},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1604478570927},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1604478570926},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1604478570927},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1604478570926},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1604478570928},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1604478570928},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1604478570928},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1604478570929},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1604478570929},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1604478570929},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1604478570929},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1604478570929},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1604478570930},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1604478570930},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1604478570928},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1604478570930},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1604478570930},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1604478570929},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1604478570930},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1604478570931},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1604478570930},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1604478570931},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1604478570931},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1604478570931},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1604478570931},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1604478570932},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1604478570932},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1604478570932},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1604478570931},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1604478570932},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1604478570933},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1604478570933},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1604478570933},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1604478570933},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1604478570934},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1604478570934},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1604478570933},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1604478570933},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1604478570934},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1604478570934},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1604478570934},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1604478570934},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1604478570935},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1604478570935},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1604478570935},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1604478570935},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1604478570935},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1604478570935},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1604478570941},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1604478570941},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1604478570943},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1604478570955},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1604478570956},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1604478570956},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1604478570956},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1604478570956},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1604478570957},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1604478570961},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1604478570961},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1604478570961},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1604478570961},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1604478570961},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1604478570961},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1604478570968},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1604478570973},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1604478570970},{"_id":"source/_posts/微信授权流程/flowChart.png","hash":"97a87939796c8bb264d2608b2e8f32841d199d53","modified":1604478570883},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1604478570972},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1604478570960},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1604478570995},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1604478570971},{"_id":"public/search.xml","hash":"ce172004f3c4400cb3db93256c3fbbecfbac57d2","modified":1616400839643},{"_id":"public/categories/index.html","hash":"63606f2815d7c9c6b38ca4dcd4a089f33d1569c2","modified":1616400839665},{"_id":"public/about/index.html","hash":"44c9e4be1614852c62a2fc24bec24db50a4ccc37","modified":1616400839665},{"_id":"public/tags/index.html","hash":"010c603cd9116e132c9806eab3439ddff4ac22ff","modified":1616400839665},{"_id":"public/2021/03/22/微信小程序从0到1/index.html","hash":"b99004fd32e195f60bf17a880932de48b8bbf512","modified":1616400839665},{"_id":"public/2020/12/31/2020年终总结/index.html","hash":"a5d42dca082b0c65ed60edca593190590c26fba5","modified":1616400839665},{"_id":"public/2020/12/10/【译】Can-NodeJS-use-ES6-import-syntax/index.html","hash":"9d44ab59b15df7a6faed9b3911465f8be39ad1ed","modified":1616400839665},{"_id":"public/2020/07/23/【译】从-ES2016-到-ES2020-的所有特性/index.html","hash":"ef65c749c2b75d15191d96b2e0d3d79b36d7453d","modified":1616400839665},{"_id":"public/2020/01/02/PWA-Service-Worker-小结（二）实践/index.html","hash":"adecce75a3ac18bc79227d6f46f52f4c27bf8bd9","modified":1616400839665},{"_id":"public/2019/12/31/2019年终总结/index.html","hash":"e8d211e01f9e30d3d407d5678c47a1663f0ee874","modified":1616400839666},{"_id":"public/2019/12/26/PWA-Service-Worker-小结（一）各类缓存对比/index.html","hash":"fd63df939d83f5750ba58a5a06d364ea85a247d2","modified":1616400839666},{"_id":"public/2019/11/14/Flink-初探/index.html","hash":"840b7336bd604867ac2ab075527ed96c22e3fa32","modified":1616400839666},{"_id":"public/2019/10/22/《计算机网络》-http-部分读书笔记/index.html","hash":"4dd2f62873c1458e08696787a2bd68c755d55400","modified":1616400839666},{"_id":"public/2019/08/05/z-index小结/index.html","hash":"787b1e0b923c91f0944c51610a64840399a11267","modified":1616400839666},{"_id":"public/2019/07/15/Prometheus监控应用性能/index.html","hash":"23c1f4e846770ac31a9c4e7e43245231d567438b","modified":1616400839666},{"_id":"public/2019/07/11/使用 Performance APi 进行前端性能监控/index.html","hash":"a2cfcdb42c9573ae7b5da2be3ca73ab6074f1747","modified":1616400839666},{"_id":"public/2019/06/02/IP地址和子网划分/index.html","hash":"340fcdc154f5a71497e81ee1138f392afd5c185c","modified":1616400839666},{"_id":"public/2019/05/30/微信授权流程/index.html","hash":"345dfc745cacfe97dc1cbe0ef42d2017dd0f5a22","modified":1616400839666},{"_id":"public/2019/04/13/正则表达式学习笔记/index.html","hash":"9d1501b23bc6775cd27d65d6d27a5e74008d0ada","modified":1616400839666},{"_id":"public/2019/01/03/前端模块化/index.html","hash":"8fcc872d16a29e7cc4e71b3303ba20fa6ff9cc19","modified":1616400839666},{"_id":"public/2018/12/31/2018年终总结/index.html","hash":"70e74c67b2e345edcb922700992952757bef0cdc","modified":1616400839666},{"_id":"public/2018/11/30/Linux命令行与shell脚本学习/index.html","hash":"db39668cd3426203d11b149838a887eff22fa721","modified":1616400839666},{"_id":"public/2018/11/17/同时使用两个账号分别操作Github和Gitlab/index.html","hash":"472a7ea10fcb60ec18b703cb059f162ed7b4778e","modified":1616400839666},{"_id":"public/2018/11/17/Hexo-基础使用/index.html","hash":"e9c0e65653ec2d56dc171b6e41a50eacd633410d","modified":1616400839666},{"_id":"public/2018/09/07/《看见》-柴静/index.html","hash":"91892c39e70cebd6210408640b137499d19c0cd4","modified":1616400839666},{"_id":"public/2018/09/05/MarkDown语法小记/index.html","hash":"ad93d66c7473c9fb9995ced281bc253f1e6e2494","modified":1616400839666},{"_id":"public/archives/index.html","hash":"cf4bd0214b399b1d269c48bfd4b64120cf672f09","modified":1616400839666},{"_id":"public/archives/page/2/index.html","hash":"64a336b234fcb37614a81aa7136f5f1ddece9ef9","modified":1616400839666},{"_id":"public/archives/page/3/index.html","hash":"d71769e51bbcdf75c34395123a0d6a287ca3fe1d","modified":1616400839666},{"_id":"public/archives/2018/index.html","hash":"c4c90f568ab99fc43fbae733abbc45da9cf99cc7","modified":1616400839666},{"_id":"public/archives/2018/09/index.html","hash":"671d2283c7c174dc70933948f65d9f1b00a17c21","modified":1616400839666},{"_id":"public/archives/2018/11/index.html","hash":"746a161b865014971673c10efff09046cc205ff2","modified":1616400839667},{"_id":"public/archives/2018/12/index.html","hash":"283ffac0b0c818157c53b079c1e95785803a4eda","modified":1616400839667},{"_id":"public/archives/2019/index.html","hash":"7ed8be4cdccc65b307347fd8ef4f1db07f920054","modified":1616400839667},{"_id":"public/archives/2019/page/2/index.html","hash":"ed572efbe4154c46165c248ded917f3cd0d1a6a1","modified":1616400839667},{"_id":"public/archives/2019/01/index.html","hash":"ce5331ff0b3b231a679f86da914a61b2816442ff","modified":1616400839667},{"_id":"public/archives/2019/04/index.html","hash":"4029c3e930b4cf55025a3c1e7aa86343e47448b6","modified":1616400839667},{"_id":"public/archives/2019/05/index.html","hash":"1cf20a273861e9aba97b0df42cb93c1b964a53a6","modified":1616400839667},{"_id":"public/archives/2019/06/index.html","hash":"967ef7e474bc2aeba4fe3c2723e4f5ec82d1eeab","modified":1616400839667},{"_id":"public/archives/2019/07/index.html","hash":"7b32fb25ad0509788a526910c41dc4ac6e388574","modified":1616400839667},{"_id":"public/archives/2019/08/index.html","hash":"02ec234dd8dbaf0640edb41f308aa0ebf394d027","modified":1616400839667},{"_id":"public/archives/2019/10/index.html","hash":"b452df3bc751a6f408c92385bd3cf02aa2d022e9","modified":1616400839667},{"_id":"public/archives/2019/11/index.html","hash":"d0d05c97ba07c00cb83ea2cf5343260091f5d1f2","modified":1616400839667},{"_id":"public/archives/2019/12/index.html","hash":"78b87d41456c76939c4c178f9259c7ec6e56e531","modified":1616400839667},{"_id":"public/archives/2020/index.html","hash":"dbef685e36a539239579ec4a5a0e4cb0af29bb25","modified":1616400839667},{"_id":"public/archives/2020/01/index.html","hash":"6e3674ecd10d4660b2a7ff8eb760237d3c3c66b9","modified":1616400839667},{"_id":"public/archives/2020/07/index.html","hash":"8f633859ffd69dd2dea66f65d9493bcb9eec5c64","modified":1616400839667},{"_id":"public/archives/2020/12/index.html","hash":"e148993bfada399b293886dcece0e27d827e7251","modified":1616400839667},{"_id":"public/archives/2021/index.html","hash":"337fb45901edae69dca8b57ebf52491df16598e0","modified":1616400839667},{"_id":"public/archives/2021/03/index.html","hash":"c38c20d7560ead43c0d04fd4e0a06221bdee4d0b","modified":1616400839667},{"_id":"public/categories/大数据/index.html","hash":"12a273dddd2261b29058bc297db9f1fbe5037b8a","modified":1616400839667},{"_id":"public/categories/其他小结/index.html","hash":"644713642e03c14ccf6d8507af02530bba51447f","modified":1616400839667},{"_id":"public/categories/计算机相关知识/index.html","hash":"e6c5e2020196dc5625d89bc9fd669feb8ccadd2a","modified":1616400839667},{"_id":"public/categories/前端/index.html","hash":"f2357b2cf49beb20afe322a2bc00a126f958673c","modified":1616400839667},{"_id":"public/categories/监控/index.html","hash":"72068b6184cf2873fd48958567357a2b004c4cbf","modified":1616400839667},{"_id":"public/categories/闲暇读物/index.html","hash":"e889b52be07721a524cb752be736631b5b1b6480","modified":1616400839667},{"_id":"public/categories/后端/index.html","hash":"d4c42dd1f9c9decea41bc998194df8058e917c49","modified":1616400839667},{"_id":"public/categories/前端，JavaScript/index.html","hash":"38d1343c982ecdb4bee6d55f97eaa509fd3f0f9e","modified":1616400839667},{"_id":"public/categories/前端/PWA/index.html","hash":"ebf4ec19e40a5a9917926d944f5541b2cb2944d5","modified":1616400839667},{"_id":"public/categories/前端/JavaScript/index.html","hash":"321b0d5ca4bfb46657820ac1a3a1161b57f1e127","modified":1616400839667},{"_id":"public/categories/git/index.html","hash":"20bc7a5a2b19f05ae856a8582adc2ff7e5d048c6","modified":1616400839667},{"_id":"public/categories/前端/CSS/index.html","hash":"960f7d4b4733083c17bc336157cefa10fc179b5f","modified":1616400839667},{"_id":"public/tags/年度总结/index.html","hash":"cc1a85f787a779df301f18db402f32e02d654f81","modified":1616400839667},{"_id":"public/tags/大数据/index.html","hash":"c373804a842240d4c61b3090d7d14ee0cb735ea0","modified":1616400839667},{"_id":"public/tags/流处理/index.html","hash":"f0dfe301f6ef84ef68258f4c25be84308d3b1d66","modified":1616400839667},{"_id":"public/tags/Hexo/index.html","hash":"22ca7f5021dac5de89b1723c1a26ad44184a4029","modified":1616400839668},{"_id":"public/tags/计算机网络/index.html","hash":"4bb394cc2aa63acc055180a6d9593b3a4ead17eb","modified":1616400839668},{"_id":"public/tags/Linux-shell/index.html","hash":"014cc15fdb743ae8338619a71b4fcc6f7f526c28","modified":1616400839668},{"_id":"public/tags/Markdown/index.html","hash":"548407542f9b037fb4c64fd3ebab8ac801b596a4","modified":1616400839668},{"_id":"public/tags/Service-Worker/index.html","hash":"f95027629e488d431421d690ea85ff6c294f352d","modified":1616400839668},{"_id":"public/tags/性能监控/index.html","hash":"e7dc687be6642a5d45a3812de70a7f6725bf04d5","modified":1616400839668},{"_id":"public/tags/CSS/index.html","hash":"6df6afe766dcaad5f87c71ddf6d98d0ed08959d0","modified":1616400839668},{"_id":"public/tags/读书小结/index.html","hash":"adf9dcef4c36f21a7cb25bb869d86d06964d9d3d","modified":1616400839668},{"_id":"public/tags/NodeJS/index.html","hash":"e0c2d813ef9398962a839c9ae1c2e3e25fa7871e","modified":1616400839668},{"_id":"public/tags/JavaScript/index.html","hash":"55450eadf837c3118960a509d733ed39d56a2f79","modified":1616400839668},{"_id":"public/tags/git/index.html","hash":"eeb5d7ab4f52fec74fc82bed0370094095a2099e","modified":1616400839668},{"_id":"public/tags/微信/index.html","hash":"6ac6dd9669272e0d8c39c01d5e440e3ff6876b77","modified":1616400839668},{"_id":"public/tags/小程序/index.html","hash":"afc035eea1e4d8c1fb1597699dc3934483df760e","modified":1616400839668},{"_id":"public/tags/微信授权/index.html","hash":"3f99614e15d005a2295f1e5d4e9a20b45a684df1","modified":1616400839668},{"_id":"public/index.html","hash":"0d60f7382dcc116f7debd3d67b9ba0edd2f51e31","modified":1616400839668},{"_id":"public/page/2/index.html","hash":"8050e47cfa45e07b8236ade8f3ff8968eaa52a76","modified":1616400839668},{"_id":"public/page/3/index.html","hash":"86dfa366c3c57cb55a6924a22e1c4238cb2c6d0f","modified":1616400839668},{"_id":"public/README.md","hash":"4d64a4be880145dc767a0f2b35ae07130934caec","modified":1616400839679},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1616400839680},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1616400839680},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1616400839680},{"_id":"public/images/avatar.jpeg","hash":"157d6b7c4638a84211cdaaa337dfb960d6939048","modified":1616400839680},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1616400839680},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1616400839680},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1616400839680},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1616400839680},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1616400839680},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1616400839680},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1616400839680},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1616400839680},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1616400839680},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1616400839680},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1616400839680},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1616400839680},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1616400839680},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1616400839680},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1616400839680},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1616400839680},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1616400839680},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1616400839680},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1616400839680},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1616400839680},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1616400839680},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1616400839680},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1616400839680},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1616400839680},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1616400839681},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1616400839681},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1616400839681},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1616400839681},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1616400839681},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1616400839681},{"_id":"public/2020/01/02/PWA-Service-Worker-小结（二）实践/Service-Worker-Lifecycle.png","hash":"b801bcfb4112648500133eee45b1a377d3a34b31","modified":1616400839681},{"_id":"public/2019/08/05/z-index小结/stacking-order.png","hash":"3364e6e9cc70ce7b8264ff8cd0e2cfa1bdf820dd","modified":1616400839681},{"_id":"public/2018/11/17/同时使用两个账号分别操作Github和Gitlab/enter-passphrase.png","hash":"5ab1bc937fa5dd48ab38cd1e78c8b48d70c4933b","modified":1616400839681},{"_id":"public/2019/12/26/PWA-Service-Worker-小结（一）各类缓存对比/CDN&&Nginx.jpg","hash":"4a01a5df01bc6198dd539a2917767c924cc561e8","modified":1616400839681},{"_id":"public/2018/11/17/同时使用两个账号分别操作Github和Gitlab/test-ssh-connect.png","hash":"3d2a10a7ab19235e215ae66efbf24c9ef2a1b825","modified":1616400839681},{"_id":"public/2019/12/26/PWA-Service-Worker-小结（一）各类缓存对比/协商缓存命中过程.png","hash":"0f471929b52bb025498ffaed9c214db2961bb400","modified":1616400839681},{"_id":"public/2019/12/26/PWA-Service-Worker-小结（一）各类缓存对比/web应用缓存位置图.png","hash":"d7baa3458ab7c1b0c2445828dc3025f8e3f7ccff","modified":1616400839681},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1616400840206},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1616400840215},{"_id":"public/2018/11/30/Linux命令行与shell脚本学习/file-permissions.png","hash":"34f6f19127840ef3503441821afed1362c7de51a","modified":1616400840219},{"_id":"public/2019/07/15/Prometheus监控应用性能/architecture.png","hash":"9de69ee9f98ab5cdb790cc74957e8cd74e81657b","modified":1616400840219},{"_id":"public/2019/07/15/Prometheus监控应用性能/flowChart.png","hash":"a5d0eb6f25eef534ab0706a265a0919e6a642a3c","modified":1616400840219},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1616400840232},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1616400840232},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1616400840233},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1616400840233},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1616400840233},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1616400840233},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1616400840233},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1616400840233},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1616400840233},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1616400840233},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1616400840233},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1616400840233},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1616400840233},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1616400840233},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1616400840233},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1616400840233},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1616400840233},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1616400840233},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1616400840233},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1616400840234},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1616400840234},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1616400840234},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1616400840234},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1616400840234},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1616400840234},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1616400840234},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1616400840234},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1616400840234},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1616400840234},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1616400840234},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1616400840234},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1616400840234},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1616400840234},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1616400840234},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1616400840234},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1616400840234},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1616400840234},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1616400840234},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1616400840234},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1616400840234},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1616400840234},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1616400840235},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1616400840235},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1616400840235},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1616400840235},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1616400840235},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1616400840235},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1616400840235},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1616400840235},{"_id":"public/css/main.css","hash":"7c56aca6d16ceb6d44d335851c5320baca3e2260","modified":1616400840235},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1616400840235},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1616400840235},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1616400840235},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1616400840235},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1616400840235},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1616400840235},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1616400840235},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1616400840235},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1616400840236},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1616400840236},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1616400840236},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1616400840236},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1616400840236},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1616400840236},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1616400840236},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1616400840236},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1616400840236},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1616400840236},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1616400840237},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1616400840237},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1616400840237},{"_id":"public/2019/07/11/使用 Performance APi 进行前端性能监控/performance.png","hash":"dfd42f426cd812d386633f709f028946737724d2","modified":1616400840237},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1616400840243},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1616400840243},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1616400840257},{"_id":"public/2019/05/30/微信授权流程/flowChart.png","hash":"97a87939796c8bb264d2608b2e8f32841d199d53","modified":1616400840257}],"Category":[{"name":"大数据","_id":"ckmkbbo0e00077vvu7cv11czo"},{"name":"其他小结","_id":"ckmkbbo0n000e7vvumslyz8h4"},{"name":"计算机相关知识","_id":"ckmkbbo0r000k7vvug1iakyzv"},{"name":"前端","_id":"ckmkbbo0y00107vvup9r7rpn9"},{"name":"监控","_id":"ckmkbbo1000187vvu33qkzn4t"},{"name":"闲暇读物","_id":"ckmkbbo14001p7vvusshgkpz7"},{"name":"后端","_id":"ckmkbbo15001s7vvu541bb0cc"},{"name":"前端，JavaScript","_id":"ckmkbbo15001w7vvuoegdg2i5"},{"name":"PWA","parent":"ckmkbbo0y00107vvup9r7rpn9","_id":"ckmkbbo1600207vvupln9ha2l"},{"name":"JavaScript","parent":"ckmkbbo0y00107vvup9r7rpn9","_id":"ckmkbbo1600247vvu5mkmi07e"},{"name":"git","_id":"ckmkbbo1700287vvu0zdtbeyn"},{"name":"CSS","parent":"ckmkbbo0y00107vvup9r7rpn9","_id":"ckmkbbo19002l7vvuhud75lvz"}],"Data":[],"Page":[{"title":"分类","date":"2018-09-07T07:08:41.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-09-07 15:08:41\ntype: categories\n---\n","updated":"2020-11-04T08:29:30.883Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckmkbbo3z00347vvut5ar3gv7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于我","date":"2019-05-04T14:27:14.000Z","tags":null,"categories":null,"_content":"<br/>\n我毕业于<del>一所技术院校</del>辽宁工程技术大学，是一名通信学子。\n大一的时候学做 ppt，大二的时候搞 Ps 和 Ae ，大三上学期无意间被网页上的动画效果吸引，大四的时候迈入了前端的坑。\n\n### 关于通信\n上大学的时候，同学们都调侃，“为啥通信的学生要学这么多，几乎电信学院的各个专业各科我们都会掺和一脚”。大三上专业课的时候，学习`信号与系统`、`通信原理`，`移动通信`，...铺天盖地的数学砸下来，才知道：“哦，原来通信是搞数学的。”\n<del>用专业的话说，通信也是考量人发量的一门学科。</del>。\n\n### 关于前端\n一入前端深似海，从此学习常相伴。\n前端知识面广而杂，计算机专业基础知识的欠缺，让我无时不刻觉得<del>我应该在土里，不是在前端的坑底</del>认真学习的重要性。\nGood good study, day day up ╰(￣▽￣)╭ .\n\n### 关于我\n大三的时候，身边的大多数同学决定考研，继续研究<del>数学</del>通信。\n而当时的我，一手掐着前端的学习资料，一手抱着通信课本，毅然决然的准备成为一名准前端er。\n<del>现在，我在一家互联网金融公司继续挖坑、填坑。</del>\n现在，我在一家二手交易平台继续打酱油。\n\n### 关于辽工大\n辽工大坐落在葫芦岛兴城，四周山水环绕，风景秀美。\n除了夏日太热，冬日太冷，平常风太大以外，几乎没有缺点。\n工大er们大多热情、优秀，<del>还很逗比</del>。","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2019-05-04 22:27:14\ntags: \ncategories: \n---\n<br/>\n我毕业于<del>一所技术院校</del>辽宁工程技术大学，是一名通信学子。\n大一的时候学做 ppt，大二的时候搞 Ps 和 Ae ，大三上学期无意间被网页上的动画效果吸引，大四的时候迈入了前端的坑。\n\n### 关于通信\n上大学的时候，同学们都调侃，“为啥通信的学生要学这么多，几乎电信学院的各个专业各科我们都会掺和一脚”。大三上专业课的时候，学习`信号与系统`、`通信原理`，`移动通信`，...铺天盖地的数学砸下来，才知道：“哦，原来通信是搞数学的。”\n<del>用专业的话说，通信也是考量人发量的一门学科。</del>。\n\n### 关于前端\n一入前端深似海，从此学习常相伴。\n前端知识面广而杂，计算机专业基础知识的欠缺，让我无时不刻觉得<del>我应该在土里，不是在前端的坑底</del>认真学习的重要性。\nGood good study, day day up ╰(￣▽￣)╭ .\n\n### 关于我\n大三的时候，身边的大多数同学决定考研，继续研究<del>数学</del>通信。\n而当时的我，一手掐着前端的学习资料，一手抱着通信课本，毅然决然的准备成为一名准前端er。\n<del>现在，我在一家互联网金融公司继续挖坑、填坑。</del>\n现在，我在一家二手交易平台继续打酱油。\n\n### 关于辽工大\n辽工大坐落在葫芦岛兴城，四周山水环绕，风景秀美。\n除了夏日太热，冬日太冷，平常风太大以外，几乎没有缺点。\n工大er们大多热情、优秀，<del>还很逗比</del>。","updated":"2020-11-04T08:29:30.883Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckmkbbo4000357vvupqy4o661","content":"<p><br><br>我毕业于<del>一所技术院校</del>辽宁工程技术大学，是一名通信学子。<br>大一的时候学做 ppt，大二的时候搞 Ps 和 Ae ，大三上学期无意间被网页上的动画效果吸引，大四的时候迈入了前端的坑。</p>\n<h3 id=\"关于通信\"><a href=\"#关于通信\" class=\"headerlink\" title=\"关于通信\"></a>关于通信</h3><p>上大学的时候，同学们都调侃，“为啥通信的学生要学这么多，几乎电信学院的各个专业各科我们都会掺和一脚”。大三上专业课的时候，学习<code>信号与系统</code>、<code>通信原理</code>，<code>移动通信</code>，…铺天盖地的数学砸下来，才知道：“哦，原来通信是搞数学的。”<br><del>用专业的话说，通信也是考量人发量的一门学科。</del>。</p>\n<h3 id=\"关于前端\"><a href=\"#关于前端\" class=\"headerlink\" title=\"关于前端\"></a>关于前端</h3><p>一入前端深似海，从此学习常相伴。<br>前端知识面广而杂，计算机专业基础知识的欠缺，让我无时不刻觉得<del>我应该在土里，不是在前端的坑底</del>认真学习的重要性。<br>Good good study, day day up ╰(￣▽￣)╭ .</p>\n<h3 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h3><p>大三的时候，身边的大多数同学决定考研，继续研究<del>数学</del>通信。<br>而当时的我，一手掐着前端的学习资料，一手抱着通信课本，毅然决然的准备成为一名准前端er。<br><del>现在，我在一家互联网金融公司继续挖坑、填坑。</del><br>现在，我在一家二手交易平台继续打酱油。</p>\n<h3 id=\"关于辽工大\"><a href=\"#关于辽工大\" class=\"headerlink\" title=\"关于辽工大\"></a>关于辽工大</h3><p>辽工大坐落在葫芦岛兴城，四周山水环绕，风景秀美。<br>除了夏日太热，冬日太冷，平常风太大以外，几乎没有缺点。<br>工大er们大多热情、优秀，<del>还很逗比</del>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><br><br>我毕业于<del>一所技术院校</del>辽宁工程技术大学，是一名通信学子。<br>大一的时候学做 ppt，大二的时候搞 Ps 和 Ae ，大三上学期无意间被网页上的动画效果吸引，大四的时候迈入了前端的坑。</p>\n<h3 id=\"关于通信\"><a href=\"#关于通信\" class=\"headerlink\" title=\"关于通信\"></a>关于通信</h3><p>上大学的时候，同学们都调侃，“为啥通信的学生要学这么多，几乎电信学院的各个专业各科我们都会掺和一脚”。大三上专业课的时候，学习<code>信号与系统</code>、<code>通信原理</code>，<code>移动通信</code>，…铺天盖地的数学砸下来，才知道：“哦，原来通信是搞数学的。”<br><del>用专业的话说，通信也是考量人发量的一门学科。</del>。</p>\n<h3 id=\"关于前端\"><a href=\"#关于前端\" class=\"headerlink\" title=\"关于前端\"></a>关于前端</h3><p>一入前端深似海，从此学习常相伴。<br>前端知识面广而杂，计算机专业基础知识的欠缺，让我无时不刻觉得<del>我应该在土里，不是在前端的坑底</del>认真学习的重要性。<br>Good good study, day day up ╰(￣▽￣)╭ .</p>\n<h3 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h3><p>大三的时候，身边的大多数同学决定考研，继续研究<del>数学</del>通信。<br>而当时的我，一手掐着前端的学习资料，一手抱着通信课本，毅然决然的准备成为一名准前端er。<br><del>现在，我在一家互联网金融公司继续挖坑、填坑。</del><br>现在，我在一家二手交易平台继续打酱油。</p>\n<h3 id=\"关于辽工大\"><a href=\"#关于辽工大\" class=\"headerlink\" title=\"关于辽工大\"></a>关于辽工大</h3><p>辽工大坐落在葫芦岛兴城，四周山水环绕，风景秀美。<br>除了夏日太热，冬日太冷，平常风太大以外，几乎没有缺点。<br>工大er们大多热情、优秀，<del>还很逗比</del>。</p>\n"},{"date":"2018-09-07T02:16:55.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\n# title: tags\ndate: 2018-09-07 10:16:55\ntype: tags\n---\n","updated":"2020-11-04T08:29:30.883Z","path":"tags/index.html","title":"","comments":1,"layout":"page","_id":"ckmkbbo4100367vvubftlavnx","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2018年终总结","date":"2018-12-31T15:26:27.000Z","_content":"2018年仿佛什么都没做，但又仿佛做了些什么；仿佛没有遗憾，但却又心有不甘；以为走到了正确的方向，但“迷茫”二字却困惑了我整整一年。\n<!--more-->\n\n* 一月：实习、回校考试\n* 二月：回家过年\n* 三月：实习、回校选毕设题目\n* 四月：实习、学习毕设相关知识、投递简历\n* 五月：实习、开始码毕设、投递简历、跑面试\n* 六月：回校答辩、毕业\n* 七月：转正，回公司工作\n* 八月：工作、去当了一次漫展NPC\n* 九月：工作、去了一次上海迪士尼\n* 十月：工作、找房、换房\n* 十一月：工作\n* 十二月：工作\n\n18年主要完成事件就是这些。\n__四、五月__ 大概是最忙的时候，因为要管的事情太多，忙到脚打后脑勺。\n__六月__ 是全年最开心的阶段，因为回学校了，有室友和同学在。虽然答辩时被老师问到怀疑人生，但最后老师还是给了高分，借此拿了一次奖学金的我也是受宠若惊，以为毕业前再也没有机会拿到了。除了感谢老师以外，还得感谢公司leader，毕设题目是他建议的。\n__七月__ 本决定给自己一周毕业旅行的时间，奈何职业方向和家里人冲突升级。取消了打算已久的假期，回公司了。工位发生很大变化，前端组的大家这次都坐在一起了。\n__八月__ 第一次去了漫展，也是第一次当NPC，不过应该也都是最后一次了哈哈。遇见了很好的小伙伴们，临走前，没有张口要联系方式，挺后悔的。\n__九月__ 去了趟迪士尼，事实证明，做攻略还是非常有用滴，项目都玩了，喜欢的也几刷了。遗憾的是，时间来不及，没有买到漫威周边。\n__十月__ 相对轻松。十一没出去玩，出去看房，找到合适的就换了，室友也换了，承蒙了之前两位姐姐很多照顾，有时会怀念。十月末公司团建，挺好玩的。\n__十一月__，中旬心心念念的 blog 诞生了，虽然不难，但也是历史性的一步！毕竟从去年就开始惦记着...\n__十二月__，成长。双十二的时候，买了新水彩颜料，终于把雄狮换成鲁本斯了。\n\n18年看似很充实，实际一年到头可以收获的东西却寥寥无几，全年没有明确的方向，只是被时间推着做事。\n希望19年找到自己的目标和方向。","source":"_posts/2018年终总结.md","raw":"---\ntitle: 2018年终总结\ndate: 2018-12-31 23:26:27\ntags: [年度总结]\n---\n2018年仿佛什么都没做，但又仿佛做了些什么；仿佛没有遗憾，但却又心有不甘；以为走到了正确的方向，但“迷茫”二字却困惑了我整整一年。\n<!--more-->\n\n* 一月：实习、回校考试\n* 二月：回家过年\n* 三月：实习、回校选毕设题目\n* 四月：实习、学习毕设相关知识、投递简历\n* 五月：实习、开始码毕设、投递简历、跑面试\n* 六月：回校答辩、毕业\n* 七月：转正，回公司工作\n* 八月：工作、去当了一次漫展NPC\n* 九月：工作、去了一次上海迪士尼\n* 十月：工作、找房、换房\n* 十一月：工作\n* 十二月：工作\n\n18年主要完成事件就是这些。\n__四、五月__ 大概是最忙的时候，因为要管的事情太多，忙到脚打后脑勺。\n__六月__ 是全年最开心的阶段，因为回学校了，有室友和同学在。虽然答辩时被老师问到怀疑人生，但最后老师还是给了高分，借此拿了一次奖学金的我也是受宠若惊，以为毕业前再也没有机会拿到了。除了感谢老师以外，还得感谢公司leader，毕设题目是他建议的。\n__七月__ 本决定给自己一周毕业旅行的时间，奈何职业方向和家里人冲突升级。取消了打算已久的假期，回公司了。工位发生很大变化，前端组的大家这次都坐在一起了。\n__八月__ 第一次去了漫展，也是第一次当NPC，不过应该也都是最后一次了哈哈。遇见了很好的小伙伴们，临走前，没有张口要联系方式，挺后悔的。\n__九月__ 去了趟迪士尼，事实证明，做攻略还是非常有用滴，项目都玩了，喜欢的也几刷了。遗憾的是，时间来不及，没有买到漫威周边。\n__十月__ 相对轻松。十一没出去玩，出去看房，找到合适的就换了，室友也换了，承蒙了之前两位姐姐很多照顾，有时会怀念。十月末公司团建，挺好玩的。\n__十一月__，中旬心心念念的 blog 诞生了，虽然不难，但也是历史性的一步！毕竟从去年就开始惦记着...\n__十二月__，成长。双十二的时候，买了新水彩颜料，终于把雄狮换成鲁本斯了。\n\n18年看似很充实，实际一年到头可以收获的东西却寥寥无几，全年没有明确的方向，只是被时间推着做事。\n希望19年找到自己的目标和方向。","slug":"2018年终总结","published":1,"updated":"2020-11-04T08:29:30.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0300007vvundulmx8m","content":"<p>2018年仿佛什么都没做，但又仿佛做了些什么；仿佛没有遗憾，但却又心有不甘；以为走到了正确的方向，但“迷茫”二字却困惑了我整整一年。<br><a id=\"more\"></a></p>\n<ul>\n<li>一月：实习、回校考试</li>\n<li>二月：回家过年</li>\n<li>三月：实习、回校选毕设题目</li>\n<li>四月：实习、学习毕设相关知识、投递简历</li>\n<li>五月：实习、开始码毕设、投递简历、跑面试</li>\n<li>六月：回校答辩、毕业</li>\n<li>七月：转正，回公司工作</li>\n<li>八月：工作、去当了一次漫展NPC</li>\n<li>九月：工作、去了一次上海迪士尼</li>\n<li>十月：工作、找房、换房</li>\n<li>十一月：工作</li>\n<li>十二月：工作</li>\n</ul>\n<p>18年主要完成事件就是这些。<br><strong>四、五月</strong> 大概是最忙的时候，因为要管的事情太多，忙到脚打后脑勺。<br><strong>六月</strong> 是全年最开心的阶段，因为回学校了，有室友和同学在。虽然答辩时被老师问到怀疑人生，但最后老师还是给了高分，借此拿了一次奖学金的我也是受宠若惊，以为毕业前再也没有机会拿到了。除了感谢老师以外，还得感谢公司leader，毕设题目是他建议的。<br><strong>七月</strong> 本决定给自己一周毕业旅行的时间，奈何职业方向和家里人冲突升级。取消了打算已久的假期，回公司了。工位发生很大变化，前端组的大家这次都坐在一起了。<br><strong>八月</strong> 第一次去了漫展，也是第一次当NPC，不过应该也都是最后一次了哈哈。遇见了很好的小伙伴们，临走前，没有张口要联系方式，挺后悔的。<br><strong>九月</strong> 去了趟迪士尼，事实证明，做攻略还是非常有用滴，项目都玩了，喜欢的也几刷了。遗憾的是，时间来不及，没有买到漫威周边。<br><strong>十月</strong> 相对轻松。十一没出去玩，出去看房，找到合适的就换了，室友也换了，承蒙了之前两位姐姐很多照顾，有时会怀念。十月末公司团建，挺好玩的。<br><strong>十一月</strong>，中旬心心念念的 blog 诞生了，虽然不难，但也是历史性的一步！毕竟从去年就开始惦记着…<br><strong>十二月</strong>，成长。双十二的时候，买了新水彩颜料，终于把雄狮换成鲁本斯了。</p>\n<p>18年看似很充实，实际一年到头可以收获的东西却寥寥无几，全年没有明确的方向，只是被时间推着做事。<br>希望19年找到自己的目标和方向。</p>\n","site":{"data":{}},"excerpt":"<p>2018年仿佛什么都没做，但又仿佛做了些什么；仿佛没有遗憾，但却又心有不甘；以为走到了正确的方向，但“迷茫”二字却困惑了我整整一年。<br></p>","more":"<p></p>\n<ul>\n<li>一月：实习、回校考试</li>\n<li>二月：回家过年</li>\n<li>三月：实习、回校选毕设题目</li>\n<li>四月：实习、学习毕设相关知识、投递简历</li>\n<li>五月：实习、开始码毕设、投递简历、跑面试</li>\n<li>六月：回校答辩、毕业</li>\n<li>七月：转正，回公司工作</li>\n<li>八月：工作、去当了一次漫展NPC</li>\n<li>九月：工作、去了一次上海迪士尼</li>\n<li>十月：工作、找房、换房</li>\n<li>十一月：工作</li>\n<li>十二月：工作</li>\n</ul>\n<p>18年主要完成事件就是这些。<br><strong>四、五月</strong> 大概是最忙的时候，因为要管的事情太多，忙到脚打后脑勺。<br><strong>六月</strong> 是全年最开心的阶段，因为回学校了，有室友和同学在。虽然答辩时被老师问到怀疑人生，但最后老师还是给了高分，借此拿了一次奖学金的我也是受宠若惊，以为毕业前再也没有机会拿到了。除了感谢老师以外，还得感谢公司leader，毕设题目是他建议的。<br><strong>七月</strong> 本决定给自己一周毕业旅行的时间，奈何职业方向和家里人冲突升级。取消了打算已久的假期，回公司了。工位发生很大变化，前端组的大家这次都坐在一起了。<br><strong>八月</strong> 第一次去了漫展，也是第一次当NPC，不过应该也都是最后一次了哈哈。遇见了很好的小伙伴们，临走前，没有张口要联系方式，挺后悔的。<br><strong>九月</strong> 去了趟迪士尼，事实证明，做攻略还是非常有用滴，项目都玩了，喜欢的也几刷了。遗憾的是，时间来不及，没有买到漫威周边。<br><strong>十月</strong> 相对轻松。十一没出去玩，出去看房，找到合适的就换了，室友也换了，承蒙了之前两位姐姐很多照顾，有时会怀念。十月末公司团建，挺好玩的。<br><strong>十一月</strong>，中旬心心念念的 blog 诞生了，虽然不难，但也是历史性的一步！毕竟从去年就开始惦记着…<br><strong>十二月</strong>，成长。双十二的时候，买了新水彩颜料，终于把雄狮换成鲁本斯了。</p>\n<p>18年看似很充实，实际一年到头可以收获的东西却寥寥无几，全年没有明确的方向，只是被时间推着做事。<br>希望19年找到自己的目标和方向。</p>"},{"title":"2019年终总结","date":"2019-12-31T02:37:55.000Z","_content":"2019年终总结（✖️）\n2020待做清单（✔️）\n<!--more-->\n\n* 一月：工作\n* 二月：回家过年\n* 三月：PWA 离线缓存初步探索\n* 四月：多页应用 Service Worker 合适的落地方案持续寻找中（暂缓）；前端性能指标 Performance 采集上报\n* 五月：前端性能指标尝试用 Prometheus 监控系统记录并用 Grafana 做可视化，尝试结果并不好；其他工作中过了一遍 RabbitMQ 事件队列收发流程\n* 六月：Elasticsearch 日志监控系统初探，目的是根据日志中的某些关键词，发出微信、邮件告警通知\n* 七月：elk 告警通知进行落地测试调优，微信和邮箱刚开始差点被通知给炸没了...\n* 八月：告警通知发现了很多不规范的日志，以及某些机器大清早的刷接口...持续使用中...但怎样区分业务的错误日志和代码的错误日志一直是一个问题...\n* 九月：学习计算机网络相关知识\n* 十月：Flink 实时计算性能指标探索\n* 十一月：网络工程师考试\n* 十二月：灌水\n\n今年是工作上探索新技术比较多的一年，前端的、不止前端的...虽然最终落地实践并产生结果的并不多，但是多种类型和方向的尝试让我开拓了不少眼界。纵观全年技术探索，leader 在带我们建立 FE 团队的性能监控和异常监控系统方向上做努力。19年没搞完的总结，就是20年的todolist... \n希望 2020 年的我对技术研究能上升个层次，不仅仅是学习新技术、了解新技术带来什么好处，还要能想到引入新技术带来的一系列后续的优化和落地。\n\n其他方面，就是缺少的计科知识，出来混，总要还的。报了个网工的考试督促自己系统学习下计科网络相关的知识，然后用实力证明忘的比学的快。\n\n__二月份__ 回家过年无聊的时候下了个游戏叫《守望先锋》，从人机模式简单->困难，到快速游戏，再到竞技比赛：体验团队合作游戏的乐趣 + 1，一言不合口吐芬芳 + 10086 。概括起来就是，如果这局赢了，那是队友真强；如果这局输了，那是我正常发挥。不知不觉，这游戏已经玩了一年了...\n__六月底__ 终于不堪某水果的电池续航和微信卡顿问题转战 HUAWEI 阵营，不得不说，真香...，但是安卓9下的抓包真是让我脑壳疼了好几天...\n__八月份__ gxTodo 总是莫名其妙的卡死崩溃，改用【滴答清单】了。印象笔记也是真的好用...\n__十月份__ 找房换房。没想到第一次坐在电动车后面吹着微风晒着暖阳周游北京，居然是自如管家驮着我。带我看房的自如管家是位体型娇小的南方妹子，我站在她面前就像是一个五大三粗的钢铁硬汉...怪不好意思的...\n__十一月份__ 软考北京考点在房山...(╯°□°）╯︵┻━┻)\n\n19年还算充实，虽然相比于18年更宅了一点...最大的希望就是在 2020 年懒癌和拖延症能治好，找到比较感兴趣的东西。还有，别迟到。","source":"_posts/2019年终总结.md","raw":"---\ntitle: 2019年终总结\ndate: 2019-12-31 10:37:55\ntags: [年度总结]\ncategories:\n---\n2019年终总结（✖️）\n2020待做清单（✔️）\n<!--more-->\n\n* 一月：工作\n* 二月：回家过年\n* 三月：PWA 离线缓存初步探索\n* 四月：多页应用 Service Worker 合适的落地方案持续寻找中（暂缓）；前端性能指标 Performance 采集上报\n* 五月：前端性能指标尝试用 Prometheus 监控系统记录并用 Grafana 做可视化，尝试结果并不好；其他工作中过了一遍 RabbitMQ 事件队列收发流程\n* 六月：Elasticsearch 日志监控系统初探，目的是根据日志中的某些关键词，发出微信、邮件告警通知\n* 七月：elk 告警通知进行落地测试调优，微信和邮箱刚开始差点被通知给炸没了...\n* 八月：告警通知发现了很多不规范的日志，以及某些机器大清早的刷接口...持续使用中...但怎样区分业务的错误日志和代码的错误日志一直是一个问题...\n* 九月：学习计算机网络相关知识\n* 十月：Flink 实时计算性能指标探索\n* 十一月：网络工程师考试\n* 十二月：灌水\n\n今年是工作上探索新技术比较多的一年，前端的、不止前端的...虽然最终落地实践并产生结果的并不多，但是多种类型和方向的尝试让我开拓了不少眼界。纵观全年技术探索，leader 在带我们建立 FE 团队的性能监控和异常监控系统方向上做努力。19年没搞完的总结，就是20年的todolist... \n希望 2020 年的我对技术研究能上升个层次，不仅仅是学习新技术、了解新技术带来什么好处，还要能想到引入新技术带来的一系列后续的优化和落地。\n\n其他方面，就是缺少的计科知识，出来混，总要还的。报了个网工的考试督促自己系统学习下计科网络相关的知识，然后用实力证明忘的比学的快。\n\n__二月份__ 回家过年无聊的时候下了个游戏叫《守望先锋》，从人机模式简单->困难，到快速游戏，再到竞技比赛：体验团队合作游戏的乐趣 + 1，一言不合口吐芬芳 + 10086 。概括起来就是，如果这局赢了，那是队友真强；如果这局输了，那是我正常发挥。不知不觉，这游戏已经玩了一年了...\n__六月底__ 终于不堪某水果的电池续航和微信卡顿问题转战 HUAWEI 阵营，不得不说，真香...，但是安卓9下的抓包真是让我脑壳疼了好几天...\n__八月份__ gxTodo 总是莫名其妙的卡死崩溃，改用【滴答清单】了。印象笔记也是真的好用...\n__十月份__ 找房换房。没想到第一次坐在电动车后面吹着微风晒着暖阳周游北京，居然是自如管家驮着我。带我看房的自如管家是位体型娇小的南方妹子，我站在她面前就像是一个五大三粗的钢铁硬汉...怪不好意思的...\n__十一月份__ 软考北京考点在房山...(╯°□°）╯︵┻━┻)\n\n19年还算充实，虽然相比于18年更宅了一点...最大的希望就是在 2020 年懒癌和拖延症能治好，找到比较感兴趣的东西。还有，别迟到。","slug":"2019年终总结","published":1,"updated":"2020-11-04T08:29:30.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0600017vvun1gd9b7q","content":"<p>2019年终总结（✖️）<br>2020待做清单（✔️）<br><a id=\"more\"></a></p>\n<ul>\n<li>一月：工作</li>\n<li>二月：回家过年</li>\n<li>三月：PWA 离线缓存初步探索</li>\n<li>四月：多页应用 Service Worker 合适的落地方案持续寻找中（暂缓）；前端性能指标 Performance 采集上报</li>\n<li>五月：前端性能指标尝试用 Prometheus 监控系统记录并用 Grafana 做可视化，尝试结果并不好；其他工作中过了一遍 RabbitMQ 事件队列收发流程</li>\n<li>六月：Elasticsearch 日志监控系统初探，目的是根据日志中的某些关键词，发出微信、邮件告警通知</li>\n<li>七月：elk 告警通知进行落地测试调优，微信和邮箱刚开始差点被通知给炸没了…</li>\n<li>八月：告警通知发现了很多不规范的日志，以及某些机器大清早的刷接口…持续使用中…但怎样区分业务的错误日志和代码的错误日志一直是一个问题…</li>\n<li>九月：学习计算机网络相关知识</li>\n<li>十月：Flink 实时计算性能指标探索</li>\n<li>十一月：网络工程师考试</li>\n<li>十二月：灌水</li>\n</ul>\n<p>今年是工作上探索新技术比较多的一年，前端的、不止前端的…虽然最终落地实践并产生结果的并不多，但是多种类型和方向的尝试让我开拓了不少眼界。纵观全年技术探索，leader 在带我们建立 FE 团队的性能监控和异常监控系统方向上做努力。19年没搞完的总结，就是20年的todolist…<br>希望 2020 年的我对技术研究能上升个层次，不仅仅是学习新技术、了解新技术带来什么好处，还要能想到引入新技术带来的一系列后续的优化和落地。</p>\n<p>其他方面，就是缺少的计科知识，出来混，总要还的。报了个网工的考试督促自己系统学习下计科网络相关的知识，然后用实力证明忘的比学的快。</p>\n<p><strong>二月份</strong> 回家过年无聊的时候下了个游戏叫《守望先锋》，从人机模式简单-&gt;困难，到快速游戏，再到竞技比赛：体验团队合作游戏的乐趣 + 1，一言不合口吐芬芳 + 10086 。概括起来就是，如果这局赢了，那是队友真强；如果这局输了，那是我正常发挥。不知不觉，这游戏已经玩了一年了…<br><strong>六月底</strong> 终于不堪某水果的电池续航和微信卡顿问题转战 HUAWEI 阵营，不得不说，真香…，但是安卓9下的抓包真是让我脑壳疼了好几天…<br><strong>八月份</strong> gxTodo 总是莫名其妙的卡死崩溃，改用【滴答清单】了。印象笔记也是真的好用…<br><strong>十月份</strong> 找房换房。没想到第一次坐在电动车后面吹着微风晒着暖阳周游北京，居然是自如管家驮着我。带我看房的自如管家是位体型娇小的南方妹子，我站在她面前就像是一个五大三粗的钢铁硬汉…怪不好意思的…<br><strong>十一月份</strong> 软考北京考点在房山…(╯°□°）╯︵┻━┻)</p>\n<p>19年还算充实，虽然相比于18年更宅了一点…最大的希望就是在 2020 年懒癌和拖延症能治好，找到比较感兴趣的东西。还有，别迟到。</p>\n","site":{"data":{}},"excerpt":"<p>2019年终总结（✖️）<br>2020待做清单（✔️）<br></p>","more":"<p></p>\n<ul>\n<li>一月：工作</li>\n<li>二月：回家过年</li>\n<li>三月：PWA 离线缓存初步探索</li>\n<li>四月：多页应用 Service Worker 合适的落地方案持续寻找中（暂缓）；前端性能指标 Performance 采集上报</li>\n<li>五月：前端性能指标尝试用 Prometheus 监控系统记录并用 Grafana 做可视化，尝试结果并不好；其他工作中过了一遍 RabbitMQ 事件队列收发流程</li>\n<li>六月：Elasticsearch 日志监控系统初探，目的是根据日志中的某些关键词，发出微信、邮件告警通知</li>\n<li>七月：elk 告警通知进行落地测试调优，微信和邮箱刚开始差点被通知给炸没了…</li>\n<li>八月：告警通知发现了很多不规范的日志，以及某些机器大清早的刷接口…持续使用中…但怎样区分业务的错误日志和代码的错误日志一直是一个问题…</li>\n<li>九月：学习计算机网络相关知识</li>\n<li>十月：Flink 实时计算性能指标探索</li>\n<li>十一月：网络工程师考试</li>\n<li>十二月：灌水</li>\n</ul>\n<p>今年是工作上探索新技术比较多的一年，前端的、不止前端的…虽然最终落地实践并产生结果的并不多，但是多种类型和方向的尝试让我开拓了不少眼界。纵观全年技术探索，leader 在带我们建立 FE 团队的性能监控和异常监控系统方向上做努力。19年没搞完的总结，就是20年的todolist…<br>希望 2020 年的我对技术研究能上升个层次，不仅仅是学习新技术、了解新技术带来什么好处，还要能想到引入新技术带来的一系列后续的优化和落地。</p>\n<p>其他方面，就是缺少的计科知识，出来混，总要还的。报了个网工的考试督促自己系统学习下计科网络相关的知识，然后用实力证明忘的比学的快。</p>\n<p><strong>二月份</strong> 回家过年无聊的时候下了个游戏叫《守望先锋》，从人机模式简单-&gt;困难，到快速游戏，再到竞技比赛：体验团队合作游戏的乐趣 + 1，一言不合口吐芬芳 + 10086 。概括起来就是，如果这局赢了，那是队友真强；如果这局输了，那是我正常发挥。不知不觉，这游戏已经玩了一年了…<br><strong>六月底</strong> 终于不堪某水果的电池续航和微信卡顿问题转战 HUAWEI 阵营，不得不说，真香…，但是安卓9下的抓包真是让我脑壳疼了好几天…<br><strong>八月份</strong> gxTodo 总是莫名其妙的卡死崩溃，改用【滴答清单】了。印象笔记也是真的好用…<br><strong>十月份</strong> 找房换房。没想到第一次坐在电动车后面吹着微风晒着暖阳周游北京，居然是自如管家驮着我。带我看房的自如管家是位体型娇小的南方妹子，我站在她面前就像是一个五大三粗的钢铁硬汉…怪不好意思的…<br><strong>十一月份</strong> 软考北京考点在房山…(╯°□°）╯︵┻━┻)</p>\n<p>19年还算充实，虽然相比于18年更宅了一点…最大的希望就是在 2020 年懒癌和拖延症能治好，找到比较感兴趣的东西。还有，别迟到。</p>"},{"title":"2020年终总结","date":"2020-12-31T11:07:34.000Z","_content":"2020年终总结（✖️）\n2020年流水账（✔️）\n<!--more-->\n\n* 1.22 __回家过年__\n* 2.9 __疫情__ 家里东拼西凑最好的口罩都给我拿到了北京，高铁上人很少，人们不怎么说话也不怎么吃东西\n* 3.20 __被裁__ P2P 行业终没能熬过政策寒冬，和之前的同事们由于疫情的原因最后也没能聚上一餐\n* 4.2 __新公司__ 入职某二手平台，开启9点后下班的生活\n* 4.4 __搬家__ 不搬家来公司要一个半小时\n* 5.1 __购入Switch__ 笔记本拿去维修了，于是买了心仪已久的 Switch 和塞尔达来消磨时光\n* 8.18 __同学婚礼__ 去了满洲里见证大学室友的婚礼，两三年不见，大家变化都很大，仿佛只有我还在原地\n* 9.27 __购入Mac Pro__ 赶着最后一波教育优惠，买了自己的 MacBook，顺带入了 Air Pods\n* 10.15 __搬家__ 又换房子了，房东不租了给了一个月搬家时间，自如赔付了一个月的房租\n* 10.29 __转正__ 改了六七版述职PPT，终于成为公司正式的一员了，有时会不禁会想，如果时间能回到以前就好了\n* 11.1 __欢乐谷__ 搭上万圣节的尾巴和公司的小伙伴们去了欢乐谷，各种失重旋转高速俯冲的过山车超级好玩，可是一起同行的小伙伴却说啥也不来第二次了\n* 12.8 __取消成都之旅__ 一场说走就走的成都之旅最终没能逃离疫情的影响，周五买的元旦机票也只能匆匆退掉\n* 12.28 __深圳&优化__ 一起吃饭的小伙伴有一位还在试用期，被”调“去了深圳，31号就是在公司的最后一天，有点不舍\n\n## 工作\n### 这一年，最大的变化就是换公司了吧。\n新公司 leader 人挺好，每月都会面谈与我们沟通，虽然我每次都不知道说什么，虽然每次的问题都没有什么变化。\n新公司的同事们都很年轻，也很 nice，虽然我依旧不是很健谈，饭桌上也总是沉默。\n\n__技术__：\n  * 之前没接触过小程序，没用过 TS，也没用过 React，今年在工作中都浅浅的用到了；\n  * 公司内很多内部封装好的组件库，用起来很方便，也有专门负责维护的同学；\n  * 内部技术分享很丰富，但自己的消化速度没想象那么强；\n  \n__作息__：疫情期间找工作，虽然已经做好了就算新公司是 996 也无所谓的准备，但真的接触这种作息才发现，如果可以我还是希望有自己的时间；\n\n### 购入 Mac\n在公司配备的 Windows 上设计稿总是展示不完全，要么看不清阴影，要么找不到虚线，被设计谈了两三次之后，索性就买了。\n刚开始不是很适应新版 Mac 的键盘手感，后来敲着敲着也无所谓了。\nAir Pods 着实很惊艳，开启降噪模式，专心程度 up~up~。\n\n### 神奇的小程序（uniapp + ts）\n首次接触小程序还是在实习的时候，在学校的一个课题中用过一点，当时也没觉得什么。但是新公司小程序体积很大，改一行代码，编译要好久好久...先要等 uniapp 编译完，然后要等小程序开发者工具编译，这两段编译时间足够我接杯水顺便去上个厕所；\n6、7月份的时候想要尝试过去优化这个编译速度，却发现无从下手，小程序项目的编译工具是 uniapp 自己的，开发者工具的编译也无法介入，最后组内同事给出一个方案，就是注释掉开发中不需要的路由，然而速度依然差强人意；\n买了 Mac 之后，以为多少速度能快点，神奇的是，不仅没快，全量编译小程序一不小心就能把 Mac 搞死机，看着黑屏的电脑，我不仅发出感叹：”这，就是小程序的力量吗。“\n\n## 生活\n### 无法拉上拉链的伴娘服。\n刚收到大学室友结婚消息的时候，还是挺震惊的，我们还一起相聚的夜晚仿佛还在昨天，现在算算，我都已经工作两年半了，毕业一别就我们就没再见过面。\n室友是辽宁人，是我们正儿八经的东北妹砸，远嫁到了内蒙古，很佩服她的勇气，毕竟亲人和好友都不在那边，而且是一个全新的生活环境。\n也是靠着这次机会，和久别的同学见了一面。感觉大家都变了，大部分已经褪去了学生的稚气，仿佛只有我，也只有我，行为处事依旧像个没长大的学生。\n草原很美，一望无垠，很羡慕这里的生活节奏，草原上的牛羊偶尔成团，偶尔散开，都是低着头各吃各的草。\n坐了两个小时的车，从满洲里到新左旗。从乌云密布下着雨的草原一边，行驶到只有落日和霞光的另一边，如此美景，想发朋友圈却没信号。\n见了新娘，感叹时光飞逝，试了伴娘服，感叹体重为什么不飞逝；加之参加婚礼之前，去剪了剪头发，婚礼当天的我就像是个胖胖的人妖，丢人到是没有，辣眼倒是会有一点。\n要走了，拥抱一下，一转身两行热泪就下来了：”为什么哭了？“，”因为明天还要上班...“。\n\n### 身体\n虽然逢人便说”我还年轻“，虽然别人也常说”你还年轻“，但身体仿佛已经不太认同年轻这两个字了。\n越来越重的眼袋和越来越僵硬的后背，连尾椎的疼痛也变得越来越难以忍受。\n除此之外，体重也以肉眼可见的速度上涨，如此说来，今年自己都没有做过几顿饭，全靠外卖过活。\n再这样下去，怕是要早早步入 ICU 了。\n\n## 这一年\n这一年，即使有千百种不适应，也要有千百种方式去适应。\n\n絮叨絮叨，一年比一年能叨叨，年终总结写的像越来越像流水账。挺丧的一年，年底之前还是没能去海拉鲁城堡看公主一眼，也没能跟帮助过的我人道声谢，崩坏的查莉娅线稿依旧没能画完...\n\n对 2021 没有特别想立的 flag，希望做一些正确的事吧。\n\nPS: 不要听民谣写年终总结， (╯°□°）╯（ ┻━┻ 越写越丧。","source":"_posts/2020年终总结.md","raw":"---\ntitle: 2020年终总结\ndate: 2020-12-31 19:07:34\ntags: [年度总结]\ncategories:\n---\n2020年终总结（✖️）\n2020年流水账（✔️）\n<!--more-->\n\n* 1.22 __回家过年__\n* 2.9 __疫情__ 家里东拼西凑最好的口罩都给我拿到了北京，高铁上人很少，人们不怎么说话也不怎么吃东西\n* 3.20 __被裁__ P2P 行业终没能熬过政策寒冬，和之前的同事们由于疫情的原因最后也没能聚上一餐\n* 4.2 __新公司__ 入职某二手平台，开启9点后下班的生活\n* 4.4 __搬家__ 不搬家来公司要一个半小时\n* 5.1 __购入Switch__ 笔记本拿去维修了，于是买了心仪已久的 Switch 和塞尔达来消磨时光\n* 8.18 __同学婚礼__ 去了满洲里见证大学室友的婚礼，两三年不见，大家变化都很大，仿佛只有我还在原地\n* 9.27 __购入Mac Pro__ 赶着最后一波教育优惠，买了自己的 MacBook，顺带入了 Air Pods\n* 10.15 __搬家__ 又换房子了，房东不租了给了一个月搬家时间，自如赔付了一个月的房租\n* 10.29 __转正__ 改了六七版述职PPT，终于成为公司正式的一员了，有时会不禁会想，如果时间能回到以前就好了\n* 11.1 __欢乐谷__ 搭上万圣节的尾巴和公司的小伙伴们去了欢乐谷，各种失重旋转高速俯冲的过山车超级好玩，可是一起同行的小伙伴却说啥也不来第二次了\n* 12.8 __取消成都之旅__ 一场说走就走的成都之旅最终没能逃离疫情的影响，周五买的元旦机票也只能匆匆退掉\n* 12.28 __深圳&优化__ 一起吃饭的小伙伴有一位还在试用期，被”调“去了深圳，31号就是在公司的最后一天，有点不舍\n\n## 工作\n### 这一年，最大的变化就是换公司了吧。\n新公司 leader 人挺好，每月都会面谈与我们沟通，虽然我每次都不知道说什么，虽然每次的问题都没有什么变化。\n新公司的同事们都很年轻，也很 nice，虽然我依旧不是很健谈，饭桌上也总是沉默。\n\n__技术__：\n  * 之前没接触过小程序，没用过 TS，也没用过 React，今年在工作中都浅浅的用到了；\n  * 公司内很多内部封装好的组件库，用起来很方便，也有专门负责维护的同学；\n  * 内部技术分享很丰富，但自己的消化速度没想象那么强；\n  \n__作息__：疫情期间找工作，虽然已经做好了就算新公司是 996 也无所谓的准备，但真的接触这种作息才发现，如果可以我还是希望有自己的时间；\n\n### 购入 Mac\n在公司配备的 Windows 上设计稿总是展示不完全，要么看不清阴影，要么找不到虚线，被设计谈了两三次之后，索性就买了。\n刚开始不是很适应新版 Mac 的键盘手感，后来敲着敲着也无所谓了。\nAir Pods 着实很惊艳，开启降噪模式，专心程度 up~up~。\n\n### 神奇的小程序（uniapp + ts）\n首次接触小程序还是在实习的时候，在学校的一个课题中用过一点，当时也没觉得什么。但是新公司小程序体积很大，改一行代码，编译要好久好久...先要等 uniapp 编译完，然后要等小程序开发者工具编译，这两段编译时间足够我接杯水顺便去上个厕所；\n6、7月份的时候想要尝试过去优化这个编译速度，却发现无从下手，小程序项目的编译工具是 uniapp 自己的，开发者工具的编译也无法介入，最后组内同事给出一个方案，就是注释掉开发中不需要的路由，然而速度依然差强人意；\n买了 Mac 之后，以为多少速度能快点，神奇的是，不仅没快，全量编译小程序一不小心就能把 Mac 搞死机，看着黑屏的电脑，我不仅发出感叹：”这，就是小程序的力量吗。“\n\n## 生活\n### 无法拉上拉链的伴娘服。\n刚收到大学室友结婚消息的时候，还是挺震惊的，我们还一起相聚的夜晚仿佛还在昨天，现在算算，我都已经工作两年半了，毕业一别就我们就没再见过面。\n室友是辽宁人，是我们正儿八经的东北妹砸，远嫁到了内蒙古，很佩服她的勇气，毕竟亲人和好友都不在那边，而且是一个全新的生活环境。\n也是靠着这次机会，和久别的同学见了一面。感觉大家都变了，大部分已经褪去了学生的稚气，仿佛只有我，也只有我，行为处事依旧像个没长大的学生。\n草原很美，一望无垠，很羡慕这里的生活节奏，草原上的牛羊偶尔成团，偶尔散开，都是低着头各吃各的草。\n坐了两个小时的车，从满洲里到新左旗。从乌云密布下着雨的草原一边，行驶到只有落日和霞光的另一边，如此美景，想发朋友圈却没信号。\n见了新娘，感叹时光飞逝，试了伴娘服，感叹体重为什么不飞逝；加之参加婚礼之前，去剪了剪头发，婚礼当天的我就像是个胖胖的人妖，丢人到是没有，辣眼倒是会有一点。\n要走了，拥抱一下，一转身两行热泪就下来了：”为什么哭了？“，”因为明天还要上班...“。\n\n### 身体\n虽然逢人便说”我还年轻“，虽然别人也常说”你还年轻“，但身体仿佛已经不太认同年轻这两个字了。\n越来越重的眼袋和越来越僵硬的后背，连尾椎的疼痛也变得越来越难以忍受。\n除此之外，体重也以肉眼可见的速度上涨，如此说来，今年自己都没有做过几顿饭，全靠外卖过活。\n再这样下去，怕是要早早步入 ICU 了。\n\n## 这一年\n这一年，即使有千百种不适应，也要有千百种方式去适应。\n\n絮叨絮叨，一年比一年能叨叨，年终总结写的像越来越像流水账。挺丧的一年，年底之前还是没能去海拉鲁城堡看公主一眼，也没能跟帮助过的我人道声谢，崩坏的查莉娅线稿依旧没能画完...\n\n对 2021 没有特别想立的 flag，希望做一些正确的事吧。\n\nPS: 不要听民谣写年终总结， (╯°□°）╯（ ┻━┻ 越写越丧。","slug":"2020年终总结","published":1,"updated":"2021-01-06T02:28:42.640Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0900037vvunl01h9xr","content":"<p>2020年终总结（✖️）<br>2020年流水账（✔️）<br><a id=\"more\"></a></p>\n<ul>\n<li>1.22 <strong>回家过年</strong></li>\n<li>2.9 <strong>疫情</strong> 家里东拼西凑最好的口罩都给我拿到了北京，高铁上人很少，人们不怎么说话也不怎么吃东西</li>\n<li>3.20 <strong>被裁</strong> P2P 行业终没能熬过政策寒冬，和之前的同事们由于疫情的原因最后也没能聚上一餐</li>\n<li>4.2 <strong>新公司</strong> 入职某二手平台，开启9点后下班的生活</li>\n<li>4.4 <strong>搬家</strong> 不搬家来公司要一个半小时</li>\n<li>5.1 <strong>购入Switch</strong> 笔记本拿去维修了，于是买了心仪已久的 Switch 和塞尔达来消磨时光</li>\n<li>8.18 <strong>同学婚礼</strong> 去了满洲里见证大学室友的婚礼，两三年不见，大家变化都很大，仿佛只有我还在原地</li>\n<li>9.27 <strong>购入Mac Pro</strong> 赶着最后一波教育优惠，买了自己的 MacBook，顺带入了 Air Pods</li>\n<li>10.15 <strong>搬家</strong> 又换房子了，房东不租了给了一个月搬家时间，自如赔付了一个月的房租</li>\n<li>10.29 <strong>转正</strong> 改了六七版述职PPT，终于成为公司正式的一员了，有时会不禁会想，如果时间能回到以前就好了</li>\n<li>11.1 <strong>欢乐谷</strong> 搭上万圣节的尾巴和公司的小伙伴们去了欢乐谷，各种失重旋转高速俯冲的过山车超级好玩，可是一起同行的小伙伴却说啥也不来第二次了</li>\n<li>12.8 <strong>取消成都之旅</strong> 一场说走就走的成都之旅最终没能逃离疫情的影响，周五买的元旦机票也只能匆匆退掉</li>\n<li>12.28 <strong>深圳&amp;优化</strong> 一起吃饭的小伙伴有一位还在试用期，被”调“去了深圳，31号就是在公司的最后一天，有点不舍</li>\n</ul>\n<h2 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h2><h3 id=\"这一年，最大的变化就是换公司了吧。\"><a href=\"#这一年，最大的变化就是换公司了吧。\" class=\"headerlink\" title=\"这一年，最大的变化就是换公司了吧。\"></a>这一年，最大的变化就是换公司了吧。</h3><p>新公司 leader 人挺好，每月都会面谈与我们沟通，虽然我每次都不知道说什么，虽然每次的问题都没有什么变化。<br>新公司的同事们都很年轻，也很 nice，虽然我依旧不是很健谈，饭桌上也总是沉默。</p>\n<p><strong>技术</strong>：</p>\n<ul>\n<li>之前没接触过小程序，没用过 TS，也没用过 React，今年在工作中都浅浅的用到了；</li>\n<li>公司内很多内部封装好的组件库，用起来很方便，也有专门负责维护的同学；</li>\n<li>内部技术分享很丰富，但自己的消化速度没想象那么强；</li>\n</ul>\n<p><strong>作息</strong>：疫情期间找工作，虽然已经做好了就算新公司是 996 也无所谓的准备，但真的接触这种作息才发现，如果可以我还是希望有自己的时间；</p>\n<h3 id=\"购入-Mac\"><a href=\"#购入-Mac\" class=\"headerlink\" title=\"购入 Mac\"></a>购入 Mac</h3><p>在公司配备的 Windows 上设计稿总是展示不完全，要么看不清阴影，要么找不到虚线，被设计谈了两三次之后，索性就买了。<br>刚开始不是很适应新版 Mac 的键盘手感，后来敲着敲着也无所谓了。<br>Air Pods 着实很惊艳，开启降噪模式，专心程度 up~up~。</p>\n<h3 id=\"神奇的小程序（uniapp-ts）\"><a href=\"#神奇的小程序（uniapp-ts）\" class=\"headerlink\" title=\"神奇的小程序（uniapp + ts）\"></a>神奇的小程序（uniapp + ts）</h3><p>首次接触小程序还是在实习的时候，在学校的一个课题中用过一点，当时也没觉得什么。但是新公司小程序体积很大，改一行代码，编译要好久好久…先要等 uniapp 编译完，然后要等小程序开发者工具编译，这两段编译时间足够我接杯水顺便去上个厕所；<br>6、7月份的时候想要尝试过去优化这个编译速度，却发现无从下手，小程序项目的编译工具是 uniapp 自己的，开发者工具的编译也无法介入，最后组内同事给出一个方案，就是注释掉开发中不需要的路由，然而速度依然差强人意；<br>买了 Mac 之后，以为多少速度能快点，神奇的是，不仅没快，全量编译小程序一不小心就能把 Mac 搞死机，看着黑屏的电脑，我不仅发出感叹：”这，就是小程序的力量吗。“</p>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><h3 id=\"无法拉上拉链的伴娘服。\"><a href=\"#无法拉上拉链的伴娘服。\" class=\"headerlink\" title=\"无法拉上拉链的伴娘服。\"></a>无法拉上拉链的伴娘服。</h3><p>刚收到大学室友结婚消息的时候，还是挺震惊的，我们还一起相聚的夜晚仿佛还在昨天，现在算算，我都已经工作两年半了，毕业一别就我们就没再见过面。<br>室友是辽宁人，是我们正儿八经的东北妹砸，远嫁到了内蒙古，很佩服她的勇气，毕竟亲人和好友都不在那边，而且是一个全新的生活环境。<br>也是靠着这次机会，和久别的同学见了一面。感觉大家都变了，大部分已经褪去了学生的稚气，仿佛只有我，也只有我，行为处事依旧像个没长大的学生。<br>草原很美，一望无垠，很羡慕这里的生活节奏，草原上的牛羊偶尔成团，偶尔散开，都是低着头各吃各的草。<br>坐了两个小时的车，从满洲里到新左旗。从乌云密布下着雨的草原一边，行驶到只有落日和霞光的另一边，如此美景，想发朋友圈却没信号。<br>见了新娘，感叹时光飞逝，试了伴娘服，感叹体重为什么不飞逝；加之参加婚礼之前，去剪了剪头发，婚礼当天的我就像是个胖胖的人妖，丢人到是没有，辣眼倒是会有一点。<br>要走了，拥抱一下，一转身两行热泪就下来了：”为什么哭了？“，”因为明天还要上班…“。</p>\n<h3 id=\"身体\"><a href=\"#身体\" class=\"headerlink\" title=\"身体\"></a>身体</h3><p>虽然逢人便说”我还年轻“，虽然别人也常说”你还年轻“，但身体仿佛已经不太认同年轻这两个字了。<br>越来越重的眼袋和越来越僵硬的后背，连尾椎的疼痛也变得越来越难以忍受。<br>除此之外，体重也以肉眼可见的速度上涨，如此说来，今年自己都没有做过几顿饭，全靠外卖过活。<br>再这样下去，怕是要早早步入 ICU 了。</p>\n<h2 id=\"这一年\"><a href=\"#这一年\" class=\"headerlink\" title=\"这一年\"></a>这一年</h2><p>这一年，即使有千百种不适应，也要有千百种方式去适应。</p>\n<p>絮叨絮叨，一年比一年能叨叨，年终总结写的像越来越像流水账。挺丧的一年，年底之前还是没能去海拉鲁城堡看公主一眼，也没能跟帮助过的我人道声谢，崩坏的查莉娅线稿依旧没能画完…</p>\n<p>对 2021 没有特别想立的 flag，希望做一些正确的事吧。</p>\n<p>PS: 不要听民谣写年终总结， (╯°□°）╯（ ┻━┻ 越写越丧。</p>\n","site":{"data":{}},"excerpt":"<p>2020年终总结（✖️）<br>2020年流水账（✔️）<br></p>","more":"<p></p>\n<ul>\n<li>1.22 <strong>回家过年</strong></li>\n<li>2.9 <strong>疫情</strong> 家里东拼西凑最好的口罩都给我拿到了北京，高铁上人很少，人们不怎么说话也不怎么吃东西</li>\n<li>3.20 <strong>被裁</strong> P2P 行业终没能熬过政策寒冬，和之前的同事们由于疫情的原因最后也没能聚上一餐</li>\n<li>4.2 <strong>新公司</strong> 入职某二手平台，开启9点后下班的生活</li>\n<li>4.4 <strong>搬家</strong> 不搬家来公司要一个半小时</li>\n<li>5.1 <strong>购入Switch</strong> 笔记本拿去维修了，于是买了心仪已久的 Switch 和塞尔达来消磨时光</li>\n<li>8.18 <strong>同学婚礼</strong> 去了满洲里见证大学室友的婚礼，两三年不见，大家变化都很大，仿佛只有我还在原地</li>\n<li>9.27 <strong>购入Mac Pro</strong> 赶着最后一波教育优惠，买了自己的 MacBook，顺带入了 Air Pods</li>\n<li>10.15 <strong>搬家</strong> 又换房子了，房东不租了给了一个月搬家时间，自如赔付了一个月的房租</li>\n<li>10.29 <strong>转正</strong> 改了六七版述职PPT，终于成为公司正式的一员了，有时会不禁会想，如果时间能回到以前就好了</li>\n<li>11.1 <strong>欢乐谷</strong> 搭上万圣节的尾巴和公司的小伙伴们去了欢乐谷，各种失重旋转高速俯冲的过山车超级好玩，可是一起同行的小伙伴却说啥也不来第二次了</li>\n<li>12.8 <strong>取消成都之旅</strong> 一场说走就走的成都之旅最终没能逃离疫情的影响，周五买的元旦机票也只能匆匆退掉</li>\n<li>12.28 <strong>深圳&amp;优化</strong> 一起吃饭的小伙伴有一位还在试用期，被”调“去了深圳，31号就是在公司的最后一天，有点不舍</li>\n</ul>\n<h2 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h2><h3 id=\"这一年，最大的变化就是换公司了吧。\"><a href=\"#这一年，最大的变化就是换公司了吧。\" class=\"headerlink\" title=\"这一年，最大的变化就是换公司了吧。\"></a>这一年，最大的变化就是换公司了吧。</h3><p>新公司 leader 人挺好，每月都会面谈与我们沟通，虽然我每次都不知道说什么，虽然每次的问题都没有什么变化。<br>新公司的同事们都很年轻，也很 nice，虽然我依旧不是很健谈，饭桌上也总是沉默。</p>\n<p><strong>技术</strong>：</p>\n<ul>\n<li>之前没接触过小程序，没用过 TS，也没用过 React，今年在工作中都浅浅的用到了；</li>\n<li>公司内很多内部封装好的组件库，用起来很方便，也有专门负责维护的同学；</li>\n<li>内部技术分享很丰富，但自己的消化速度没想象那么强；</li>\n</ul>\n<p><strong>作息</strong>：疫情期间找工作，虽然已经做好了就算新公司是 996 也无所谓的准备，但真的接触这种作息才发现，如果可以我还是希望有自己的时间；</p>\n<h3 id=\"购入-Mac\"><a href=\"#购入-Mac\" class=\"headerlink\" title=\"购入 Mac\"></a>购入 Mac</h3><p>在公司配备的 Windows 上设计稿总是展示不完全，要么看不清阴影，要么找不到虚线，被设计谈了两三次之后，索性就买了。<br>刚开始不是很适应新版 Mac 的键盘手感，后来敲着敲着也无所谓了。<br>Air Pods 着实很惊艳，开启降噪模式，专心程度 up~up~。</p>\n<h3 id=\"神奇的小程序（uniapp-ts）\"><a href=\"#神奇的小程序（uniapp-ts）\" class=\"headerlink\" title=\"神奇的小程序（uniapp + ts）\"></a>神奇的小程序（uniapp + ts）</h3><p>首次接触小程序还是在实习的时候，在学校的一个课题中用过一点，当时也没觉得什么。但是新公司小程序体积很大，改一行代码，编译要好久好久…先要等 uniapp 编译完，然后要等小程序开发者工具编译，这两段编译时间足够我接杯水顺便去上个厕所；<br>6、7月份的时候想要尝试过去优化这个编译速度，却发现无从下手，小程序项目的编译工具是 uniapp 自己的，开发者工具的编译也无法介入，最后组内同事给出一个方案，就是注释掉开发中不需要的路由，然而速度依然差强人意；<br>买了 Mac 之后，以为多少速度能快点，神奇的是，不仅没快，全量编译小程序一不小心就能把 Mac 搞死机，看着黑屏的电脑，我不仅发出感叹：”这，就是小程序的力量吗。“</p>\n<h2 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h2><h3 id=\"无法拉上拉链的伴娘服。\"><a href=\"#无法拉上拉链的伴娘服。\" class=\"headerlink\" title=\"无法拉上拉链的伴娘服。\"></a>无法拉上拉链的伴娘服。</h3><p>刚收到大学室友结婚消息的时候，还是挺震惊的，我们还一起相聚的夜晚仿佛还在昨天，现在算算，我都已经工作两年半了，毕业一别就我们就没再见过面。<br>室友是辽宁人，是我们正儿八经的东北妹砸，远嫁到了内蒙古，很佩服她的勇气，毕竟亲人和好友都不在那边，而且是一个全新的生活环境。<br>也是靠着这次机会，和久别的同学见了一面。感觉大家都变了，大部分已经褪去了学生的稚气，仿佛只有我，也只有我，行为处事依旧像个没长大的学生。<br>草原很美，一望无垠，很羡慕这里的生活节奏，草原上的牛羊偶尔成团，偶尔散开，都是低着头各吃各的草。<br>坐了两个小时的车，从满洲里到新左旗。从乌云密布下着雨的草原一边，行驶到只有落日和霞光的另一边，如此美景，想发朋友圈却没信号。<br>见了新娘，感叹时光飞逝，试了伴娘服，感叹体重为什么不飞逝；加之参加婚礼之前，去剪了剪头发，婚礼当天的我就像是个胖胖的人妖，丢人到是没有，辣眼倒是会有一点。<br>要走了，拥抱一下，一转身两行热泪就下来了：”为什么哭了？“，”因为明天还要上班…“。</p>\n<h3 id=\"身体\"><a href=\"#身体\" class=\"headerlink\" title=\"身体\"></a>身体</h3><p>虽然逢人便说”我还年轻“，虽然别人也常说”你还年轻“，但身体仿佛已经不太认同年轻这两个字了。<br>越来越重的眼袋和越来越僵硬的后背，连尾椎的疼痛也变得越来越难以忍受。<br>除此之外，体重也以肉眼可见的速度上涨，如此说来，今年自己都没有做过几顿饭，全靠外卖过活。<br>再这样下去，怕是要早早步入 ICU 了。</p>\n<h2 id=\"这一年\"><a href=\"#这一年\" class=\"headerlink\" title=\"这一年\"></a>这一年</h2><p>这一年，即使有千百种不适应，也要有千百种方式去适应。</p>\n<p>絮叨絮叨，一年比一年能叨叨，年终总结写的像越来越像流水账。挺丧的一年，年底之前还是没能去海拉鲁城堡看公主一眼，也没能跟帮助过的我人道声谢，崩坏的查莉娅线稿依旧没能画完…</p>\n<p>对 2021 没有特别想立的 flag，希望做一些正确的事吧。</p>\n<p>PS: 不要听民谣写年终总结， (╯°□°）╯（ ┻━┻ 越写越丧。</p>"},{"title":"Flink 初探","date":"2019-11-14T06:58:06.000Z","_content":"Apache Flink 是一个分布式处理引擎，在有界或无界数据流上进行有状态的计算。工作时偶然接触到一点点，有些概念虽然有点抽象，但是思路却值得借鉴。本文记录用 Flink 实时求均值、水印生成、以及迟到的数据元触发计算更新等等，是一篇纯探索性文章。<del>用笔记形式记录，以便忘记。</del>\n<!--more-->\n### Flink 中文官网 \n[https://flink.apachecn.org/docs/1.7-SNAPSHOT/#/](https://flink.apachecn.org/docs/1.7-SNAPSHOT/#/)\n\n### 一、Flink 简介\nFlink 是一个针对流数据和批数据的分布式处理引擎，代码主要是由 Java 实现，部分代码是 Scala。它可以处理有界的批量数据集、也可以处理无界的实时数据集。对 Flink 而言，其主要处理的场景就是流数据。<br/>\n\n### 二、流处理和批处理的区别\n__批处理__ 特点：离线、单次处理的数据量大、处理速度慢、非实时计算。常见的批处理就是数据库深夜定时跑任务，因为批量计算会占用大量资源。\n__流处理__ 特点：在线，单次处理数据量小、处理速度快、实时计算。常见的应用场景就是监控、统计、实时推荐等。\n\n### 三、学习目标\n用 Flink 消费已有数据源，实时计算数据均值，并允许数据元延迟到来时，重新触发计算。\n\n### 四、涉及到的名词概念\n1. __窗口__ (Windows)：对某段数据流进行统计，即统计区间；Windows 可以是时间驱动的（例如：每30秒）或数据驱动（例如：每100个数据元）。\n2. __时间__ (Time)：程序中引用的时间；Flink 支持三种时间：事件时间、摄取时间和处理时间。\n3. __算子__ (Operator)：Flink 内部提供的时间/数据流/数据元的处理函数。\n4. __时间戳__ (TimeStamp)/__水印__ (WaterMark)：使用数据源的时间或者系统时间为到来的数据元加上时间戳；数据流加上水印标记，为了等下个数据元到来时知道该数据元是否应该被包含在当前次计算中。\n__注：Watermark 是随数据产生的，窗口时间现在处于什么位置看 Watermark，只有新产生的一条数据超出窗口长度，这个窗口才会触发计算。(当使用事件时间窗口时，可能会发生数据元迟到的情况，则必须为数据流设置时间戳和水印)__\n   \n#### 允许迟到 allowedLateness\n只要应该属于此窗口的第一个数据元到达，就会创建一个窗口，当时间（事件或处理时间）超过其结束时间戳加上用户指定 allowed lateness 时，窗口将被完全删除。\n__allowedLateness 用来设置窗口销毁时间__，而 waterMark 是用来设置窗口激活时间。当时延迟时间超过 allowedLateness 设置的时间，这个计算窗口就会被销毁，开始下一个窗口，即使被销毁的窗口还没有触发计算。\n\n#### 窗口函数\nFlink 的窗口函数会暴露出数据流不同状态时的处理函数，具体的高级操作或者运算例如聚合、求均值等函数需要我们自己去实现。\n例如聚合窗口 `stream.aggregate` 的参数 AggregateFunction <IN, ACC, OUT>，具有三种的类型：输入类型(IN)、累加器类型(ACC)和输出类型(OUT)。\n使用 AggregateFunction 求均值（示例代码来自[官网](https://flink.apachecn.org/docs/1.7-SNAPSHOT/#/27?id=window-functions)）：\n````java\n    private static class AverageAggregate\n    implements AggregateFunction<Tuple2<String, Long>, Tuple2<Long, Long>, Double> {\n    @Override\n    public Tuple2<Long, Long> createAccumulator() {\n      return new Tuple2<>(0L, 0L);\n    }\n\n    @Override\n    public Tuple2<Long, Long> add(Tuple2<String, Long> value, Tuple2<Long, Long> accumulator) {\n      return new Tuple2<>(accumulator.f0 + value.f1, accumulator.f1 + 1L);\n    }\n\n    @Override\n    public Double getResult(Tuple2<Long, Long> accumulator) {\n      return ((double) accumulator.f0) / accumulator.f1;\n    }\n\n    @Override\n    public Tuple2<Long, Long> merge(Tuple2<Long, Long> a, Tuple2<Long, Long> b) {\n      return new Tuple2<>(a.f0 + b.f0, a.f1 + b.f1);\n    }\n\n    DataStream<Tuple2<String, Long>> input = ...;\n\n    input\n        .keyBy(<key selector>)\n        .window(<window assigner>)\n        .aggregate(new AverageAggregate());\n    }\n````\n\n### 五、遇到的问题\n* 数据流过滤后，只剩下被过滤的数据：\n  * __SingleOutputStreamOperator__ 旁路分支：这个分支用来获取被过滤掉的数据，并不是过滤后的数据。\n* 给数据流设置时间戳之后，迟到的数据没有被抛弃：\n  * __stream.assignTimestampsAndWatermarks__ 定期生成水印：最简单的特殊情况是给定源任务看到的时间戳按升序发生的情况。在这种情况下，当前时间戳始终可以充当水印，因为没有更早的时间戳会到达。且生成的时间戳会覆盖事件原有的，若存在迟到的数据元，用这个方法，则数据不会被抛弃。\n  * __BoundedOutOfOrdernessTimestampExtractor__ ：Flink 提供此参数为固定数量的迟到者分配时间戳和水印。若有数据元可能迟到的场景，请应用此方法。\n* [设置的水印时间戳，超时告警，但是数据没有被丢弃？](https://stackoverflow.com/questions/50114412/flink-watermark-and-triggers-late-elements-not-discarded-on-event-time)\n* [最新记录没有被统计，只有下一条数据写入时，之前的数据才会被触发统计？](https://developer.aliyun.com/ask/128431?spm=a2c6h.13159736)\n\n### 六、数据下沉 Data Sink\nFlink 可以自己指定数据源连接器，以及数据下沉(接收)目标。从 Flink 官网上来看连接器支持 Kalfa、Elasticsearch、HDFS、RabbitMQ 等等，公司已有 RabbitMQ 数据源，使用 RabbitMQ sink 接收数时，注意事件消费者不要和事件生产者的队列名不要相同，否则会报错。\n\n### 参考链接\n* [http://www.54tianzhisheng.cn/](http://www.54tianzhisheng.cn/)\n* [Flink 水印机制到底怎么回事](https://bbs.csdn.net/topics/392567642?list=70723145)\n* [Flink 水印机制](https://www.cnblogs.com/starzy/p/11439997.html)\n* [Flink实战--如何使用水印](https://blog.csdn.net/aA518189/article/details/85233247)\n* [Flink Window 的 Timestamps/Watermarks 和 allowedLateness 的区别](https://www.cnblogs.com/jiang-it/p/9280946.html)\n* [Flink 零基础实战教程：如何计算实时商品](http://wuchong.me/blog/2018/11/07/use-flink-calculate-hot-items/)\n* [《从0到1学习Flink》-- Flink读取 Kafka 数据写入到 RabbitMQ](https://cloud.tencent.com/developer/article/1419588)","source":"_posts/Flink-初探.md","raw":"---\ntitle: Flink 初探\ndate: 2019-11-14 14:58:06\ntags: [大数据, 流处理]\ncategories: 大数据\n---\nApache Flink 是一个分布式处理引擎，在有界或无界数据流上进行有状态的计算。工作时偶然接触到一点点，有些概念虽然有点抽象，但是思路却值得借鉴。本文记录用 Flink 实时求均值、水印生成、以及迟到的数据元触发计算更新等等，是一篇纯探索性文章。<del>用笔记形式记录，以便忘记。</del>\n<!--more-->\n### Flink 中文官网 \n[https://flink.apachecn.org/docs/1.7-SNAPSHOT/#/](https://flink.apachecn.org/docs/1.7-SNAPSHOT/#/)\n\n### 一、Flink 简介\nFlink 是一个针对流数据和批数据的分布式处理引擎，代码主要是由 Java 实现，部分代码是 Scala。它可以处理有界的批量数据集、也可以处理无界的实时数据集。对 Flink 而言，其主要处理的场景就是流数据。<br/>\n\n### 二、流处理和批处理的区别\n__批处理__ 特点：离线、单次处理的数据量大、处理速度慢、非实时计算。常见的批处理就是数据库深夜定时跑任务，因为批量计算会占用大量资源。\n__流处理__ 特点：在线，单次处理数据量小、处理速度快、实时计算。常见的应用场景就是监控、统计、实时推荐等。\n\n### 三、学习目标\n用 Flink 消费已有数据源，实时计算数据均值，并允许数据元延迟到来时，重新触发计算。\n\n### 四、涉及到的名词概念\n1. __窗口__ (Windows)：对某段数据流进行统计，即统计区间；Windows 可以是时间驱动的（例如：每30秒）或数据驱动（例如：每100个数据元）。\n2. __时间__ (Time)：程序中引用的时间；Flink 支持三种时间：事件时间、摄取时间和处理时间。\n3. __算子__ (Operator)：Flink 内部提供的时间/数据流/数据元的处理函数。\n4. __时间戳__ (TimeStamp)/__水印__ (WaterMark)：使用数据源的时间或者系统时间为到来的数据元加上时间戳；数据流加上水印标记，为了等下个数据元到来时知道该数据元是否应该被包含在当前次计算中。\n__注：Watermark 是随数据产生的，窗口时间现在处于什么位置看 Watermark，只有新产生的一条数据超出窗口长度，这个窗口才会触发计算。(当使用事件时间窗口时，可能会发生数据元迟到的情况，则必须为数据流设置时间戳和水印)__\n   \n#### 允许迟到 allowedLateness\n只要应该属于此窗口的第一个数据元到达，就会创建一个窗口，当时间（事件或处理时间）超过其结束时间戳加上用户指定 allowed lateness 时，窗口将被完全删除。\n__allowedLateness 用来设置窗口销毁时间__，而 waterMark 是用来设置窗口激活时间。当时延迟时间超过 allowedLateness 设置的时间，这个计算窗口就会被销毁，开始下一个窗口，即使被销毁的窗口还没有触发计算。\n\n#### 窗口函数\nFlink 的窗口函数会暴露出数据流不同状态时的处理函数，具体的高级操作或者运算例如聚合、求均值等函数需要我们自己去实现。\n例如聚合窗口 `stream.aggregate` 的参数 AggregateFunction <IN, ACC, OUT>，具有三种的类型：输入类型(IN)、累加器类型(ACC)和输出类型(OUT)。\n使用 AggregateFunction 求均值（示例代码来自[官网](https://flink.apachecn.org/docs/1.7-SNAPSHOT/#/27?id=window-functions)）：\n````java\n    private static class AverageAggregate\n    implements AggregateFunction<Tuple2<String, Long>, Tuple2<Long, Long>, Double> {\n    @Override\n    public Tuple2<Long, Long> createAccumulator() {\n      return new Tuple2<>(0L, 0L);\n    }\n\n    @Override\n    public Tuple2<Long, Long> add(Tuple2<String, Long> value, Tuple2<Long, Long> accumulator) {\n      return new Tuple2<>(accumulator.f0 + value.f1, accumulator.f1 + 1L);\n    }\n\n    @Override\n    public Double getResult(Tuple2<Long, Long> accumulator) {\n      return ((double) accumulator.f0) / accumulator.f1;\n    }\n\n    @Override\n    public Tuple2<Long, Long> merge(Tuple2<Long, Long> a, Tuple2<Long, Long> b) {\n      return new Tuple2<>(a.f0 + b.f0, a.f1 + b.f1);\n    }\n\n    DataStream<Tuple2<String, Long>> input = ...;\n\n    input\n        .keyBy(<key selector>)\n        .window(<window assigner>)\n        .aggregate(new AverageAggregate());\n    }\n````\n\n### 五、遇到的问题\n* 数据流过滤后，只剩下被过滤的数据：\n  * __SingleOutputStreamOperator__ 旁路分支：这个分支用来获取被过滤掉的数据，并不是过滤后的数据。\n* 给数据流设置时间戳之后，迟到的数据没有被抛弃：\n  * __stream.assignTimestampsAndWatermarks__ 定期生成水印：最简单的特殊情况是给定源任务看到的时间戳按升序发生的情况。在这种情况下，当前时间戳始终可以充当水印，因为没有更早的时间戳会到达。且生成的时间戳会覆盖事件原有的，若存在迟到的数据元，用这个方法，则数据不会被抛弃。\n  * __BoundedOutOfOrdernessTimestampExtractor__ ：Flink 提供此参数为固定数量的迟到者分配时间戳和水印。若有数据元可能迟到的场景，请应用此方法。\n* [设置的水印时间戳，超时告警，但是数据没有被丢弃？](https://stackoverflow.com/questions/50114412/flink-watermark-and-triggers-late-elements-not-discarded-on-event-time)\n* [最新记录没有被统计，只有下一条数据写入时，之前的数据才会被触发统计？](https://developer.aliyun.com/ask/128431?spm=a2c6h.13159736)\n\n### 六、数据下沉 Data Sink\nFlink 可以自己指定数据源连接器，以及数据下沉(接收)目标。从 Flink 官网上来看连接器支持 Kalfa、Elasticsearch、HDFS、RabbitMQ 等等，公司已有 RabbitMQ 数据源，使用 RabbitMQ sink 接收数时，注意事件消费者不要和事件生产者的队列名不要相同，否则会报错。\n\n### 参考链接\n* [http://www.54tianzhisheng.cn/](http://www.54tianzhisheng.cn/)\n* [Flink 水印机制到底怎么回事](https://bbs.csdn.net/topics/392567642?list=70723145)\n* [Flink 水印机制](https://www.cnblogs.com/starzy/p/11439997.html)\n* [Flink实战--如何使用水印](https://blog.csdn.net/aA518189/article/details/85233247)\n* [Flink Window 的 Timestamps/Watermarks 和 allowedLateness 的区别](https://www.cnblogs.com/jiang-it/p/9280946.html)\n* [Flink 零基础实战教程：如何计算实时商品](http://wuchong.me/blog/2018/11/07/use-flink-calculate-hot-items/)\n* [《从0到1学习Flink》-- Flink读取 Kafka 数据写入到 RabbitMQ](https://cloud.tencent.com/developer/article/1419588)","slug":"Flink-初探","published":1,"updated":"2020-11-04T08:29:30.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0a00047vvunwqob8q6","content":"<p>Apache Flink 是一个分布式处理引擎，在有界或无界数据流上进行有状态的计算。工作时偶然接触到一点点，有些概念虽然有点抽象，但是思路却值得借鉴。本文记录用 Flink 实时求均值、水印生成、以及迟到的数据元触发计算更新等等，是一篇纯探索性文章。<del>用笔记形式记录，以便忘记。</del><br><a id=\"more\"></a></p>\n<h3 id=\"Flink-中文官网\"><a href=\"#Flink-中文官网\" class=\"headerlink\" title=\"Flink 中文官网\"></a>Flink 中文官网</h3><p><a href=\"https://flink.apachecn.org/docs/1.7-SNAPSHOT/#/\" target=\"_blank\" rel=\"noopener\">https://flink.apachecn.org/docs/1.7-SNAPSHOT/#/</a></p>\n<h3 id=\"一、Flink-简介\"><a href=\"#一、Flink-简介\" class=\"headerlink\" title=\"一、Flink 简介\"></a>一、Flink 简介</h3><p>Flink 是一个针对流数据和批数据的分布式处理引擎，代码主要是由 Java 实现，部分代码是 Scala。它可以处理有界的批量数据集、也可以处理无界的实时数据集。对 Flink 而言，其主要处理的场景就是流数据。<br></p>\n<h3 id=\"二、流处理和批处理的区别\"><a href=\"#二、流处理和批处理的区别\" class=\"headerlink\" title=\"二、流处理和批处理的区别\"></a>二、流处理和批处理的区别</h3><p><strong>批处理</strong> 特点：离线、单次处理的数据量大、处理速度慢、非实时计算。常见的批处理就是数据库深夜定时跑任务，因为批量计算会占用大量资源。<br><strong>流处理</strong> 特点：在线，单次处理数据量小、处理速度快、实时计算。常见的应用场景就是监控、统计、实时推荐等。</p>\n<h3 id=\"三、学习目标\"><a href=\"#三、学习目标\" class=\"headerlink\" title=\"三、学习目标\"></a>三、学习目标</h3><p>用 Flink 消费已有数据源，实时计算数据均值，并允许数据元延迟到来时，重新触发计算。</p>\n<h3 id=\"四、涉及到的名词概念\"><a href=\"#四、涉及到的名词概念\" class=\"headerlink\" title=\"四、涉及到的名词概念\"></a>四、涉及到的名词概念</h3><ol>\n<li><strong>窗口</strong> (Windows)：对某段数据流进行统计，即统计区间；Windows 可以是时间驱动的（例如：每30秒）或数据驱动（例如：每100个数据元）。</li>\n<li><strong>时间</strong> (Time)：程序中引用的时间；Flink 支持三种时间：事件时间、摄取时间和处理时间。</li>\n<li><strong>算子</strong> (Operator)：Flink 内部提供的时间/数据流/数据元的处理函数。</li>\n<li><strong>时间戳</strong> (TimeStamp)/<strong>水印</strong> (WaterMark)：使用数据源的时间或者系统时间为到来的数据元加上时间戳；数据流加上水印标记，为了等下个数据元到来时知道该数据元是否应该被包含在当前次计算中。<br><strong>注：Watermark 是随数据产生的，窗口时间现在处于什么位置看 Watermark，只有新产生的一条数据超出窗口长度，这个窗口才会触发计算。(当使用事件时间窗口时，可能会发生数据元迟到的情况，则必须为数据流设置时间戳和水印)</strong></li>\n</ol>\n<h4 id=\"允许迟到-allowedLateness\"><a href=\"#允许迟到-allowedLateness\" class=\"headerlink\" title=\"允许迟到 allowedLateness\"></a>允许迟到 allowedLateness</h4><p>只要应该属于此窗口的第一个数据元到达，就会创建一个窗口，当时间（事件或处理时间）超过其结束时间戳加上用户指定 allowed lateness 时，窗口将被完全删除。<br><strong>allowedLateness 用来设置窗口销毁时间</strong>，而 waterMark 是用来设置窗口激活时间。当时延迟时间超过 allowedLateness 设置的时间，这个计算窗口就会被销毁，开始下一个窗口，即使被销毁的窗口还没有触发计算。</p>\n<h4 id=\"窗口函数\"><a href=\"#窗口函数\" class=\"headerlink\" title=\"窗口函数\"></a>窗口函数</h4><p>Flink 的窗口函数会暴露出数据流不同状态时的处理函数，具体的高级操作或者运算例如聚合、求均值等函数需要我们自己去实现。<br>例如聚合窗口 <code>stream.aggregate</code> 的参数 AggregateFunction &lt;IN, ACC, OUT&gt;，具有三种的类型：输入类型(IN)、累加器类型(ACC)和输出类型(OUT)。<br>使用 AggregateFunction 求均值（示例代码来自<a href=\"https://flink.apachecn.org/docs/1.7-SNAPSHOT/#/27?id=window-functions\" target=\"_blank\" rel=\"noopener\">官网</a>）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AverageAggregate</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">implements</span> <span class=\"title\">AggregateFunction</span>&lt;<span class=\"title\">Tuple2</span>&lt;<span class=\"title\">String</span>, <span class=\"title\">Long</span>&gt;, <span class=\"title\">Tuple2</span>&lt;<span class=\"title\">Long</span>, <span class=\"title\">Long</span>&gt;, <span class=\"title\">Double</span>&gt; </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Tuple2&lt;Long, Long&gt; <span class=\"title\">createAccumulator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Tuple2&lt;&gt;(<span class=\"number\">0L</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Tuple2&lt;Long, Long&gt; <span class=\"title\">add</span><span class=\"params\">(Tuple2&lt;String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Tuple2&lt;&gt;(accumulator.f0 + value.f1, accumulator.f1 + <span class=\"number\">1L</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Double <span class=\"title\">getResult</span><span class=\"params\">(Tuple2&lt;Long, Long&gt; accumulator)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ((<span class=\"keyword\">double</span>) accumulator.f0) / accumulator.f1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Tuple2&lt;Long, Long&gt; <span class=\"title\">merge</span><span class=\"params\">(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Tuple2&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class=\"line\"></span><br><span class=\"line\">input</span><br><span class=\"line\">    .keyBy(&lt;key selector&gt;)</span><br><span class=\"line\">    .window(&lt;window assigner&gt;)</span><br><span class=\"line\">    .aggregate(<span class=\"keyword\">new</span> AverageAggregate());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"五、遇到的问题\"><a href=\"#五、遇到的问题\" class=\"headerlink\" title=\"五、遇到的问题\"></a>五、遇到的问题</h3><ul>\n<li>数据流过滤后，只剩下被过滤的数据：<ul>\n<li><strong>SingleOutputStreamOperator</strong> 旁路分支：这个分支用来获取被过滤掉的数据，并不是过滤后的数据。</li>\n</ul>\n</li>\n<li>给数据流设置时间戳之后，迟到的数据没有被抛弃：<ul>\n<li><strong>stream.assignTimestampsAndWatermarks</strong> 定期生成水印：最简单的特殊情况是给定源任务看到的时间戳按升序发生的情况。在这种情况下，当前时间戳始终可以充当水印，因为没有更早的时间戳会到达。且生成的时间戳会覆盖事件原有的，若存在迟到的数据元，用这个方法，则数据不会被抛弃。</li>\n<li><strong>BoundedOutOfOrdernessTimestampExtractor</strong> ：Flink 提供此参数为固定数量的迟到者分配时间戳和水印。若有数据元可能迟到的场景，请应用此方法。</li>\n</ul>\n</li>\n<li><a href=\"https://stackoverflow.com/questions/50114412/flink-watermark-and-triggers-late-elements-not-discarded-on-event-time\" target=\"_blank\" rel=\"noopener\">设置的水印时间戳，超时告警，但是数据没有被丢弃？</a></li>\n<li><a href=\"https://developer.aliyun.com/ask/128431?spm=a2c6h.13159736\" target=\"_blank\" rel=\"noopener\">最新记录没有被统计，只有下一条数据写入时，之前的数据才会被触发统计？</a></li>\n</ul>\n<h3 id=\"六、数据下沉-Data-Sink\"><a href=\"#六、数据下沉-Data-Sink\" class=\"headerlink\" title=\"六、数据下沉 Data Sink\"></a>六、数据下沉 Data Sink</h3><p>Flink 可以自己指定数据源连接器，以及数据下沉(接收)目标。从 Flink 官网上来看连接器支持 Kalfa、Elasticsearch、HDFS、RabbitMQ 等等，公司已有 RabbitMQ 数据源，使用 RabbitMQ sink 接收数时，注意事件消费者不要和事件生产者的队列名不要相同，否则会报错。</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><ul>\n<li><a href=\"http://www.54tianzhisheng.cn/\" target=\"_blank\" rel=\"noopener\">http://www.54tianzhisheng.cn/</a></li>\n<li><a href=\"https://bbs.csdn.net/topics/392567642?list=70723145\" target=\"_blank\" rel=\"noopener\">Flink 水印机制到底怎么回事</a></li>\n<li><a href=\"https://www.cnblogs.com/starzy/p/11439997.html\" target=\"_blank\" rel=\"noopener\">Flink 水印机制</a></li>\n<li><a href=\"https://blog.csdn.net/aA518189/article/details/85233247\" target=\"_blank\" rel=\"noopener\">Flink实战–如何使用水印</a></li>\n<li><a href=\"https://www.cnblogs.com/jiang-it/p/9280946.html\" target=\"_blank\" rel=\"noopener\">Flink Window 的 Timestamps/Watermarks 和 allowedLateness 的区别</a></li>\n<li><a href=\"http://wuchong.me/blog/2018/11/07/use-flink-calculate-hot-items/\" target=\"_blank\" rel=\"noopener\">Flink 零基础实战教程：如何计算实时商品</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1419588\" target=\"_blank\" rel=\"noopener\">《从0到1学习Flink》– Flink读取 Kafka 数据写入到 RabbitMQ</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Apache Flink 是一个分布式处理引擎，在有界或无界数据流上进行有状态的计算。工作时偶然接触到一点点，有些概念虽然有点抽象，但是思路却值得借鉴。本文记录用 Flink 实时求均值、水印生成、以及迟到的数据元触发计算更新等等，是一篇纯探索性文章。<del>用笔记形式记录，以便忘记。</del><br></p>","more":"<p></p>\n<h3 id=\"Flink-中文官网\"><a href=\"#Flink-中文官网\" class=\"headerlink\" title=\"Flink 中文官网\"></a>Flink 中文官网</h3><p><a href=\"https://flink.apachecn.org/docs/1.7-SNAPSHOT/#/\" target=\"_blank\" rel=\"noopener\">https://flink.apachecn.org/docs/1.7-SNAPSHOT/#/</a></p>\n<h3 id=\"一、Flink-简介\"><a href=\"#一、Flink-简介\" class=\"headerlink\" title=\"一、Flink 简介\"></a>一、Flink 简介</h3><p>Flink 是一个针对流数据和批数据的分布式处理引擎，代码主要是由 Java 实现，部分代码是 Scala。它可以处理有界的批量数据集、也可以处理无界的实时数据集。对 Flink 而言，其主要处理的场景就是流数据。<br></p>\n<h3 id=\"二、流处理和批处理的区别\"><a href=\"#二、流处理和批处理的区别\" class=\"headerlink\" title=\"二、流处理和批处理的区别\"></a>二、流处理和批处理的区别</h3><p><strong>批处理</strong> 特点：离线、单次处理的数据量大、处理速度慢、非实时计算。常见的批处理就是数据库深夜定时跑任务，因为批量计算会占用大量资源。<br><strong>流处理</strong> 特点：在线，单次处理数据量小、处理速度快、实时计算。常见的应用场景就是监控、统计、实时推荐等。</p>\n<h3 id=\"三、学习目标\"><a href=\"#三、学习目标\" class=\"headerlink\" title=\"三、学习目标\"></a>三、学习目标</h3><p>用 Flink 消费已有数据源，实时计算数据均值，并允许数据元延迟到来时，重新触发计算。</p>\n<h3 id=\"四、涉及到的名词概念\"><a href=\"#四、涉及到的名词概念\" class=\"headerlink\" title=\"四、涉及到的名词概念\"></a>四、涉及到的名词概念</h3><ol>\n<li><strong>窗口</strong> (Windows)：对某段数据流进行统计，即统计区间；Windows 可以是时间驱动的（例如：每30秒）或数据驱动（例如：每100个数据元）。</li>\n<li><strong>时间</strong> (Time)：程序中引用的时间；Flink 支持三种时间：事件时间、摄取时间和处理时间。</li>\n<li><strong>算子</strong> (Operator)：Flink 内部提供的时间/数据流/数据元的处理函数。</li>\n<li><strong>时间戳</strong> (TimeStamp)/<strong>水印</strong> (WaterMark)：使用数据源的时间或者系统时间为到来的数据元加上时间戳；数据流加上水印标记，为了等下个数据元到来时知道该数据元是否应该被包含在当前次计算中。<br><strong>注：Watermark 是随数据产生的，窗口时间现在处于什么位置看 Watermark，只有新产生的一条数据超出窗口长度，这个窗口才会触发计算。(当使用事件时间窗口时，可能会发生数据元迟到的情况，则必须为数据流设置时间戳和水印)</strong></li>\n</ol>\n<h4 id=\"允许迟到-allowedLateness\"><a href=\"#允许迟到-allowedLateness\" class=\"headerlink\" title=\"允许迟到 allowedLateness\"></a>允许迟到 allowedLateness</h4><p>只要应该属于此窗口的第一个数据元到达，就会创建一个窗口，当时间（事件或处理时间）超过其结束时间戳加上用户指定 allowed lateness 时，窗口将被完全删除。<br><strong>allowedLateness 用来设置窗口销毁时间</strong>，而 waterMark 是用来设置窗口激活时间。当时延迟时间超过 allowedLateness 设置的时间，这个计算窗口就会被销毁，开始下一个窗口，即使被销毁的窗口还没有触发计算。</p>\n<h4 id=\"窗口函数\"><a href=\"#窗口函数\" class=\"headerlink\" title=\"窗口函数\"></a>窗口函数</h4><p>Flink 的窗口函数会暴露出数据流不同状态时的处理函数，具体的高级操作或者运算例如聚合、求均值等函数需要我们自己去实现。<br>例如聚合窗口 <code>stream.aggregate</code> 的参数 AggregateFunction &lt;IN, ACC, OUT&gt;，具有三种的类型：输入类型(IN)、累加器类型(ACC)和输出类型(OUT)。<br>使用 AggregateFunction 求均值（示例代码来自<a href=\"https://flink.apachecn.org/docs/1.7-SNAPSHOT/#/27?id=window-functions\" target=\"_blank\" rel=\"noopener\">官网</a>）：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AverageAggregate</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">implements</span> <span class=\"title\">AggregateFunction</span>&lt;<span class=\"title\">Tuple2</span>&lt;<span class=\"title\">String</span>, <span class=\"title\">Long</span>&gt;, <span class=\"title\">Tuple2</span>&lt;<span class=\"title\">Long</span>, <span class=\"title\">Long</span>&gt;, <span class=\"title\">Double</span>&gt; </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Tuple2&lt;Long, Long&gt; <span class=\"title\">createAccumulator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Tuple2&lt;&gt;(<span class=\"number\">0L</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Tuple2&lt;Long, Long&gt; <span class=\"title\">add</span><span class=\"params\">(Tuple2&lt;String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Tuple2&lt;&gt;(accumulator.f0 + value.f1, accumulator.f1 + <span class=\"number\">1L</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Double <span class=\"title\">getResult</span><span class=\"params\">(Tuple2&lt;Long, Long&gt; accumulator)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ((<span class=\"keyword\">double</span>) accumulator.f0) / accumulator.f1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Tuple2&lt;Long, Long&gt; <span class=\"title\">merge</span><span class=\"params\">(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Tuple2&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class=\"line\"></span><br><span class=\"line\">input</span><br><span class=\"line\">    .keyBy(&lt;key selector&gt;)</span><br><span class=\"line\">    .window(&lt;window assigner&gt;)</span><br><span class=\"line\">    .aggregate(<span class=\"keyword\">new</span> AverageAggregate());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"五、遇到的问题\"><a href=\"#五、遇到的问题\" class=\"headerlink\" title=\"五、遇到的问题\"></a>五、遇到的问题</h3><ul>\n<li>数据流过滤后，只剩下被过滤的数据：<ul>\n<li><strong>SingleOutputStreamOperator</strong> 旁路分支：这个分支用来获取被过滤掉的数据，并不是过滤后的数据。</li>\n</ul>\n</li>\n<li>给数据流设置时间戳之后，迟到的数据没有被抛弃：<ul>\n<li><strong>stream.assignTimestampsAndWatermarks</strong> 定期生成水印：最简单的特殊情况是给定源任务看到的时间戳按升序发生的情况。在这种情况下，当前时间戳始终可以充当水印，因为没有更早的时间戳会到达。且生成的时间戳会覆盖事件原有的，若存在迟到的数据元，用这个方法，则数据不会被抛弃。</li>\n<li><strong>BoundedOutOfOrdernessTimestampExtractor</strong> ：Flink 提供此参数为固定数量的迟到者分配时间戳和水印。若有数据元可能迟到的场景，请应用此方法。</li>\n</ul>\n</li>\n<li><a href=\"https://stackoverflow.com/questions/50114412/flink-watermark-and-triggers-late-elements-not-discarded-on-event-time\" target=\"_blank\" rel=\"noopener\">设置的水印时间戳，超时告警，但是数据没有被丢弃？</a></li>\n<li><a href=\"https://developer.aliyun.com/ask/128431?spm=a2c6h.13159736\" target=\"_blank\" rel=\"noopener\">最新记录没有被统计，只有下一条数据写入时，之前的数据才会被触发统计？</a></li>\n</ul>\n<h3 id=\"六、数据下沉-Data-Sink\"><a href=\"#六、数据下沉-Data-Sink\" class=\"headerlink\" title=\"六、数据下沉 Data Sink\"></a>六、数据下沉 Data Sink</h3><p>Flink 可以自己指定数据源连接器，以及数据下沉(接收)目标。从 Flink 官网上来看连接器支持 Kalfa、Elasticsearch、HDFS、RabbitMQ 等等，公司已有 RabbitMQ 数据源，使用 RabbitMQ sink 接收数时，注意事件消费者不要和事件生产者的队列名不要相同，否则会报错。</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><ul>\n<li><a href=\"http://www.54tianzhisheng.cn/\" target=\"_blank\" rel=\"noopener\">http://www.54tianzhisheng.cn/</a></li>\n<li><a href=\"https://bbs.csdn.net/topics/392567642?list=70723145\" target=\"_blank\" rel=\"noopener\">Flink 水印机制到底怎么回事</a></li>\n<li><a href=\"https://www.cnblogs.com/starzy/p/11439997.html\" target=\"_blank\" rel=\"noopener\">Flink 水印机制</a></li>\n<li><a href=\"https://blog.csdn.net/aA518189/article/details/85233247\" target=\"_blank\" rel=\"noopener\">Flink实战–如何使用水印</a></li>\n<li><a href=\"https://www.cnblogs.com/jiang-it/p/9280946.html\" target=\"_blank\" rel=\"noopener\">Flink Window 的 Timestamps/Watermarks 和 allowedLateness 的区别</a></li>\n<li><a href=\"http://wuchong.me/blog/2018/11/07/use-flink-calculate-hot-items/\" target=\"_blank\" rel=\"noopener\">Flink 零基础实战教程：如何计算实时商品</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1419588\" target=\"_blank\" rel=\"noopener\">《从0到1学习Flink》– Flink读取 Kafka 数据写入到 RabbitMQ</a></li>\n</ul>"},{"title":"Hexo 基础使用","date":"2018-11-17T04:00:30.000Z","_content":"\n### 安装\nnode 环境下，全局安装 hexo-cli\n````\nnpm install hexo-cli -g\n````\n### 初始化\n进入到一个放置blog的**空文件夹**\n````\n    hexo init \n    hexo generate\n    hexo server # 默认4000端口\n    hexo s -p 4001 # 在自定义端口启动\n````\n浏览器输入localhost:4000，出现blog界面\n\n### 换主题\nHexo官网提供了一些主题  [https://hexo.io/themes/ ](https://hexo.io/themes/) \n* git clone 主题地址到 blog 目录下，将全局_condig.yml中的theme名字改为clone下来的文件夹的名字\n* 主题中有可供选择的几套样式，更改主题 _config.yml 里的 scheme \n* 设置代码高亮样式 更改主题 _condig.yml 里的 hightlight_theme\n* 切换Hexo语言 在全局 _condig.yml 里的 language 改成 zh-Hans 即为主题下的简体中文（默认为英文）\n* (更换完主题，需要重启应用，方能生效)\n* __由于主题也是一个git仓库，下载后记得删除.git文件，否则主题文件是无法提交的__\n  \n### 生成文章\n````\n    hexo new \"postName\" # /source/_post/postName & .md\n    hexo new page \"pageName\" # /source/pageName/index & index.md\n    hexo generate # /source/.md -> /public/.html\n    hexo server \n    hexo deploy #将.deploy目录部署到GitHub\n````\n\n### 删除文章\n````\n    hexo clean # delete /public\n    hexo generate # regenerate /public\n    hexo deploy\n````\n\n### 其他\n- **插入本地图片**\n每次`hexo new 'postName'`时，都会创建一个与文章名相同的文件夹，将文章所需资源放入该文件夹里，引用的时候直接写文件名即可。\n- **页面增加“阅读更多”按钮**\n在 .md 文件中增加`<!--more-->`注释，如果想自动添加“阅读更多”按钮，可在主题下的`_config.yml`中将`auto_excerpt`下的`enable`设置为`true`。\n\n### 插件\n* [hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git) 一键部署到 GitPage\n* [hexo-douban](https://github.com/mythsman/hexo-douban) 爬取豆瓣相关信息\n* [hexo-generator-search](https://github.com/wzpan/hexo-generator-search) 全文搜索功能\n\n### 部署\n`hexo d`部署前，需要安装`npm install hexo-deployer-git --save`。\n修改全局 `_config.yml` 中的配置：\n````\n    deploy:\n        type: git\n        repo: <repository url>\n        branch: [branch]\n        message: [message]\n        name: [git user] \n        email: [git email]\n        extend_dirs: [extend directory] #其他要提交的目录\n        ignore_hidden: true #忽略隐藏文件\n        ignore_pattern: regexp #忽略正则匹配的隐藏文件\n````\n之后，只需要`hexo d -g`一条命令就可以生成和部署了。关于 hexo-deployer-git 这个插件的参数[hexo官方文档](https://hexo.io/zh-cn/docs/deployment.html)介绍的并不全面，建议去[hexo-deployer-git官方文档](https://github.com/hexojs/hexo-deployer-git)查看相关配置参数。\n\n__注意:__ \n* 默认部署，只将生成的HTML相关文件(/public)推送到 github\n* 若想把本地的生成器项目相关文件也推送到 github，则要配置 `extend_dirs: /`\n* message、name、email 的内容要用引号括起来\n* name、email 的配置信息用来覆盖全局的 git config 中的配置，更改这两项后，需要删除根目录下的`.deploy_git`，部署时才会生效\n* master 只能放`/public`下的文件，将项目所有文件放到 master 分支下，会导致页面 build 失败。若想将本地代码全部提交，可部署在其他分支（在`_config.yml`中增加其他分支配置信息，详情参考文档）\n* 不提交 node_modules 的话，注意在项目下新建`.gitignore`文件（为什么不使用 extend_dirs ？因为需要添加的文件夹太多...）\n\n### 搜索功能\n全局安装插件`npm install hexo-generator-search --save`\n修改全局`_config.yml`中的配置：\n````\n    search:\n        path: search.xml\n        field: post\n        content: true\n````\n\n修改主题`themes/next/_config.yml`中的配置：\n````\n    local_search:\n        enable: true\n        trigger: auto\n````\n\n生效：`hexo clean`、`hexo g`、`hexo s`\n### Hexo目录解析\n````\n    ├── node_modules # 依赖包-安装插件及所需nodejs模块。\n    ├── public  # 最终网页信息。即存放通过 markdown 渲染出来的 html文件。\n    ├── scaffolds # 模板文件夹。即新建文章时，根据 scaffold 生成文件。\n    ├── source  # 资源文件夹。即存放用户资源。\n    |   └── _posts # 博客文章目录。\n    └── themes #存放主题。Hexo根据主题生成静态页面。\n    ├── _config.yml #网站的全局配置信息。标题、网站名称等。\n    ├── db.json：# source 解析所得到的缓存文件。\n    ├── package.json  # 应用程序信息。即配置Hexo运行需要js包。\n````\n\n### 参考资料\n[利用 hexo + Gitpage 开发自己的博客](https://cherryblog.site/Use-Gitpagehexo-to-develop-their-own-blog.html)\n[hexo浅析原理](https://www.jianshu.com/p/a938da5ddb5d)","source":"_posts/Hexo-基础使用.md","raw":"---\ntitle: Hexo 基础使用\ndate: 2018-11-17 12:00:30\ntags: [Hexo]\ncategories: 其他小结\n---\n\n### 安装\nnode 环境下，全局安装 hexo-cli\n````\nnpm install hexo-cli -g\n````\n### 初始化\n进入到一个放置blog的**空文件夹**\n````\n    hexo init \n    hexo generate\n    hexo server # 默认4000端口\n    hexo s -p 4001 # 在自定义端口启动\n````\n浏览器输入localhost:4000，出现blog界面\n\n### 换主题\nHexo官网提供了一些主题  [https://hexo.io/themes/ ](https://hexo.io/themes/) \n* git clone 主题地址到 blog 目录下，将全局_condig.yml中的theme名字改为clone下来的文件夹的名字\n* 主题中有可供选择的几套样式，更改主题 _config.yml 里的 scheme \n* 设置代码高亮样式 更改主题 _condig.yml 里的 hightlight_theme\n* 切换Hexo语言 在全局 _condig.yml 里的 language 改成 zh-Hans 即为主题下的简体中文（默认为英文）\n* (更换完主题，需要重启应用，方能生效)\n* __由于主题也是一个git仓库，下载后记得删除.git文件，否则主题文件是无法提交的__\n  \n### 生成文章\n````\n    hexo new \"postName\" # /source/_post/postName & .md\n    hexo new page \"pageName\" # /source/pageName/index & index.md\n    hexo generate # /source/.md -> /public/.html\n    hexo server \n    hexo deploy #将.deploy目录部署到GitHub\n````\n\n### 删除文章\n````\n    hexo clean # delete /public\n    hexo generate # regenerate /public\n    hexo deploy\n````\n\n### 其他\n- **插入本地图片**\n每次`hexo new 'postName'`时，都会创建一个与文章名相同的文件夹，将文章所需资源放入该文件夹里，引用的时候直接写文件名即可。\n- **页面增加“阅读更多”按钮**\n在 .md 文件中增加`<!--more-->`注释，如果想自动添加“阅读更多”按钮，可在主题下的`_config.yml`中将`auto_excerpt`下的`enable`设置为`true`。\n\n### 插件\n* [hexo-deployer-git](https://github.com/hexojs/hexo-deployer-git) 一键部署到 GitPage\n* [hexo-douban](https://github.com/mythsman/hexo-douban) 爬取豆瓣相关信息\n* [hexo-generator-search](https://github.com/wzpan/hexo-generator-search) 全文搜索功能\n\n### 部署\n`hexo d`部署前，需要安装`npm install hexo-deployer-git --save`。\n修改全局 `_config.yml` 中的配置：\n````\n    deploy:\n        type: git\n        repo: <repository url>\n        branch: [branch]\n        message: [message]\n        name: [git user] \n        email: [git email]\n        extend_dirs: [extend directory] #其他要提交的目录\n        ignore_hidden: true #忽略隐藏文件\n        ignore_pattern: regexp #忽略正则匹配的隐藏文件\n````\n之后，只需要`hexo d -g`一条命令就可以生成和部署了。关于 hexo-deployer-git 这个插件的参数[hexo官方文档](https://hexo.io/zh-cn/docs/deployment.html)介绍的并不全面，建议去[hexo-deployer-git官方文档](https://github.com/hexojs/hexo-deployer-git)查看相关配置参数。\n\n__注意:__ \n* 默认部署，只将生成的HTML相关文件(/public)推送到 github\n* 若想把本地的生成器项目相关文件也推送到 github，则要配置 `extend_dirs: /`\n* message、name、email 的内容要用引号括起来\n* name、email 的配置信息用来覆盖全局的 git config 中的配置，更改这两项后，需要删除根目录下的`.deploy_git`，部署时才会生效\n* master 只能放`/public`下的文件，将项目所有文件放到 master 分支下，会导致页面 build 失败。若想将本地代码全部提交，可部署在其他分支（在`_config.yml`中增加其他分支配置信息，详情参考文档）\n* 不提交 node_modules 的话，注意在项目下新建`.gitignore`文件（为什么不使用 extend_dirs ？因为需要添加的文件夹太多...）\n\n### 搜索功能\n全局安装插件`npm install hexo-generator-search --save`\n修改全局`_config.yml`中的配置：\n````\n    search:\n        path: search.xml\n        field: post\n        content: true\n````\n\n修改主题`themes/next/_config.yml`中的配置：\n````\n    local_search:\n        enable: true\n        trigger: auto\n````\n\n生效：`hexo clean`、`hexo g`、`hexo s`\n### Hexo目录解析\n````\n    ├── node_modules # 依赖包-安装插件及所需nodejs模块。\n    ├── public  # 最终网页信息。即存放通过 markdown 渲染出来的 html文件。\n    ├── scaffolds # 模板文件夹。即新建文章时，根据 scaffold 生成文件。\n    ├── source  # 资源文件夹。即存放用户资源。\n    |   └── _posts # 博客文章目录。\n    └── themes #存放主题。Hexo根据主题生成静态页面。\n    ├── _config.yml #网站的全局配置信息。标题、网站名称等。\n    ├── db.json：# source 解析所得到的缓存文件。\n    ├── package.json  # 应用程序信息。即配置Hexo运行需要js包。\n````\n\n### 参考资料\n[利用 hexo + Gitpage 开发自己的博客](https://cherryblog.site/Use-Gitpagehexo-to-develop-their-own-blog.html)\n[hexo浅析原理](https://www.jianshu.com/p/a938da5ddb5d)","slug":"Hexo-基础使用","published":1,"updated":"2020-11-04T08:29:30.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0b00057vvucrn2kbuy","content":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>node 环境下，全局安装 hexo-cli<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>进入到一个放置blog的<strong>空文件夹</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init </span><br><span class=\"line\">hexo generate</span><br><span class=\"line\">hexo server # 默认4000端口</span><br><span class=\"line\">hexo s -p 4001 # 在自定义端口启动</span><br></pre></td></tr></table></figure></p>\n<p>浏览器输入localhost:4000，出现blog界面</p>\n<h3 id=\"换主题\"><a href=\"#换主题\" class=\"headerlink\" title=\"换主题\"></a>换主题</h3><p>Hexo官网提供了一些主题  <a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/themes/ </a> </p>\n<ul>\n<li>git clone 主题地址到 blog 目录下，将全局_condig.yml中的theme名字改为clone下来的文件夹的名字</li>\n<li>主题中有可供选择的几套样式，更改主题 _config.yml 里的 scheme </li>\n<li>设置代码高亮样式 更改主题 _condig.yml 里的 hightlight_theme</li>\n<li>切换Hexo语言 在全局 _condig.yml 里的 language 改成 zh-Hans 即为主题下的简体中文（默认为英文）</li>\n<li>(更换完主题，需要重启应用，方能生效)</li>\n<li><strong>由于主题也是一个git仓库，下载后记得删除.git文件，否则主题文件是无法提交的</strong></li>\n</ul>\n<h3 id=\"生成文章\"><a href=\"#生成文章\" class=\"headerlink\" title=\"生成文章\"></a>生成文章</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;postName&quot; # /source/_post/postName &amp; .md</span><br><span class=\"line\">hexo new page &quot;pageName&quot; # /source/pageName/index &amp; index.md</span><br><span class=\"line\">hexo generate # /source/.md -&gt; /public/.html</span><br><span class=\"line\">hexo server </span><br><span class=\"line\">hexo deploy #将.deploy目录部署到GitHub</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除文章\"><a href=\"#删除文章\" class=\"headerlink\" title=\"删除文章\"></a>删除文章</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean # delete /public</span><br><span class=\"line\">hexo generate # regenerate /public</span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li><strong>插入本地图片</strong><br>每次<code>hexo new &#39;postName&#39;</code>时，都会创建一个与文章名相同的文件夹，将文章所需资源放入该文件夹里，引用的时候直接写文件名即可。</li>\n<li><strong>页面增加“阅读更多”按钮</strong><br>在 .md 文件中增加<code>&lt;!--more--&gt;</code>注释，如果想自动添加“阅读更多”按钮，可在主题下的<code>_config.yml</code>中将<code>auto_excerpt</code>下的<code>enable</code>设置为<code>true</code>。</li>\n</ul>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><ul>\n<li><a href=\"https://github.com/hexojs/hexo-deployer-git\" target=\"_blank\" rel=\"noopener\">hexo-deployer-git</a> 一键部署到 GitPage</li>\n<li><a href=\"https://github.com/mythsman/hexo-douban\" target=\"_blank\" rel=\"noopener\">hexo-douban</a> 爬取豆瓣相关信息</li>\n<li><a href=\"https://github.com/wzpan/hexo-generator-search\" target=\"_blank\" rel=\"noopener\">hexo-generator-search</a> 全文搜索功能</li>\n</ul>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><p><code>hexo d</code>部署前，需要安装<code>npm install hexo-deployer-git --save</code>。<br>修改全局 <code>_config.yml</code> 中的配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">    type: git</span><br><span class=\"line\">    repo: &lt;repository url&gt;</span><br><span class=\"line\">    branch: [branch]</span><br><span class=\"line\">    message: [message]</span><br><span class=\"line\">    name: [git user] </span><br><span class=\"line\">    email: [git email]</span><br><span class=\"line\">    extend_dirs: [extend directory] #其他要提交的目录</span><br><span class=\"line\">    ignore_hidden: true #忽略隐藏文件</span><br><span class=\"line\">    ignore_pattern: regexp #忽略正则匹配的隐藏文件</span><br></pre></td></tr></table></figure></p>\n<p>之后，只需要<code>hexo d -g</code>一条命令就可以生成和部署了。关于 hexo-deployer-git 这个插件的参数<a href=\"https://hexo.io/zh-cn/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">hexo官方文档</a>介绍的并不全面，建议去<a href=\"https://github.com/hexojs/hexo-deployer-git\" target=\"_blank\" rel=\"noopener\">hexo-deployer-git官方文档</a>查看相关配置参数。</p>\n<p><strong>注意:</strong> </p>\n<ul>\n<li>默认部署，只将生成的HTML相关文件(/public)推送到 github</li>\n<li>若想把本地的生成器项目相关文件也推送到 github，则要配置 <code>extend_dirs: /</code></li>\n<li>message、name、email 的内容要用引号括起来</li>\n<li>name、email 的配置信息用来覆盖全局的 git config 中的配置，更改这两项后，需要删除根目录下的<code>.deploy_git</code>，部署时才会生效</li>\n<li>master 只能放<code>/public</code>下的文件，将项目所有文件放到 master 分支下，会导致页面 build 失败。若想将本地代码全部提交，可部署在其他分支（在<code>_config.yml</code>中增加其他分支配置信息，详情参考文档）</li>\n<li>不提交 node_modules 的话，注意在项目下新建<code>.gitignore</code>文件（为什么不使用 extend_dirs ？因为需要添加的文件夹太多…）</li>\n</ul>\n<h3 id=\"搜索功能\"><a href=\"#搜索功能\" class=\"headerlink\" title=\"搜索功能\"></a>搜索功能</h3><p>全局安装插件<code>npm install hexo-generator-search --save</code><br>修改全局<code>_config.yml</code>中的配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">    path: search.xml</span><br><span class=\"line\">    field: post</span><br><span class=\"line\">    content: true</span><br></pre></td></tr></table></figure></p>\n<p>修改主题<code>themes/next/_config.yml</code>中的配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local_search:</span><br><span class=\"line\">    enable: true</span><br><span class=\"line\">    trigger: auto</span><br></pre></td></tr></table></figure></p>\n<p>生效：<code>hexo clean</code>、<code>hexo g</code>、<code>hexo s</code></p>\n<h3 id=\"Hexo目录解析\"><a href=\"#Hexo目录解析\" class=\"headerlink\" title=\"Hexo目录解析\"></a>Hexo目录解析</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── node_modules # 依赖包-安装插件及所需nodejs模块。</span><br><span class=\"line\">├── public  # 最终网页信息。即存放通过 markdown 渲染出来的 html文件。</span><br><span class=\"line\">├── scaffolds # 模板文件夹。即新建文章时，根据 scaffold 生成文件。</span><br><span class=\"line\">├── source  # 资源文件夹。即存放用户资源。</span><br><span class=\"line\">|   └── _posts # 博客文章目录。</span><br><span class=\"line\">└── themes #存放主题。Hexo根据主题生成静态页面。</span><br><span class=\"line\">├── _config.yml #网站的全局配置信息。标题、网站名称等。</span><br><span class=\"line\">├── db.json：# source 解析所得到的缓存文件。</span><br><span class=\"line\">├── package.json  # 应用程序信息。即配置Hexo运行需要js包。</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://cherryblog.site/Use-Gitpagehexo-to-develop-their-own-blog.html\" target=\"_blank\" rel=\"noopener\">利用 hexo + Gitpage 开发自己的博客</a><br><a href=\"https://www.jianshu.com/p/a938da5ddb5d\" target=\"_blank\" rel=\"noopener\">hexo浅析原理</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>node 环境下，全局安装 hexo-cli<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>进入到一个放置blog的<strong>空文件夹</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init </span><br><span class=\"line\">hexo generate</span><br><span class=\"line\">hexo server # 默认4000端口</span><br><span class=\"line\">hexo s -p 4001 # 在自定义端口启动</span><br></pre></td></tr></table></figure></p>\n<p>浏览器输入localhost:4000，出现blog界面</p>\n<h3 id=\"换主题\"><a href=\"#换主题\" class=\"headerlink\" title=\"换主题\"></a>换主题</h3><p>Hexo官网提供了一些主题  <a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/themes/ </a> </p>\n<ul>\n<li>git clone 主题地址到 blog 目录下，将全局_condig.yml中的theme名字改为clone下来的文件夹的名字</li>\n<li>主题中有可供选择的几套样式，更改主题 _config.yml 里的 scheme </li>\n<li>设置代码高亮样式 更改主题 _condig.yml 里的 hightlight_theme</li>\n<li>切换Hexo语言 在全局 _condig.yml 里的 language 改成 zh-Hans 即为主题下的简体中文（默认为英文）</li>\n<li>(更换完主题，需要重启应用，方能生效)</li>\n<li><strong>由于主题也是一个git仓库，下载后记得删除.git文件，否则主题文件是无法提交的</strong></li>\n</ul>\n<h3 id=\"生成文章\"><a href=\"#生成文章\" class=\"headerlink\" title=\"生成文章\"></a>生成文章</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;postName&quot; # /source/_post/postName &amp; .md</span><br><span class=\"line\">hexo new page &quot;pageName&quot; # /source/pageName/index &amp; index.md</span><br><span class=\"line\">hexo generate # /source/.md -&gt; /public/.html</span><br><span class=\"line\">hexo server </span><br><span class=\"line\">hexo deploy #将.deploy目录部署到GitHub</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除文章\"><a href=\"#删除文章\" class=\"headerlink\" title=\"删除文章\"></a>删除文章</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean # delete /public</span><br><span class=\"line\">hexo generate # regenerate /public</span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li><strong>插入本地图片</strong><br>每次<code>hexo new &#39;postName&#39;</code>时，都会创建一个与文章名相同的文件夹，将文章所需资源放入该文件夹里，引用的时候直接写文件名即可。</li>\n<li><strong>页面增加“阅读更多”按钮</strong><br>在 .md 文件中增加<code>&lt;!--more--&gt;</code>注释，如果想自动添加“阅读更多”按钮，可在主题下的<code>_config.yml</code>中将<code>auto_excerpt</code>下的<code>enable</code>设置为<code>true</code>。</li>\n</ul>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><ul>\n<li><a href=\"https://github.com/hexojs/hexo-deployer-git\" target=\"_blank\" rel=\"noopener\">hexo-deployer-git</a> 一键部署到 GitPage</li>\n<li><a href=\"https://github.com/mythsman/hexo-douban\" target=\"_blank\" rel=\"noopener\">hexo-douban</a> 爬取豆瓣相关信息</li>\n<li><a href=\"https://github.com/wzpan/hexo-generator-search\" target=\"_blank\" rel=\"noopener\">hexo-generator-search</a> 全文搜索功能</li>\n</ul>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><p><code>hexo d</code>部署前，需要安装<code>npm install hexo-deployer-git --save</code>。<br>修改全局 <code>_config.yml</code> 中的配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">    type: git</span><br><span class=\"line\">    repo: &lt;repository url&gt;</span><br><span class=\"line\">    branch: [branch]</span><br><span class=\"line\">    message: [message]</span><br><span class=\"line\">    name: [git user] </span><br><span class=\"line\">    email: [git email]</span><br><span class=\"line\">    extend_dirs: [extend directory] #其他要提交的目录</span><br><span class=\"line\">    ignore_hidden: true #忽略隐藏文件</span><br><span class=\"line\">    ignore_pattern: regexp #忽略正则匹配的隐藏文件</span><br></pre></td></tr></table></figure></p>\n<p>之后，只需要<code>hexo d -g</code>一条命令就可以生成和部署了。关于 hexo-deployer-git 这个插件的参数<a href=\"https://hexo.io/zh-cn/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">hexo官方文档</a>介绍的并不全面，建议去<a href=\"https://github.com/hexojs/hexo-deployer-git\" target=\"_blank\" rel=\"noopener\">hexo-deployer-git官方文档</a>查看相关配置参数。</p>\n<p><strong>注意:</strong> </p>\n<ul>\n<li>默认部署，只将生成的HTML相关文件(/public)推送到 github</li>\n<li>若想把本地的生成器项目相关文件也推送到 github，则要配置 <code>extend_dirs: /</code></li>\n<li>message、name、email 的内容要用引号括起来</li>\n<li>name、email 的配置信息用来覆盖全局的 git config 中的配置，更改这两项后，需要删除根目录下的<code>.deploy_git</code>，部署时才会生效</li>\n<li>master 只能放<code>/public</code>下的文件，将项目所有文件放到 master 分支下，会导致页面 build 失败。若想将本地代码全部提交，可部署在其他分支（在<code>_config.yml</code>中增加其他分支配置信息，详情参考文档）</li>\n<li>不提交 node_modules 的话，注意在项目下新建<code>.gitignore</code>文件（为什么不使用 extend_dirs ？因为需要添加的文件夹太多…）</li>\n</ul>\n<h3 id=\"搜索功能\"><a href=\"#搜索功能\" class=\"headerlink\" title=\"搜索功能\"></a>搜索功能</h3><p>全局安装插件<code>npm install hexo-generator-search --save</code><br>修改全局<code>_config.yml</code>中的配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">    path: search.xml</span><br><span class=\"line\">    field: post</span><br><span class=\"line\">    content: true</span><br></pre></td></tr></table></figure></p>\n<p>修改主题<code>themes/next/_config.yml</code>中的配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local_search:</span><br><span class=\"line\">    enable: true</span><br><span class=\"line\">    trigger: auto</span><br></pre></td></tr></table></figure></p>\n<p>生效：<code>hexo clean</code>、<code>hexo g</code>、<code>hexo s</code></p>\n<h3 id=\"Hexo目录解析\"><a href=\"#Hexo目录解析\" class=\"headerlink\" title=\"Hexo目录解析\"></a>Hexo目录解析</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── node_modules # 依赖包-安装插件及所需nodejs模块。</span><br><span class=\"line\">├── public  # 最终网页信息。即存放通过 markdown 渲染出来的 html文件。</span><br><span class=\"line\">├── scaffolds # 模板文件夹。即新建文章时，根据 scaffold 生成文件。</span><br><span class=\"line\">├── source  # 资源文件夹。即存放用户资源。</span><br><span class=\"line\">|   └── _posts # 博客文章目录。</span><br><span class=\"line\">└── themes #存放主题。Hexo根据主题生成静态页面。</span><br><span class=\"line\">├── _config.yml #网站的全局配置信息。标题、网站名称等。</span><br><span class=\"line\">├── db.json：# source 解析所得到的缓存文件。</span><br><span class=\"line\">├── package.json  # 应用程序信息。即配置Hexo运行需要js包。</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://cherryblog.site/Use-Gitpagehexo-to-develop-their-own-blog.html\" target=\"_blank\" rel=\"noopener\">利用 hexo + Gitpage 开发自己的博客</a><br><a href=\"https://www.jianshu.com/p/a938da5ddb5d\" target=\"_blank\" rel=\"noopener\">hexo浅析原理</a></p>\n"},{"title":"IP地址和子网划分","date":"2019-06-02T13:47:33.000Z","_content":"计算机知识补全计划：ip地址、子网掩码相关笔记。\n<!--more-->\n\nMAC地址：决定下跳给哪个设备\nIP地址：决定数据最终到达的计算机\n子网掩码：用来判断两台机器的ip地址是否处于同一网段\n__[课程链接](https://www.bilibili.com/video/av17905625)__\n\n一、IP地址\n    IP地址是由32位二进制组成的，写成十进制，每四位以逗号分隔：如`192.168.30.10`。IP地址分为两部分，一部分是网络部分，另一部分是主机部分；在同一网段的计算机，网络部分一样，主机部分不一样，`子网掩码`就是用来区分主机与网段的。\n1. 子网掩码\n   两台计算机在通信之前，首先需要判断需要进行通信的设备与当前的设备是否处于同一网段之中：`IP地址`和`子网掩码`做`与运算`得出的结果就是网络部分，网络部分相同则处于同一网段。\n   例如：A计算机想与B计算机通信，首先A将A的子网掩码和A的IP地址进行与运算，再将A的子网掩码和B的IP地址进行运算，若二者结果相同，则处于同一网段。\n2. IP地址的分类\n   * A类：1-127  缺省子网掩码：255.0.0.0\n   * B类：128-191 缺省子网掩码：255.255.0.0\n   * C类：192-223 缺省子网掩码：255.255.255.0\n   * D类（组播）：224-239 缺省子网掩码：无\n   * E类（研究）：240-255 缺省子网掩码：无\n````\n[0----------128-----192---224-240-255]\n````\n在分配IP地址时注意：\n`xxx.0.0.0`：全0表示这个子网的网络号，不可用；\n`xxx.255.255.255`：全1表示这个子网的广播地址，代表网段内所有计算机，可跨网段，不可用。（注意，若全为255，则只能发送给本网段的机器，不能跨网段）\n例如C类地址，能设置的主机号只有2-254，一般路由器的ip地址为该网段内的第一个或者最后一个，避免冲突。\n3. 保留地址\n   * 保留的私网地址（不在公网上，相互之间不能通信（内网））：\n     * A 10.0.0.0 -- 10.255.255.255\n     * B 172.16.0.0 -- 172.31.255.255\n     * C 192.168.0.0 -- 192.168.255.255\n   * 本地环回地址\n     * 127.0.0.1 本机\n     * 169.254.0.0 断网地址\n     * 224.0.0.1 特殊的组播地址，代表所有主机地址\n   ","source":"_posts/IP地址和子网划分.md","raw":"---\ntitle: IP地址和子网划分\ndate: 2019-06-02 21:47:33\ntags: [计算机网络]\ncategories: 计算机相关知识\n---\n计算机知识补全计划：ip地址、子网掩码相关笔记。\n<!--more-->\n\nMAC地址：决定下跳给哪个设备\nIP地址：决定数据最终到达的计算机\n子网掩码：用来判断两台机器的ip地址是否处于同一网段\n__[课程链接](https://www.bilibili.com/video/av17905625)__\n\n一、IP地址\n    IP地址是由32位二进制组成的，写成十进制，每四位以逗号分隔：如`192.168.30.10`。IP地址分为两部分，一部分是网络部分，另一部分是主机部分；在同一网段的计算机，网络部分一样，主机部分不一样，`子网掩码`就是用来区分主机与网段的。\n1. 子网掩码\n   两台计算机在通信之前，首先需要判断需要进行通信的设备与当前的设备是否处于同一网段之中：`IP地址`和`子网掩码`做`与运算`得出的结果就是网络部分，网络部分相同则处于同一网段。\n   例如：A计算机想与B计算机通信，首先A将A的子网掩码和A的IP地址进行与运算，再将A的子网掩码和B的IP地址进行运算，若二者结果相同，则处于同一网段。\n2. IP地址的分类\n   * A类：1-127  缺省子网掩码：255.0.0.0\n   * B类：128-191 缺省子网掩码：255.255.0.0\n   * C类：192-223 缺省子网掩码：255.255.255.0\n   * D类（组播）：224-239 缺省子网掩码：无\n   * E类（研究）：240-255 缺省子网掩码：无\n````\n[0----------128-----192---224-240-255]\n````\n在分配IP地址时注意：\n`xxx.0.0.0`：全0表示这个子网的网络号，不可用；\n`xxx.255.255.255`：全1表示这个子网的广播地址，代表网段内所有计算机，可跨网段，不可用。（注意，若全为255，则只能发送给本网段的机器，不能跨网段）\n例如C类地址，能设置的主机号只有2-254，一般路由器的ip地址为该网段内的第一个或者最后一个，避免冲突。\n3. 保留地址\n   * 保留的私网地址（不在公网上，相互之间不能通信（内网））：\n     * A 10.0.0.0 -- 10.255.255.255\n     * B 172.16.0.0 -- 172.31.255.255\n     * C 192.168.0.0 -- 192.168.255.255\n   * 本地环回地址\n     * 127.0.0.1 本机\n     * 169.254.0.0 断网地址\n     * 224.0.0.1 特殊的组播地址，代表所有主机地址\n   ","slug":"IP地址和子网划分","published":1,"updated":"2020-11-04T08:29:30.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0f00097vvuatrazhdu","content":"<p>计算机知识补全计划：ip地址、子网掩码相关笔记。<br><a id=\"more\"></a></p>\n<p>MAC地址：决定下跳给哪个设备<br>IP地址：决定数据最终到达的计算机<br>子网掩码：用来判断两台机器的ip地址是否处于同一网段<br><strong><a href=\"https://www.bilibili.com/video/av17905625\" target=\"_blank\" rel=\"noopener\">课程链接</a></strong></p>\n<p>一、IP地址<br>    IP地址是由32位二进制组成的，写成十进制，每四位以逗号分隔：如<code>192.168.30.10</code>。IP地址分为两部分，一部分是网络部分，另一部分是主机部分；在同一网段的计算机，网络部分一样，主机部分不一样，<code>子网掩码</code>就是用来区分主机与网段的。</p>\n<ol>\n<li>子网掩码<br>两台计算机在通信之前，首先需要判断需要进行通信的设备与当前的设备是否处于同一网段之中：<code>IP地址</code>和<code>子网掩码</code>做<code>与运算</code>得出的结果就是网络部分，网络部分相同则处于同一网段。<br>例如：A计算机想与B计算机通信，首先A将A的子网掩码和A的IP地址进行与运算，再将A的子网掩码和B的IP地址进行运算，若二者结果相同，则处于同一网段。</li>\n<li>IP地址的分类<ul>\n<li>A类：1-127  缺省子网掩码：255.0.0.0</li>\n<li>B类：128-191 缺省子网掩码：255.255.0.0</li>\n<li>C类：192-223 缺省子网掩码：255.255.255.0</li>\n<li>D类（组播）：224-239 缺省子网掩码：无</li>\n<li>E类（研究）：240-255 缺省子网掩码：无<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0----------128-----192---224-240-255]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<p>在分配IP地址时注意：<br><code>xxx.0.0.0</code>：全0表示这个子网的网络号，不可用；<br><code>xxx.255.255.255</code>：全1表示这个子网的广播地址，代表网段内所有计算机，可跨网段，不可用。（注意，若全为255，则只能发送给本网段的机器，不能跨网段）<br>例如C类地址，能设置的主机号只有2-254，一般路由器的ip地址为该网段内的第一个或者最后一个，避免冲突。</p>\n<ol start=\"3\">\n<li>保留地址<ul>\n<li>保留的私网地址（不在公网上，相互之间不能通信（内网））：<ul>\n<li>A 10.0.0.0 – 10.255.255.255</li>\n<li>B 172.16.0.0 – 172.31.255.255</li>\n<li>C 192.168.0.0 – 192.168.255.255</li>\n</ul>\n</li>\n<li>本地环回地址<ul>\n<li>127.0.0.1 本机</li>\n<li>169.254.0.0 断网地址</li>\n<li>224.0.0.1 特殊的组播地址，代表所有主机地址</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>计算机知识补全计划：ip地址、子网掩码相关笔记。<br></p>","more":"<p></p>\n<p>MAC地址：决定下跳给哪个设备<br>IP地址：决定数据最终到达的计算机<br>子网掩码：用来判断两台机器的ip地址是否处于同一网段<br><strong><a href=\"https://www.bilibili.com/video/av17905625\" target=\"_blank\" rel=\"noopener\">课程链接</a></strong></p>\n<p>一、IP地址<br>    IP地址是由32位二进制组成的，写成十进制，每四位以逗号分隔：如<code>192.168.30.10</code>。IP地址分为两部分，一部分是网络部分，另一部分是主机部分；在同一网段的计算机，网络部分一样，主机部分不一样，<code>子网掩码</code>就是用来区分主机与网段的。</p>\n<ol>\n<li>子网掩码<br>两台计算机在通信之前，首先需要判断需要进行通信的设备与当前的设备是否处于同一网段之中：<code>IP地址</code>和<code>子网掩码</code>做<code>与运算</code>得出的结果就是网络部分，网络部分相同则处于同一网段。<br>例如：A计算机想与B计算机通信，首先A将A的子网掩码和A的IP地址进行与运算，再将A的子网掩码和B的IP地址进行运算，若二者结果相同，则处于同一网段。</li>\n<li>IP地址的分类<ul>\n<li>A类：1-127  缺省子网掩码：255.0.0.0</li>\n<li>B类：128-191 缺省子网掩码：255.255.0.0</li>\n<li>C类：192-223 缺省子网掩码：255.255.255.0</li>\n<li>D类（组播）：224-239 缺省子网掩码：无</li>\n<li>E类（研究）：240-255 缺省子网掩码：无<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0----------128-----192---224-240-255]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<p>在分配IP地址时注意：<br><code>xxx.0.0.0</code>：全0表示这个子网的网络号，不可用；<br><code>xxx.255.255.255</code>：全1表示这个子网的广播地址，代表网段内所有计算机，可跨网段，不可用。（注意，若全为255，则只能发送给本网段的机器，不能跨网段）<br>例如C类地址，能设置的主机号只有2-254，一般路由器的ip地址为该网段内的第一个或者最后一个，避免冲突。</p>\n<ol start=\"3\">\n<li>保留地址<ul>\n<li>保留的私网地址（不在公网上，相互之间不能通信（内网））：<ul>\n<li>A 10.0.0.0 – 10.255.255.255</li>\n<li>B 172.16.0.0 – 172.31.255.255</li>\n<li>C 192.168.0.0 – 192.168.255.255</li>\n</ul>\n</li>\n<li>本地环回地址<ul>\n<li>127.0.0.1 本机</li>\n<li>169.254.0.0 断网地址</li>\n<li>224.0.0.1 特殊的组播地址，代表所有主机地址</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>"},{"title":"Linux命令行与shell脚本学习","date":"2018-11-30T08:00:10.000Z","_content":"《Linux命令行与shell脚本编程大全》读书小结，熟悉一下常用的命令行操作。书籍比较基础，对熟悉Linux命令行的人来说参考意义不大。主要记录下书中提到的、没提到的常用的命令。\n<!--more-->\n### 基础操作\n* . 代表当前目录\n* .. 代表父级目录\n* ~ 代表根目录 表名当前工作目录位于用户home目录之下\n* man <directive\\> 可查看指令可使用的参数手册\n* `tab` 键自动补全文件名\n* cd 切换目录\n* linux 中的文件路径全部采用正斜线`/`，windows中的路径都是反斜线`\\`而且带盘符\n* ls 列出当前路径下的所有文件\n    * -F 在显示子目录的时候在它的文件名之后加上一个斜线(“/”)字符\n    * -F -R 遍历(递归)出当前目录下的子文件夹的所有内容(可以缩写成 ls -FR )\n    * -a 列出所有文件，包括隐藏文件\n    * -l 列出文件的所有信息\n* pwd 查看当前所在位置的全路径\n* sudo 以 root 用户身份运行命令\n  \n### 文件基础操作\n* open <fileName\\> 用默认程序打开文件\n* touch <fileName\\> 创建一个文件 (不可在不存在的目录下新建文件)\n* mkdir <directory\\> 创建一个文件夹\n    * -p 创建多个层级的文件夹\n* rmdir <directory\\> 只删除空目录\n    * 在非空目录下使用 rm -r 命令\n* cp <fileName\\> <targetDirectory/fileName> 复制文件到目标文件夹/文件名\n    * -i 强制 shell 询问是否覆盖同名文件\n* scp <fileName\\> <root@targetPath> 远程拷贝文件 可以跨服务器\n* mv <fileName\\> <directory/fileName> 用来 移动/重命名 文件\n    * -i 强制 shell 询问是否覆盖同名文件\n* rm <fileName\\> 删除文件/文件夹中的所有内容\n    * -i 强制 shell 询问是否删除文件\n    * -f 强制删除，没有警告信息也没有声音提示\n    * -r 递归删除目录及目录内所有文件  \n    * __注意：Linux 中没有回收站或垃圾箱，文件一旦删除，就无法再找回__\n* ls -l <fileName\\> 查看文件权限\n* chmod value <fileName\\> 更改文件权限\n  * 权限描述顺序依次是：Owner(User)、Group、Other\n  * r=读取属性 //值=4\n  * w=写入属性 //值=2\n  * x=执行属性 //值=1\n  ![文件权限](/file-permissions.png)\n* chown(选项)(参数) 更改文件夹所有者和所属组\n  * chown -R user:group .git 将.git文件夹的权限设置为 group 下的 user\n* 获取文件路径：直接将文件拖入命令行即可\n  \n### 文件内容操作\n* file <fileName/directoryName\\> 查看文件类型信息\n* du <fileName/directoryName\\> 用来查看文件或目录所占用的磁盘空间的大小\n    * -h 以易于阅读的方式展示\n    * -a 显示目录及其下子目录和文件占用的磁盘空间大小\n    * -s 只展示当前目录占用磁盘空间大小\n* cat/more/less <fileName\\> 查看整个文件内容\n    * cat 一次性加载完所有文件内容\n    * more 一次显示一屏文本\n    * less 一次显示一屏文本 可以上下页翻建\n* tail/head <fileName\\> 查看部分文件内容\n    * tail 默认展示文件最后10行的效果\n        * -n 2 只显示文件最后两行\n        * -f 允许其他进程使用该文件时查看该文件的内容，tail会保持活跃状态，并不断显示添加到文件中的内容。（可用来实时监测系统日志）\n    * head 默认展示文件前10行内容\n        * 不支持 -f 属性\n* grep match_pattern <fileName\\> 强大的文本搜索工具，可以使用正则表达式搜索文本，并显示出匹配的行数\n* sed -i 's/被替换的内容/要替换的内容/g' file  -i 表示直接修改并保存\n    * [使用 sed 命令，报错`invalid command code`](https://blog.csdn.net/u010339879/article/details/90107977)，是因为 -i 原地替换是危险行为，需要指明一个备份的扩展名才可以，若给了空的扩展名，则不会备份源文件。\n    * 如 sed -i '' 's/被替换的内容/要替换的内容/g' file\n* ls -> xxx.txt 将命令输出的内容保存为文件\n\n\n### 监控进程\n* ps 显示进程信息（瞬间占用情况）\n* top 显示进程信息（实时占用情况）\n* lsof 查看进程打开的文件\n    * lsof -i:4000 查看4000端口占用情况\n* kill [PID] 杀死对应进程\n  \n### 网络情况\n* ping <ip\\> 测试主机之间的连通性(不会自动结束，需要手动 ctrl + c 强制退出)\n* dig <url\\> 域名查询工具，可以用来测试域名系统工作是否正常\n* nsloopup <url\\> 域名查询工具，查询 DNS 相关信息\n\n### 变量\n#### 环境变量\n* printenv/env 默认输出所有环境变量（全局）\n    * printenv JAVA_HOME 输出全局设置的JAVA SDK位置\n    * env $JAVA_HOME \n    * echo $JAVA_HOME \n* echo $variableName 输出变量 ($用来表名它是个变量)\n* set 输出所有环境变量（全局和局部）\n* $HOME 表示的用户的主目录，与波浪线`~`作用一样\n\n#### 普通变量\n声明时直接声明即可使用`variable=XXX`，变量名区分大小写，但需要注意的是 __赋值时，变量名、等号和值之间没有空格__ 否则会报错`command not found`。\n常用的书写习惯是 __所有的环境变量名均使用大写字母，若是自己创建的局部变量或是shell脚本，则用小写字母，变量名区分大小写。__\n\n### vim 操作\n* vim <fileName\\> 以 vim 编辑器的方式查看当前文件\n* 按 `I` 对文件进行 INSERT 操作\n* 按 `esc` 退出当前编辑模式\n* 输入 `:` 切换到底线命令模式，可以在最底行输入其他命令\n* 输入 `wq` ，保存并退出；输入 `!q`，不保存直接退出\n* .swp 文件: 非正常关闭的 vim 编辑器会生成一个 .swp 文件\n\n### 杂项\n#### 大小写转换\n* echo $VAR_NAME | tr '[:upper:]' '[:lower:]'\n* echo $VAR_NAME | tr '[A-Z]' '[a-z]'\n\n### 其他\n* alias 可用来查看当前可用的别名(内建命令)\n  * alias 新的命令='原命令 -选项/参数' 用来定义命令别名\n* sh <fileName.sh\\> 执行shell文件\n* .xxxrc 可以看做是xxx启动运行时的配置文件\n    * 例如 .zshrc 就是 zsh 运行前要执行配置文件\n* source <fileName\\> 或者 . <fileName\\> (bash内部命令) 加载文件\n* 文件\\包查找\n  * which <fileName\\> 查找该包编译器所在位置\n  * whereis <fileName\\> 搜索更大范围的系统目录并输出所有包含的路径\n  * find <fileName\\> 查找系统是否安装了某个软件包\n\n### 常用的配置文件地址\n* Host文件 /etc/hosts\n* 配置的SSH Key: cat ~/.ssh/id_rsa.pub\n\n### 常见文件颜色\n* 白色：表示普通文件\n* 蓝色：表示目录\n* 绿色：表示可执行文件\n* 红色：表示压缩文件\n* 浅蓝色：链接文件\n* 红色闪烁：表示链接的文件有问题\n* 黄色：表示设备文件\n* 灰色：表示其他文件\n\n### 插件\n* homebrew 包管理器\n    * brew install <packageName\\> 安装插件\n    * brew list 查看电脑安装了哪些插件\n* wget 下载网页常用的工具\n* curl 模拟 http 请求，类似于 POSTMAN\n    * curl <url\\> 直接返回 url 请求结果\n* tree 以树状图形式展示目录及其子文件\n    * tree <directory\\> -J 以 json 形式展示文件\n* tig 将git命令行可视化\n\n__其他参考:__\n* __[Linux命令大全](http://man.linuxde.net/)__\n* __[Linux命令英文缩写的含义](http://blog.chinaunix.net/uid-27164517-id-3299073.html)__\n* __[Shell基础](http://c.biancheng.net/shell/base/)__\n","source":"_posts/Linux命令行与shell脚本学习.md","raw":"---\ntitle: Linux命令行与shell脚本学习\ndate: 2018-11-30 16:00:10\ntags: [Linux&shell]\ncategories: 计算机相关知识\n---\n《Linux命令行与shell脚本编程大全》读书小结，熟悉一下常用的命令行操作。书籍比较基础，对熟悉Linux命令行的人来说参考意义不大。主要记录下书中提到的、没提到的常用的命令。\n<!--more-->\n### 基础操作\n* . 代表当前目录\n* .. 代表父级目录\n* ~ 代表根目录 表名当前工作目录位于用户home目录之下\n* man <directive\\> 可查看指令可使用的参数手册\n* `tab` 键自动补全文件名\n* cd 切换目录\n* linux 中的文件路径全部采用正斜线`/`，windows中的路径都是反斜线`\\`而且带盘符\n* ls 列出当前路径下的所有文件\n    * -F 在显示子目录的时候在它的文件名之后加上一个斜线(“/”)字符\n    * -F -R 遍历(递归)出当前目录下的子文件夹的所有内容(可以缩写成 ls -FR )\n    * -a 列出所有文件，包括隐藏文件\n    * -l 列出文件的所有信息\n* pwd 查看当前所在位置的全路径\n* sudo 以 root 用户身份运行命令\n  \n### 文件基础操作\n* open <fileName\\> 用默认程序打开文件\n* touch <fileName\\> 创建一个文件 (不可在不存在的目录下新建文件)\n* mkdir <directory\\> 创建一个文件夹\n    * -p 创建多个层级的文件夹\n* rmdir <directory\\> 只删除空目录\n    * 在非空目录下使用 rm -r 命令\n* cp <fileName\\> <targetDirectory/fileName> 复制文件到目标文件夹/文件名\n    * -i 强制 shell 询问是否覆盖同名文件\n* scp <fileName\\> <root@targetPath> 远程拷贝文件 可以跨服务器\n* mv <fileName\\> <directory/fileName> 用来 移动/重命名 文件\n    * -i 强制 shell 询问是否覆盖同名文件\n* rm <fileName\\> 删除文件/文件夹中的所有内容\n    * -i 强制 shell 询问是否删除文件\n    * -f 强制删除，没有警告信息也没有声音提示\n    * -r 递归删除目录及目录内所有文件  \n    * __注意：Linux 中没有回收站或垃圾箱，文件一旦删除，就无法再找回__\n* ls -l <fileName\\> 查看文件权限\n* chmod value <fileName\\> 更改文件权限\n  * 权限描述顺序依次是：Owner(User)、Group、Other\n  * r=读取属性 //值=4\n  * w=写入属性 //值=2\n  * x=执行属性 //值=1\n  ![文件权限](/file-permissions.png)\n* chown(选项)(参数) 更改文件夹所有者和所属组\n  * chown -R user:group .git 将.git文件夹的权限设置为 group 下的 user\n* 获取文件路径：直接将文件拖入命令行即可\n  \n### 文件内容操作\n* file <fileName/directoryName\\> 查看文件类型信息\n* du <fileName/directoryName\\> 用来查看文件或目录所占用的磁盘空间的大小\n    * -h 以易于阅读的方式展示\n    * -a 显示目录及其下子目录和文件占用的磁盘空间大小\n    * -s 只展示当前目录占用磁盘空间大小\n* cat/more/less <fileName\\> 查看整个文件内容\n    * cat 一次性加载完所有文件内容\n    * more 一次显示一屏文本\n    * less 一次显示一屏文本 可以上下页翻建\n* tail/head <fileName\\> 查看部分文件内容\n    * tail 默认展示文件最后10行的效果\n        * -n 2 只显示文件最后两行\n        * -f 允许其他进程使用该文件时查看该文件的内容，tail会保持活跃状态，并不断显示添加到文件中的内容。（可用来实时监测系统日志）\n    * head 默认展示文件前10行内容\n        * 不支持 -f 属性\n* grep match_pattern <fileName\\> 强大的文本搜索工具，可以使用正则表达式搜索文本，并显示出匹配的行数\n* sed -i 's/被替换的内容/要替换的内容/g' file  -i 表示直接修改并保存\n    * [使用 sed 命令，报错`invalid command code`](https://blog.csdn.net/u010339879/article/details/90107977)，是因为 -i 原地替换是危险行为，需要指明一个备份的扩展名才可以，若给了空的扩展名，则不会备份源文件。\n    * 如 sed -i '' 's/被替换的内容/要替换的内容/g' file\n* ls -> xxx.txt 将命令输出的内容保存为文件\n\n\n### 监控进程\n* ps 显示进程信息（瞬间占用情况）\n* top 显示进程信息（实时占用情况）\n* lsof 查看进程打开的文件\n    * lsof -i:4000 查看4000端口占用情况\n* kill [PID] 杀死对应进程\n  \n### 网络情况\n* ping <ip\\> 测试主机之间的连通性(不会自动结束，需要手动 ctrl + c 强制退出)\n* dig <url\\> 域名查询工具，可以用来测试域名系统工作是否正常\n* nsloopup <url\\> 域名查询工具，查询 DNS 相关信息\n\n### 变量\n#### 环境变量\n* printenv/env 默认输出所有环境变量（全局）\n    * printenv JAVA_HOME 输出全局设置的JAVA SDK位置\n    * env $JAVA_HOME \n    * echo $JAVA_HOME \n* echo $variableName 输出变量 ($用来表名它是个变量)\n* set 输出所有环境变量（全局和局部）\n* $HOME 表示的用户的主目录，与波浪线`~`作用一样\n\n#### 普通变量\n声明时直接声明即可使用`variable=XXX`，变量名区分大小写，但需要注意的是 __赋值时，变量名、等号和值之间没有空格__ 否则会报错`command not found`。\n常用的书写习惯是 __所有的环境变量名均使用大写字母，若是自己创建的局部变量或是shell脚本，则用小写字母，变量名区分大小写。__\n\n### vim 操作\n* vim <fileName\\> 以 vim 编辑器的方式查看当前文件\n* 按 `I` 对文件进行 INSERT 操作\n* 按 `esc` 退出当前编辑模式\n* 输入 `:` 切换到底线命令模式，可以在最底行输入其他命令\n* 输入 `wq` ，保存并退出；输入 `!q`，不保存直接退出\n* .swp 文件: 非正常关闭的 vim 编辑器会生成一个 .swp 文件\n\n### 杂项\n#### 大小写转换\n* echo $VAR_NAME | tr '[:upper:]' '[:lower:]'\n* echo $VAR_NAME | tr '[A-Z]' '[a-z]'\n\n### 其他\n* alias 可用来查看当前可用的别名(内建命令)\n  * alias 新的命令='原命令 -选项/参数' 用来定义命令别名\n* sh <fileName.sh\\> 执行shell文件\n* .xxxrc 可以看做是xxx启动运行时的配置文件\n    * 例如 .zshrc 就是 zsh 运行前要执行配置文件\n* source <fileName\\> 或者 . <fileName\\> (bash内部命令) 加载文件\n* 文件\\包查找\n  * which <fileName\\> 查找该包编译器所在位置\n  * whereis <fileName\\> 搜索更大范围的系统目录并输出所有包含的路径\n  * find <fileName\\> 查找系统是否安装了某个软件包\n\n### 常用的配置文件地址\n* Host文件 /etc/hosts\n* 配置的SSH Key: cat ~/.ssh/id_rsa.pub\n\n### 常见文件颜色\n* 白色：表示普通文件\n* 蓝色：表示目录\n* 绿色：表示可执行文件\n* 红色：表示压缩文件\n* 浅蓝色：链接文件\n* 红色闪烁：表示链接的文件有问题\n* 黄色：表示设备文件\n* 灰色：表示其他文件\n\n### 插件\n* homebrew 包管理器\n    * brew install <packageName\\> 安装插件\n    * brew list 查看电脑安装了哪些插件\n* wget 下载网页常用的工具\n* curl 模拟 http 请求，类似于 POSTMAN\n    * curl <url\\> 直接返回 url 请求结果\n* tree 以树状图形式展示目录及其子文件\n    * tree <directory\\> -J 以 json 形式展示文件\n* tig 将git命令行可视化\n\n__其他参考:__\n* __[Linux命令大全](http://man.linuxde.net/)__\n* __[Linux命令英文缩写的含义](http://blog.chinaunix.net/uid-27164517-id-3299073.html)__\n* __[Shell基础](http://c.biancheng.net/shell/base/)__\n","slug":"Linux命令行与shell脚本学习","published":1,"updated":"2020-12-12T06:38:43.774Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0g000a7vvucaoqnvsg","content":"<p>《Linux命令行与shell脚本编程大全》读书小结，熟悉一下常用的命令行操作。书籍比较基础，对熟悉Linux命令行的人来说参考意义不大。主要记录下书中提到的、没提到的常用的命令。<br><a id=\"more\"></a></p>\n<h3 id=\"基础操作\"><a href=\"#基础操作\" class=\"headerlink\" title=\"基础操作\"></a>基础操作</h3><ul>\n<li>. 代表当前目录</li>\n<li>.. 代表父级目录</li>\n<li>~ 代表根目录 表名当前工作目录位于用户home目录之下</li>\n<li>man &lt;directive> 可查看指令可使用的参数手册</li>\n<li><code>tab</code> 键自动补全文件名</li>\n<li>cd 切换目录</li>\n<li>linux 中的文件路径全部采用正斜线<code>/</code>，windows中的路径都是反斜线<code>\\</code>而且带盘符</li>\n<li>ls 列出当前路径下的所有文件<ul>\n<li>-F 在显示子目录的时候在它的文件名之后加上一个斜线(“/”)字符</li>\n<li>-F -R 遍历(递归)出当前目录下的子文件夹的所有内容(可以缩写成 ls -FR )</li>\n<li>-a 列出所有文件，包括隐藏文件</li>\n<li>-l 列出文件的所有信息</li>\n</ul>\n</li>\n<li>pwd 查看当前所在位置的全路径</li>\n<li>sudo 以 root 用户身份运行命令</li>\n</ul>\n<h3 id=\"文件基础操作\"><a href=\"#文件基础操作\" class=\"headerlink\" title=\"文件基础操作\"></a>文件基础操作</h3><ul>\n<li>open &lt;fileName> 用默认程序打开文件</li>\n<li>touch &lt;fileName> 创建一个文件 (不可在不存在的目录下新建文件)</li>\n<li>mkdir &lt;directory> 创建一个文件夹<ul>\n<li>-p 创建多个层级的文件夹</li>\n</ul>\n</li>\n<li>rmdir &lt;directory> 只删除空目录<ul>\n<li>在非空目录下使用 rm -r 命令</li>\n</ul>\n</li>\n<li>cp &lt;fileName> &lt;targetDirectory/fileName&gt; 复制文件到目标文件夹/文件名<ul>\n<li>-i 强制 shell 询问是否覆盖同名文件</li>\n</ul>\n</li>\n<li>scp &lt;fileName> &lt;root@targetPath&gt; 远程拷贝文件 可以跨服务器</li>\n<li>mv &lt;fileName> &lt;directory/fileName&gt; 用来 移动/重命名 文件<ul>\n<li>-i 强制 shell 询问是否覆盖同名文件</li>\n</ul>\n</li>\n<li>rm &lt;fileName> 删除文件/文件夹中的所有内容<ul>\n<li>-i 强制 shell 询问是否删除文件</li>\n<li>-f 强制删除，没有警告信息也没有声音提示</li>\n<li>-r 递归删除目录及目录内所有文件  </li>\n<li><strong>注意：Linux 中没有回收站或垃圾箱，文件一旦删除，就无法再找回</strong></li>\n</ul>\n</li>\n<li>ls -l &lt;fileName> 查看文件权限</li>\n<li>chmod value &lt;fileName> 更改文件权限<ul>\n<li>权限描述顺序依次是：Owner(User)、Group、Other</li>\n<li>r=读取属性 //值=4</li>\n<li>w=写入属性 //值=2</li>\n<li>x=执行属性 //值=1<br><img src=\"/2018/11/30/Linux命令行与shell脚本学习/file-permissions.png\" alt=\"文件权限\"></li>\n</ul>\n</li>\n<li>chown(选项)(参数) 更改文件夹所有者和所属组<ul>\n<li>chown -R user:group .git 将.git文件夹的权限设置为 group 下的 user</li>\n</ul>\n</li>\n<li>获取文件路径：直接将文件拖入命令行即可</li>\n</ul>\n<h3 id=\"文件内容操作\"><a href=\"#文件内容操作\" class=\"headerlink\" title=\"文件内容操作\"></a>文件内容操作</h3><ul>\n<li>file &lt;fileName/directoryName> 查看文件类型信息</li>\n<li>du &lt;fileName/directoryName> 用来查看文件或目录所占用的磁盘空间的大小<ul>\n<li>-h 以易于阅读的方式展示</li>\n<li>-a 显示目录及其下子目录和文件占用的磁盘空间大小</li>\n<li>-s 只展示当前目录占用磁盘空间大小</li>\n</ul>\n</li>\n<li>cat/more/less &lt;fileName> 查看整个文件内容<ul>\n<li>cat 一次性加载完所有文件内容</li>\n<li>more 一次显示一屏文本</li>\n<li>less 一次显示一屏文本 可以上下页翻建</li>\n</ul>\n</li>\n<li>tail/head &lt;fileName> 查看部分文件内容<ul>\n<li>tail 默认展示文件最后10行的效果<ul>\n<li>-n 2 只显示文件最后两行</li>\n<li>-f 允许其他进程使用该文件时查看该文件的内容，tail会保持活跃状态，并不断显示添加到文件中的内容。（可用来实时监测系统日志）</li>\n</ul>\n</li>\n<li>head 默认展示文件前10行内容<ul>\n<li>不支持 -f 属性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>grep match_pattern &lt;fileName> 强大的文本搜索工具，可以使用正则表达式搜索文本，并显示出匹配的行数</li>\n<li>sed -i ‘s/被替换的内容/要替换的内容/g’ file  -i 表示直接修改并保存<ul>\n<li><a href=\"https://blog.csdn.net/u010339879/article/details/90107977\" target=\"_blank\" rel=\"noopener\">使用 sed 命令，报错<code>invalid command code</code></a>，是因为 -i 原地替换是危险行为，需要指明一个备份的扩展名才可以，若给了空的扩展名，则不会备份源文件。</li>\n<li>如 sed -i ‘’ ‘s/被替换的内容/要替换的内容/g’ file</li>\n</ul>\n</li>\n<li>ls -&gt; xxx.txt 将命令输出的内容保存为文件</li>\n</ul>\n<h3 id=\"监控进程\"><a href=\"#监控进程\" class=\"headerlink\" title=\"监控进程\"></a>监控进程</h3><ul>\n<li>ps 显示进程信息（瞬间占用情况）</li>\n<li>top 显示进程信息（实时占用情况）</li>\n<li>lsof 查看进程打开的文件<ul>\n<li>lsof -i:4000 查看4000端口占用情况</li>\n</ul>\n</li>\n<li>kill [PID] 杀死对应进程</li>\n</ul>\n<h3 id=\"网络情况\"><a href=\"#网络情况\" class=\"headerlink\" title=\"网络情况\"></a>网络情况</h3><ul>\n<li>ping &lt;ip> 测试主机之间的连通性(不会自动结束，需要手动 ctrl + c 强制退出)</li>\n<li>dig &lt;url> 域名查询工具，可以用来测试域名系统工作是否正常</li>\n<li>nsloopup &lt;url> 域名查询工具，查询 DNS 相关信息</li>\n</ul>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><h4 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h4><ul>\n<li>printenv/env 默认输出所有环境变量（全局）<ul>\n<li>printenv JAVA_HOME 输出全局设置的JAVA SDK位置</li>\n<li>env $JAVA_HOME </li>\n<li>echo $JAVA_HOME </li>\n</ul>\n</li>\n<li>echo $variableName 输出变量 ($用来表名它是个变量)</li>\n<li>set 输出所有环境变量（全局和局部）</li>\n<li>$HOME 表示的用户的主目录，与波浪线<code>~</code>作用一样</li>\n</ul>\n<h4 id=\"普通变量\"><a href=\"#普通变量\" class=\"headerlink\" title=\"普通变量\"></a>普通变量</h4><p>声明时直接声明即可使用<code>variable=XXX</code>，变量名区分大小写，但需要注意的是 <strong>赋值时，变量名、等号和值之间没有空格</strong> 否则会报错<code>command not found</code>。<br>常用的书写习惯是 <strong>所有的环境变量名均使用大写字母，若是自己创建的局部变量或是shell脚本，则用小写字母，变量名区分大小写。</strong></p>\n<h3 id=\"vim-操作\"><a href=\"#vim-操作\" class=\"headerlink\" title=\"vim 操作\"></a>vim 操作</h3><ul>\n<li>vim &lt;fileName> 以 vim 编辑器的方式查看当前文件</li>\n<li>按 <code>I</code> 对文件进行 INSERT 操作</li>\n<li>按 <code>esc</code> 退出当前编辑模式</li>\n<li>输入 <code>:</code> 切换到底线命令模式，可以在最底行输入其他命令</li>\n<li>输入 <code>wq</code> ，保存并退出；输入 <code>!q</code>，不保存直接退出</li>\n<li>.swp 文件: 非正常关闭的 vim 编辑器会生成一个 .swp 文件</li>\n</ul>\n<h3 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h3><h4 id=\"大小写转换\"><a href=\"#大小写转换\" class=\"headerlink\" title=\"大小写转换\"></a>大小写转换</h4><ul>\n<li>echo $VAR_NAME | tr ‘[:upper:]’ ‘[:lower:]’</li>\n<li>echo $VAR_NAME | tr ‘[A-Z]’ ‘[a-z]’</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>alias 可用来查看当前可用的别名(内建命令)<ul>\n<li>alias 新的命令=’原命令 -选项/参数’ 用来定义命令别名</li>\n</ul>\n</li>\n<li>sh &lt;fileName.sh> 执行shell文件</li>\n<li>.xxxrc 可以看做是xxx启动运行时的配置文件<ul>\n<li>例如 .zshrc 就是 zsh 运行前要执行配置文件</li>\n</ul>\n</li>\n<li>source &lt;fileName> 或者 . &lt;fileName> (bash内部命令) 加载文件</li>\n<li>文件\\包查找<ul>\n<li>which &lt;fileName> 查找该包编译器所在位置</li>\n<li>whereis &lt;fileName> 搜索更大范围的系统目录并输出所有包含的路径</li>\n<li>find &lt;fileName> 查找系统是否安装了某个软件包</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常用的配置文件地址\"><a href=\"#常用的配置文件地址\" class=\"headerlink\" title=\"常用的配置文件地址\"></a>常用的配置文件地址</h3><ul>\n<li>Host文件 /etc/hosts</li>\n<li>配置的SSH Key: cat ~/.ssh/id_rsa.pub</li>\n</ul>\n<h3 id=\"常见文件颜色\"><a href=\"#常见文件颜色\" class=\"headerlink\" title=\"常见文件颜色\"></a>常见文件颜色</h3><ul>\n<li>白色：表示普通文件</li>\n<li>蓝色：表示目录</li>\n<li>绿色：表示可执行文件</li>\n<li>红色：表示压缩文件</li>\n<li>浅蓝色：链接文件</li>\n<li>红色闪烁：表示链接的文件有问题</li>\n<li>黄色：表示设备文件</li>\n<li>灰色：表示其他文件</li>\n</ul>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><ul>\n<li>homebrew 包管理器<ul>\n<li>brew install &lt;packageName> 安装插件</li>\n<li>brew list 查看电脑安装了哪些插件</li>\n</ul>\n</li>\n<li>wget 下载网页常用的工具</li>\n<li>curl 模拟 http 请求，类似于 POSTMAN<ul>\n<li>curl &lt;url> 直接返回 url 请求结果</li>\n</ul>\n</li>\n<li>tree 以树状图形式展示目录及其子文件<ul>\n<li>tree &lt;directory> -J 以 json 形式展示文件</li>\n</ul>\n</li>\n<li>tig 将git命令行可视化</li>\n</ul>\n<p><strong>其他参考:</strong></p>\n<ul>\n<li><strong><a href=\"http://man.linuxde.net/\" target=\"_blank\" rel=\"noopener\">Linux命令大全</a></strong></li>\n<li><strong><a href=\"http://blog.chinaunix.net/uid-27164517-id-3299073.html\" target=\"_blank\" rel=\"noopener\">Linux命令英文缩写的含义</a></strong></li>\n<li><strong><a href=\"http://c.biancheng.net/shell/base/\" target=\"_blank\" rel=\"noopener\">Shell基础</a></strong></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>《Linux命令行与shell脚本编程大全》读书小结，熟悉一下常用的命令行操作。书籍比较基础，对熟悉Linux命令行的人来说参考意义不大。主要记录下书中提到的、没提到的常用的命令。<br></p>","more":"<p></p>\n<h3 id=\"基础操作\"><a href=\"#基础操作\" class=\"headerlink\" title=\"基础操作\"></a>基础操作</h3><ul>\n<li>. 代表当前目录</li>\n<li>.. 代表父级目录</li>\n<li>~ 代表根目录 表名当前工作目录位于用户home目录之下</li>\n<li>man &lt;directive> 可查看指令可使用的参数手册</li>\n<li><code>tab</code> 键自动补全文件名</li>\n<li>cd 切换目录</li>\n<li>linux 中的文件路径全部采用正斜线<code>/</code>，windows中的路径都是反斜线<code>\\</code>而且带盘符</li>\n<li>ls 列出当前路径下的所有文件<ul>\n<li>-F 在显示子目录的时候在它的文件名之后加上一个斜线(“/”)字符</li>\n<li>-F -R 遍历(递归)出当前目录下的子文件夹的所有内容(可以缩写成 ls -FR )</li>\n<li>-a 列出所有文件，包括隐藏文件</li>\n<li>-l 列出文件的所有信息</li>\n</ul>\n</li>\n<li>pwd 查看当前所在位置的全路径</li>\n<li>sudo 以 root 用户身份运行命令</li>\n</ul>\n<h3 id=\"文件基础操作\"><a href=\"#文件基础操作\" class=\"headerlink\" title=\"文件基础操作\"></a>文件基础操作</h3><ul>\n<li>open &lt;fileName> 用默认程序打开文件</li>\n<li>touch &lt;fileName> 创建一个文件 (不可在不存在的目录下新建文件)</li>\n<li>mkdir &lt;directory> 创建一个文件夹<ul>\n<li>-p 创建多个层级的文件夹</li>\n</ul>\n</li>\n<li>rmdir &lt;directory> 只删除空目录<ul>\n<li>在非空目录下使用 rm -r 命令</li>\n</ul>\n</li>\n<li>cp &lt;fileName> &lt;targetDirectory/fileName&gt; 复制文件到目标文件夹/文件名<ul>\n<li>-i 强制 shell 询问是否覆盖同名文件</li>\n</ul>\n</li>\n<li>scp &lt;fileName> &lt;root@targetPath&gt; 远程拷贝文件 可以跨服务器</li>\n<li>mv &lt;fileName> &lt;directory/fileName&gt; 用来 移动/重命名 文件<ul>\n<li>-i 强制 shell 询问是否覆盖同名文件</li>\n</ul>\n</li>\n<li>rm &lt;fileName> 删除文件/文件夹中的所有内容<ul>\n<li>-i 强制 shell 询问是否删除文件</li>\n<li>-f 强制删除，没有警告信息也没有声音提示</li>\n<li>-r 递归删除目录及目录内所有文件  </li>\n<li><strong>注意：Linux 中没有回收站或垃圾箱，文件一旦删除，就无法再找回</strong></li>\n</ul>\n</li>\n<li>ls -l &lt;fileName> 查看文件权限</li>\n<li>chmod value &lt;fileName> 更改文件权限<ul>\n<li>权限描述顺序依次是：Owner(User)、Group、Other</li>\n<li>r=读取属性 //值=4</li>\n<li>w=写入属性 //值=2</li>\n<li>x=执行属性 //值=1<br><img src=\"/2018/11/30/Linux命令行与shell脚本学习/file-permissions.png\" alt=\"文件权限\"></li>\n</ul>\n</li>\n<li>chown(选项)(参数) 更改文件夹所有者和所属组<ul>\n<li>chown -R user:group .git 将.git文件夹的权限设置为 group 下的 user</li>\n</ul>\n</li>\n<li>获取文件路径：直接将文件拖入命令行即可</li>\n</ul>\n<h3 id=\"文件内容操作\"><a href=\"#文件内容操作\" class=\"headerlink\" title=\"文件内容操作\"></a>文件内容操作</h3><ul>\n<li>file &lt;fileName/directoryName> 查看文件类型信息</li>\n<li>du &lt;fileName/directoryName> 用来查看文件或目录所占用的磁盘空间的大小<ul>\n<li>-h 以易于阅读的方式展示</li>\n<li>-a 显示目录及其下子目录和文件占用的磁盘空间大小</li>\n<li>-s 只展示当前目录占用磁盘空间大小</li>\n</ul>\n</li>\n<li>cat/more/less &lt;fileName> 查看整个文件内容<ul>\n<li>cat 一次性加载完所有文件内容</li>\n<li>more 一次显示一屏文本</li>\n<li>less 一次显示一屏文本 可以上下页翻建</li>\n</ul>\n</li>\n<li>tail/head &lt;fileName> 查看部分文件内容<ul>\n<li>tail 默认展示文件最后10行的效果<ul>\n<li>-n 2 只显示文件最后两行</li>\n<li>-f 允许其他进程使用该文件时查看该文件的内容，tail会保持活跃状态，并不断显示添加到文件中的内容。（可用来实时监测系统日志）</li>\n</ul>\n</li>\n<li>head 默认展示文件前10行内容<ul>\n<li>不支持 -f 属性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>grep match_pattern &lt;fileName> 强大的文本搜索工具，可以使用正则表达式搜索文本，并显示出匹配的行数</li>\n<li>sed -i ‘s/被替换的内容/要替换的内容/g’ file  -i 表示直接修改并保存<ul>\n<li><a href=\"https://blog.csdn.net/u010339879/article/details/90107977\" target=\"_blank\" rel=\"noopener\">使用 sed 命令，报错<code>invalid command code</code></a>，是因为 -i 原地替换是危险行为，需要指明一个备份的扩展名才可以，若给了空的扩展名，则不会备份源文件。</li>\n<li>如 sed -i ‘’ ‘s/被替换的内容/要替换的内容/g’ file</li>\n</ul>\n</li>\n<li>ls -&gt; xxx.txt 将命令输出的内容保存为文件</li>\n</ul>\n<h3 id=\"监控进程\"><a href=\"#监控进程\" class=\"headerlink\" title=\"监控进程\"></a>监控进程</h3><ul>\n<li>ps 显示进程信息（瞬间占用情况）</li>\n<li>top 显示进程信息（实时占用情况）</li>\n<li>lsof 查看进程打开的文件<ul>\n<li>lsof -i:4000 查看4000端口占用情况</li>\n</ul>\n</li>\n<li>kill [PID] 杀死对应进程</li>\n</ul>\n<h3 id=\"网络情况\"><a href=\"#网络情况\" class=\"headerlink\" title=\"网络情况\"></a>网络情况</h3><ul>\n<li>ping &lt;ip> 测试主机之间的连通性(不会自动结束，需要手动 ctrl + c 强制退出)</li>\n<li>dig &lt;url> 域名查询工具，可以用来测试域名系统工作是否正常</li>\n<li>nsloopup &lt;url> 域名查询工具，查询 DNS 相关信息</li>\n</ul>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><h4 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h4><ul>\n<li>printenv/env 默认输出所有环境变量（全局）<ul>\n<li>printenv JAVA_HOME 输出全局设置的JAVA SDK位置</li>\n<li>env $JAVA_HOME </li>\n<li>echo $JAVA_HOME </li>\n</ul>\n</li>\n<li>echo $variableName 输出变量 ($用来表名它是个变量)</li>\n<li>set 输出所有环境变量（全局和局部）</li>\n<li>$HOME 表示的用户的主目录，与波浪线<code>~</code>作用一样</li>\n</ul>\n<h4 id=\"普通变量\"><a href=\"#普通变量\" class=\"headerlink\" title=\"普通变量\"></a>普通变量</h4><p>声明时直接声明即可使用<code>variable=XXX</code>，变量名区分大小写，但需要注意的是 <strong>赋值时，变量名、等号和值之间没有空格</strong> 否则会报错<code>command not found</code>。<br>常用的书写习惯是 <strong>所有的环境变量名均使用大写字母，若是自己创建的局部变量或是shell脚本，则用小写字母，变量名区分大小写。</strong></p>\n<h3 id=\"vim-操作\"><a href=\"#vim-操作\" class=\"headerlink\" title=\"vim 操作\"></a>vim 操作</h3><ul>\n<li>vim &lt;fileName> 以 vim 编辑器的方式查看当前文件</li>\n<li>按 <code>I</code> 对文件进行 INSERT 操作</li>\n<li>按 <code>esc</code> 退出当前编辑模式</li>\n<li>输入 <code>:</code> 切换到底线命令模式，可以在最底行输入其他命令</li>\n<li>输入 <code>wq</code> ，保存并退出；输入 <code>!q</code>，不保存直接退出</li>\n<li>.swp 文件: 非正常关闭的 vim 编辑器会生成一个 .swp 文件</li>\n</ul>\n<h3 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h3><h4 id=\"大小写转换\"><a href=\"#大小写转换\" class=\"headerlink\" title=\"大小写转换\"></a>大小写转换</h4><ul>\n<li>echo $VAR_NAME | tr ‘[:upper:]’ ‘[:lower:]’</li>\n<li>echo $VAR_NAME | tr ‘[A-Z]’ ‘[a-z]’</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>alias 可用来查看当前可用的别名(内建命令)<ul>\n<li>alias 新的命令=’原命令 -选项/参数’ 用来定义命令别名</li>\n</ul>\n</li>\n<li>sh &lt;fileName.sh> 执行shell文件</li>\n<li>.xxxrc 可以看做是xxx启动运行时的配置文件<ul>\n<li>例如 .zshrc 就是 zsh 运行前要执行配置文件</li>\n</ul>\n</li>\n<li>source &lt;fileName> 或者 . &lt;fileName> (bash内部命令) 加载文件</li>\n<li>文件\\包查找<ul>\n<li>which &lt;fileName> 查找该包编译器所在位置</li>\n<li>whereis &lt;fileName> 搜索更大范围的系统目录并输出所有包含的路径</li>\n<li>find &lt;fileName> 查找系统是否安装了某个软件包</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常用的配置文件地址\"><a href=\"#常用的配置文件地址\" class=\"headerlink\" title=\"常用的配置文件地址\"></a>常用的配置文件地址</h3><ul>\n<li>Host文件 /etc/hosts</li>\n<li>配置的SSH Key: cat ~/.ssh/id_rsa.pub</li>\n</ul>\n<h3 id=\"常见文件颜色\"><a href=\"#常见文件颜色\" class=\"headerlink\" title=\"常见文件颜色\"></a>常见文件颜色</h3><ul>\n<li>白色：表示普通文件</li>\n<li>蓝色：表示目录</li>\n<li>绿色：表示可执行文件</li>\n<li>红色：表示压缩文件</li>\n<li>浅蓝色：链接文件</li>\n<li>红色闪烁：表示链接的文件有问题</li>\n<li>黄色：表示设备文件</li>\n<li>灰色：表示其他文件</li>\n</ul>\n<h3 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h3><ul>\n<li>homebrew 包管理器<ul>\n<li>brew install &lt;packageName> 安装插件</li>\n<li>brew list 查看电脑安装了哪些插件</li>\n</ul>\n</li>\n<li>wget 下载网页常用的工具</li>\n<li>curl 模拟 http 请求，类似于 POSTMAN<ul>\n<li>curl &lt;url> 直接返回 url 请求结果</li>\n</ul>\n</li>\n<li>tree 以树状图形式展示目录及其子文件<ul>\n<li>tree &lt;directory> -J 以 json 形式展示文件</li>\n</ul>\n</li>\n<li>tig 将git命令行可视化</li>\n</ul>\n<p><strong>其他参考:</strong></p>\n<ul>\n<li><strong><a href=\"http://man.linuxde.net/\" target=\"_blank\" rel=\"noopener\">Linux命令大全</a></strong></li>\n<li><strong><a href=\"http://blog.chinaunix.net/uid-27164517-id-3299073.html\" target=\"_blank\" rel=\"noopener\">Linux命令英文缩写的含义</a></strong></li>\n<li><strong><a href=\"http://c.biancheng.net/shell/base/\" target=\"_blank\" rel=\"noopener\">Shell基础</a></strong></li>\n</ul>"},{"title":"Markdown 语法小记","date":"2018-09-05T10:21:06.000Z","_content":"第一个Hexo-next主题的blog，主要用来记录markdown语法\n<!--more-->\n\n### 测试文本样式\n#### 测试加粗样式\n**加粗**\n#### 测试斜体样式\n*斜体*\n#### 测试删除线样式\n~~删除线~~\n#### 测试引用样式\n> 山穷水尽疑无路，柳暗花明又一村\n\n### 测试代码样式\n#### 测试指定代码语言代码样式\n````javascript\nvar FE_developer = {\n\tname: 'Kuro',\n\tage: '22'\n};\n\nconsole.log('info', FE_developer);\n````\n#### 测试单行代码样式\n在JS中我们常用`console.log()`来输出调试信息。\n\n#### 测试代码块样式\n```\nfunction test(a, b){\n\tsetTimeout(function(){\n\t\tconsole.log(a + b);\n\t\tsetTimeout(arguments.callee, 500);\n\t\t}, 500)\n}\n```\n\n### 测试连接样式\n百度一下：[Baidu](https://www.baidu.com)\n\n### 测试首行缩进样式\n&emsp;&emsp;markdown 语法主要考虑的是英文，中文缩进需要依赖 HTML 的空格符号\n````\n    半角空格: &nbsp;\n    全角空格：&emsp;\n````\n\n### 测试表格样式\n| 左对齐 | 居中对齐 | 右对齐 |\n| - | :-: | -: | \n| Harry Potter | Gryffindor| 90 | \n| Hermione Granger | Gryffindor | 100 | \n| Draco Malfoy | Slytherin | 90 |\n\n表格使用 `|` 来分隔不同的单元格，使用 `-` 来分隔表头和其他行。\n__注意：表格前若有文本，需要空一行才能正常显示__\n\n\n### 测试插入图片\n来自百度图片: ![夏日西瓜](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1536749860&di=13b529d93aa88d542b4e7d1fece8cd85&imgtype=jpg&er=1&src=http%3A%2F%2Fpic.90sjimg.com%2Fdesign%2F00%2F89%2F85%2F87%2Fs_1024_58bd1a48a0978.png \"西瓜\")\n\n### 测试列表\ngit常用语法\n* git status\n* git add .\n* git commit -m\"XXX\"\n\n+ git stash\n+ git list\n+ git stash apply stash@{n}\n\n- git diff\n- git reset --hard\n\n1. 列表内容\n   * 列表嵌套第一条\n   * 列表嵌套第二条\n2. 列表内容\n3. 列表内容\n\n### 测试复选框样式\n- [x] 选项一\n- [ ] 选项二\n- [ ] 选项三\n\n### 测试流程图样式\n```flow\nst=>start: 开始\ne=>end: 结束\nio1=>inputoutput: 输入聚类类数k\nop1=>operation: 筛选初始质心\nop2=>operation: 计算样本点到各个质心之间的距离\n并将其归到距离其最近的质心所在簇中\nop3=>operation: 计算各簇均值，生成新的质心\nc1=>condition: 新旧质心距离小于阈值\nio2=>inputoutput: 输出聚类结果\n\nst->io1->op1->op2->op3->c1\nc1(no)->op2\nc1(yes)->io2->e\n```\n\n### 其他注意事项\n* 在 Markdown 中直接使用尖括号`<something>`会被文本默认为HTML标签语句而不予显示。\n    * 使用转义字符`&lt;`代替`<`，用`&gt;`代替`>`\n    * 或者右闭合的尖括号前加一个转义符号`\\`，例如：`<something\\>`\n","source":"_posts/MarkDown语法小记.md","raw":"---\ntitle: Markdown 语法小记\ndate: 2018-09-05 18:21:06\ntags: [Markdown]\ncategories: 其他小结\n---\n第一个Hexo-next主题的blog，主要用来记录markdown语法\n<!--more-->\n\n### 测试文本样式\n#### 测试加粗样式\n**加粗**\n#### 测试斜体样式\n*斜体*\n#### 测试删除线样式\n~~删除线~~\n#### 测试引用样式\n> 山穷水尽疑无路，柳暗花明又一村\n\n### 测试代码样式\n#### 测试指定代码语言代码样式\n````javascript\nvar FE_developer = {\n\tname: 'Kuro',\n\tage: '22'\n};\n\nconsole.log('info', FE_developer);\n````\n#### 测试单行代码样式\n在JS中我们常用`console.log()`来输出调试信息。\n\n#### 测试代码块样式\n```\nfunction test(a, b){\n\tsetTimeout(function(){\n\t\tconsole.log(a + b);\n\t\tsetTimeout(arguments.callee, 500);\n\t\t}, 500)\n}\n```\n\n### 测试连接样式\n百度一下：[Baidu](https://www.baidu.com)\n\n### 测试首行缩进样式\n&emsp;&emsp;markdown 语法主要考虑的是英文，中文缩进需要依赖 HTML 的空格符号\n````\n    半角空格: &nbsp;\n    全角空格：&emsp;\n````\n\n### 测试表格样式\n| 左对齐 | 居中对齐 | 右对齐 |\n| - | :-: | -: | \n| Harry Potter | Gryffindor| 90 | \n| Hermione Granger | Gryffindor | 100 | \n| Draco Malfoy | Slytherin | 90 |\n\n表格使用 `|` 来分隔不同的单元格，使用 `-` 来分隔表头和其他行。\n__注意：表格前若有文本，需要空一行才能正常显示__\n\n\n### 测试插入图片\n来自百度图片: ![夏日西瓜](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1536749860&di=13b529d93aa88d542b4e7d1fece8cd85&imgtype=jpg&er=1&src=http%3A%2F%2Fpic.90sjimg.com%2Fdesign%2F00%2F89%2F85%2F87%2Fs_1024_58bd1a48a0978.png \"西瓜\")\n\n### 测试列表\ngit常用语法\n* git status\n* git add .\n* git commit -m\"XXX\"\n\n+ git stash\n+ git list\n+ git stash apply stash@{n}\n\n- git diff\n- git reset --hard\n\n1. 列表内容\n   * 列表嵌套第一条\n   * 列表嵌套第二条\n2. 列表内容\n3. 列表内容\n\n### 测试复选框样式\n- [x] 选项一\n- [ ] 选项二\n- [ ] 选项三\n\n### 测试流程图样式\n```flow\nst=>start: 开始\ne=>end: 结束\nio1=>inputoutput: 输入聚类类数k\nop1=>operation: 筛选初始质心\nop2=>operation: 计算样本点到各个质心之间的距离\n并将其归到距离其最近的质心所在簇中\nop3=>operation: 计算各簇均值，生成新的质心\nc1=>condition: 新旧质心距离小于阈值\nio2=>inputoutput: 输出聚类结果\n\nst->io1->op1->op2->op3->c1\nc1(no)->op2\nc1(yes)->io2->e\n```\n\n### 其他注意事项\n* 在 Markdown 中直接使用尖括号`<something>`会被文本默认为HTML标签语句而不予显示。\n    * 使用转义字符`&lt;`代替`<`，用`&gt;`代替`>`\n    * 或者右闭合的尖括号前加一个转义符号`\\`，例如：`<something\\>`\n","slug":"MarkDown语法小记","published":1,"updated":"2020-11-04T08:29:30.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0m000d7vvu2n3chatg","content":"<p>第一个Hexo-next主题的blog，主要用来记录markdown语法<br><a id=\"more\"></a></p>\n<h3 id=\"测试文本样式\"><a href=\"#测试文本样式\" class=\"headerlink\" title=\"测试文本样式\"></a>测试文本样式</h3><h4 id=\"测试加粗样式\"><a href=\"#测试加粗样式\" class=\"headerlink\" title=\"测试加粗样式\"></a>测试加粗样式</h4><p><strong>加粗</strong></p>\n<h4 id=\"测试斜体样式\"><a href=\"#测试斜体样式\" class=\"headerlink\" title=\"测试斜体样式\"></a>测试斜体样式</h4><p><em>斜体</em></p>\n<h4 id=\"测试删除线样式\"><a href=\"#测试删除线样式\" class=\"headerlink\" title=\"测试删除线样式\"></a>测试删除线样式</h4><p><del>删除线</del></p>\n<h4 id=\"测试引用样式\"><a href=\"#测试引用样式\" class=\"headerlink\" title=\"测试引用样式\"></a>测试引用样式</h4><blockquote>\n<p>山穷水尽疑无路，柳暗花明又一村</p>\n</blockquote>\n<h3 id=\"测试代码样式\"><a href=\"#测试代码样式\" class=\"headerlink\" title=\"测试代码样式\"></a>测试代码样式</h3><h4 id=\"测试指定代码语言代码样式\"><a href=\"#测试指定代码语言代码样式\" class=\"headerlink\" title=\"测试指定代码语言代码样式\"></a>测试指定代码语言代码样式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> FE_developer = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'Kuro'</span>,</span><br><span class=\"line\">\tage: <span class=\"string\">'22'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'info'</span>, FE_developer);</span><br></pre></td></tr></table></figure>\n<h4 id=\"测试单行代码样式\"><a href=\"#测试单行代码样式\" class=\"headerlink\" title=\"测试单行代码样式\"></a>测试单行代码样式</h4><p>在JS中我们常用<code>console.log()</code>来输出调试信息。</p>\n<h4 id=\"测试代码块样式\"><a href=\"#测试代码块样式\" class=\"headerlink\" title=\"测试代码块样式\"></a>测试代码块样式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(a, b)&#123;</span><br><span class=\"line\">\tsetTimeout(function()&#123;</span><br><span class=\"line\">\t\tconsole.log(a + b);</span><br><span class=\"line\">\t\tsetTimeout(arguments.callee, 500);</span><br><span class=\"line\">\t\t&#125;, 500)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试连接样式\"><a href=\"#测试连接样式\" class=\"headerlink\" title=\"测试连接样式\"></a>测试连接样式</h3><p>百度一下：<a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"noopener\">Baidu</a></p>\n<h3 id=\"测试首行缩进样式\"><a href=\"#测试首行缩进样式\" class=\"headerlink\" title=\"测试首行缩进样式\"></a>测试首行缩进样式</h3><p>&emsp;&emsp;markdown 语法主要考虑的是英文，中文缩进需要依赖 HTML 的空格符号<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">半角空格: &amp;nbsp;</span><br><span class=\"line\">全角空格：&amp;emsp;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"测试表格样式\"><a href=\"#测试表格样式\" class=\"headerlink\" title=\"测试表格样式\"></a>测试表格样式</h3><table>\n<thead>\n<tr>\n<th>左对齐</th>\n<th style=\"text-align:center\">居中对齐</th>\n<th style=\"text-align:right\">右对齐</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Harry Potter</td>\n<td style=\"text-align:center\">Gryffindor</td>\n<td style=\"text-align:right\">90</td>\n</tr>\n<tr>\n<td>Hermione Granger</td>\n<td style=\"text-align:center\">Gryffindor</td>\n<td style=\"text-align:right\">100</td>\n</tr>\n<tr>\n<td>Draco Malfoy</td>\n<td style=\"text-align:center\">Slytherin</td>\n<td style=\"text-align:right\">90</td>\n</tr>\n</tbody>\n</table>\n<p>表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。<br><strong>注意：表格前若有文本，需要空一行才能正常显示</strong></p>\n<h3 id=\"测试插入图片\"><a href=\"#测试插入图片\" class=\"headerlink\" title=\"测试插入图片\"></a>测试插入图片</h3><p>来自百度图片: <img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1536749860&amp;di=13b529d93aa88d542b4e7d1fece8cd85&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fpic.90sjimg.com%2Fdesign%2F00%2F89%2F85%2F87%2Fs_1024_58bd1a48a0978.png\" alt=\"夏日西瓜\" title=\"西瓜\"></p>\n<h3 id=\"测试列表\"><a href=\"#测试列表\" class=\"headerlink\" title=\"测试列表\"></a>测试列表</h3><p>git常用语法</p>\n<ul>\n<li>git status</li>\n<li>git add .</li>\n<li>git commit -m”XXX”</li>\n</ul>\n<ul>\n<li>git stash</li>\n<li>git list</li>\n<li>git stash apply stash@{n}</li>\n</ul>\n<ul>\n<li>git diff</li>\n<li>git reset –hard</li>\n</ul>\n<ol>\n<li>列表内容<ul>\n<li>列表嵌套第一条</li>\n<li>列表嵌套第二条</li>\n</ul>\n</li>\n<li>列表内容</li>\n<li>列表内容</li>\n</ol>\n<h3 id=\"测试复选框样式\"><a href=\"#测试复选框样式\" class=\"headerlink\" title=\"测试复选框样式\"></a>测试复选框样式</h3><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> 选项一</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 选项二</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 选项三</li>\n</ul>\n<h3 id=\"测试流程图样式\"><a href=\"#测试流程图样式\" class=\"headerlink\" title=\"测试流程图样式\"></a>测试流程图样式</h3><div id=\"flowchart-0\" class=\"flow-chart\"></div>\n\n<h3 id=\"其他注意事项\"><a href=\"#其他注意事项\" class=\"headerlink\" title=\"其他注意事项\"></a>其他注意事项</h3><ul>\n<li>在 Markdown 中直接使用尖括号<code>&lt;something&gt;</code>会被文本默认为HTML标签语句而不予显示。<ul>\n<li>使用转义字符<code>&amp;lt;</code>代替<code>&lt;</code>，用<code>&amp;gt;</code>代替<code>&gt;</code></li>\n<li>或者右闭合的尖括号前加一个转义符号<code>\\</code>，例如：<code>&lt;something\\&gt;</code><br><script src=\"https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js\"></script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js\"></script><textarea id=\"flowchart-0-code\" style=\"display: none\">st=>start: 开始\ne=>end: 结束\nio1=>inputoutput: 输入聚类类数k\nop1=>operation: 筛选初始质心\nop2=>operation: 计算样本点到各个质心之间的距离\n并将其归到距离其最近的质心所在簇中\nop3=>operation: 计算各簇均值，生成新的质心\nc1=>condition: 新旧质心距离小于阈值\nio2=>inputoutput: 输出聚类结果\n\nst->io1->op1->op2->op3->c1\nc1(no)->op2\nc1(yes)->io2->e</textarea><textarea id=\"flowchart-0-options\" style=\"display: none\">{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}</textarea><script>  var code = document.getElementById(\"flowchart-0-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value));  var diagram = flowchart.parse(code);  diagram.drawSVG(\"flowchart-0\", options);</script></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>第一个Hexo-next主题的blog，主要用来记录markdown语法<br></p>","more":"<p></p>\n<h3 id=\"测试文本样式\"><a href=\"#测试文本样式\" class=\"headerlink\" title=\"测试文本样式\"></a>测试文本样式</h3><h4 id=\"测试加粗样式\"><a href=\"#测试加粗样式\" class=\"headerlink\" title=\"测试加粗样式\"></a>测试加粗样式</h4><p><strong>加粗</strong></p>\n<h4 id=\"测试斜体样式\"><a href=\"#测试斜体样式\" class=\"headerlink\" title=\"测试斜体样式\"></a>测试斜体样式</h4><p><em>斜体</em></p>\n<h4 id=\"测试删除线样式\"><a href=\"#测试删除线样式\" class=\"headerlink\" title=\"测试删除线样式\"></a>测试删除线样式</h4><p><del>删除线</del></p>\n<h4 id=\"测试引用样式\"><a href=\"#测试引用样式\" class=\"headerlink\" title=\"测试引用样式\"></a>测试引用样式</h4><blockquote>\n<p>山穷水尽疑无路，柳暗花明又一村</p>\n</blockquote>\n<h3 id=\"测试代码样式\"><a href=\"#测试代码样式\" class=\"headerlink\" title=\"测试代码样式\"></a>测试代码样式</h3><h4 id=\"测试指定代码语言代码样式\"><a href=\"#测试指定代码语言代码样式\" class=\"headerlink\" title=\"测试指定代码语言代码样式\"></a>测试指定代码语言代码样式</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> FE_developer = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'Kuro'</span>,</span><br><span class=\"line\">\tage: <span class=\"string\">'22'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'info'</span>, FE_developer);</span><br></pre></td></tr></table></figure>\n<h4 id=\"测试单行代码样式\"><a href=\"#测试单行代码样式\" class=\"headerlink\" title=\"测试单行代码样式\"></a>测试单行代码样式</h4><p>在JS中我们常用<code>console.log()</code>来输出调试信息。</p>\n<h4 id=\"测试代码块样式\"><a href=\"#测试代码块样式\" class=\"headerlink\" title=\"测试代码块样式\"></a>测试代码块样式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(a, b)&#123;</span><br><span class=\"line\">\tsetTimeout(function()&#123;</span><br><span class=\"line\">\t\tconsole.log(a + b);</span><br><span class=\"line\">\t\tsetTimeout(arguments.callee, 500);</span><br><span class=\"line\">\t\t&#125;, 500)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试连接样式\"><a href=\"#测试连接样式\" class=\"headerlink\" title=\"测试连接样式\"></a>测试连接样式</h3><p>百度一下：<a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"noopener\">Baidu</a></p>\n<h3 id=\"测试首行缩进样式\"><a href=\"#测试首行缩进样式\" class=\"headerlink\" title=\"测试首行缩进样式\"></a>测试首行缩进样式</h3><p>&emsp;&emsp;markdown 语法主要考虑的是英文，中文缩进需要依赖 HTML 的空格符号<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">半角空格: &amp;nbsp;</span><br><span class=\"line\">全角空格：&amp;emsp;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"测试表格样式\"><a href=\"#测试表格样式\" class=\"headerlink\" title=\"测试表格样式\"></a>测试表格样式</h3><table>\n<thead>\n<tr>\n<th>左对齐</th>\n<th style=\"text-align:center\">居中对齐</th>\n<th style=\"text-align:right\">右对齐</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Harry Potter</td>\n<td style=\"text-align:center\">Gryffindor</td>\n<td style=\"text-align:right\">90</td>\n</tr>\n<tr>\n<td>Hermione Granger</td>\n<td style=\"text-align:center\">Gryffindor</td>\n<td style=\"text-align:right\">100</td>\n</tr>\n<tr>\n<td>Draco Malfoy</td>\n<td style=\"text-align:center\">Slytherin</td>\n<td style=\"text-align:right\">90</td>\n</tr>\n</tbody>\n</table>\n<p>表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。<br><strong>注意：表格前若有文本，需要空一行才能正常显示</strong></p>\n<h3 id=\"测试插入图片\"><a href=\"#测试插入图片\" class=\"headerlink\" title=\"测试插入图片\"></a>测试插入图片</h3><p>来自百度图片: <img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1536749860&amp;di=13b529d93aa88d542b4e7d1fece8cd85&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Fpic.90sjimg.com%2Fdesign%2F00%2F89%2F85%2F87%2Fs_1024_58bd1a48a0978.png\" alt=\"夏日西瓜\" title=\"西瓜\"></p>\n<h3 id=\"测试列表\"><a href=\"#测试列表\" class=\"headerlink\" title=\"测试列表\"></a>测试列表</h3><p>git常用语法</p>\n<ul>\n<li>git status</li>\n<li>git add .</li>\n<li>git commit -m”XXX”</li>\n</ul>\n<ul>\n<li>git stash</li>\n<li>git list</li>\n<li>git stash apply stash@{n}</li>\n</ul>\n<ul>\n<li>git diff</li>\n<li>git reset –hard</li>\n</ul>\n<ol>\n<li>列表内容<ul>\n<li>列表嵌套第一条</li>\n<li>列表嵌套第二条</li>\n</ul>\n</li>\n<li>列表内容</li>\n<li>列表内容</li>\n</ol>\n<h3 id=\"测试复选框样式\"><a href=\"#测试复选框样式\" class=\"headerlink\" title=\"测试复选框样式\"></a>测试复选框样式</h3><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> 选项一</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 选项二</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 选项三</li>\n</ul>\n<h3 id=\"测试流程图样式\"><a href=\"#测试流程图样式\" class=\"headerlink\" title=\"测试流程图样式\"></a>测试流程图样式</h3><div id=\"flowchart-0\" class=\"flow-chart\"></div>\n\n<h3 id=\"其他注意事项\"><a href=\"#其他注意事项\" class=\"headerlink\" title=\"其他注意事项\"></a>其他注意事项</h3><ul>\n<li>在 Markdown 中直接使用尖括号<code>&lt;something&gt;</code>会被文本默认为HTML标签语句而不予显示。<ul>\n<li>使用转义字符<code>&amp;lt;</code>代替<code>&lt;</code>，用<code>&amp;gt;</code>代替<code>&gt;</code></li>\n<li>或者右闭合的尖括号前加一个转义符号<code>\\</code>，例如：<code>&lt;something\\&gt;</code><br><script src=\"https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js\"></script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js\"></script><textarea id=\"flowchart-0-code\" style=\"display: none\">st=>start: 开始\ne=>end: 结束\nio1=>inputoutput: 输入聚类类数k\nop1=>operation: 筛选初始质心\nop2=>operation: 计算样本点到各个质心之间的距离\n并将其归到距离其最近的质心所在簇中\nop3=>operation: 计算各簇均值，生成新的质心\nc1=>condition: 新旧质心距离小于阈值\nio2=>inputoutput: 输出聚类结果\n\nst->io1->op1->op2->op3->c1\nc1(no)->op2\nc1(yes)->io2->e</textarea><textarea id=\"flowchart-0-options\" style=\"display: none\">{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}</textarea><script>  var code = document.getElementById(\"flowchart-0-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value));  var diagram = flowchart.parse(code);  diagram.drawSVG(\"flowchart-0\", options);</script></li>\n</ul>\n</li>\n</ul>"},{"title":"PWA-Service Worker 小结（二）实践","date":"2020-01-02T07:15:08.000Z","_content":"Service Worker 的初衷是极致优化用户体验，带来丝滑般流畅的离线应用。但同时也可以用作站点缓存使用。它本身类似于一个介于浏览器和服务端之间的网络代理，可以拦截请求并操作响应内容。功能强大，但由于兼容性问题，更适合用作渐进增强来使用。\n\n<!--more-->\n\n### 一、前言\n* Service Worker 是独立于当前页面的一段运行在浏览器后台进程里的脚本，它有自己独立的注册文件；它是 Web Worker 的一种，不能够直接操作 DOM；\n* 出于安全问题考虑，它只能在 HTTPS 域名下或者 localhost 本地运行；\n* 可以通过 postMessage 接口传递数据给其他 JS 文件；\n* Service Worker 中运行的代码不会被阻塞，也不会阻塞其他页面的 JS 文件中的代码；\n* 每个 Service Worker（注册文件）都有自己的作用域，它只会处理自己作用域下的请求，而 Service Worker 的存放位置就是它的最大作用域；\n* 缓存的资源存储在 Cache Storage 中，缓存不会过期，但是浏览器对每个网站的 Cache Storage 的大小有硬性限制，所以需要清理不必要的缓存；\n\n### 二、Service Worker 的生命周期\n1. 注册 Service worker，在网页上生效；\n2. 安装成功，激活 或者 安装失败（下次加载会尝试重新安装）；\n3. 激活后，在 sw 的作用域下作用所有的页面，首次注册 sw 不会生效，下次加载页面才会生效；已经注册的 sw 不会重复注册；不会因为页面的关闭而被销毁；\n4. sw 作用页面后，处理 fetch（网络请求）和 postMessage（页面消息）事件 或者 被终止（节省内存）。\n\n![](/Service-Worker-Lifecycle.png \"Service Worker Lifecycle\")\n\n### 三、Service Worker 安装注册\n#### 注册文件\n````javascript\n// service worker 注册文件\nif ('serviceWorker' in window.navigator) {\n  navigator.serviceWorker.register('./sw.js', { scope: './' })\n    .then(function (reg) {\n      console.log('success', reg);\n    })\n    .catch(function (err) {\n      console.log('fail', err);\n    });\n\n````\nregister 方法接受两个参数，第一个是 service worker 文件的路径，第二个参数是 Serivce Worker 的配置项，可选填，其中比较重要的是 __scope__ 属性。\n\n#### 拓展 Service Worker 作用域\n\nscope的默认值为 `./`（注意，这里所有的相对路径不是相对于页面，而是相对于sw.js脚本的），因此，`navigator.serviceWorker.register('/static/home/js/sw.js')`代码中的 scope 实际上是`/static/home/js`，Service Worker也就注册在了`/static/home/js`路径下，显然无法在`/home`下生效。\n\n可以通过添加 `Service-Worker-Allowed` 响应头的方式来扩展 service worker 的作用域：\n````javascript\n// express 扩展 service worker scope\napp.use(serveStatic(`${sourceRoot}/home`, {\n    maxAge: 0,\n    setHeaders: function (res, path, stat) {\n        if (/\\/sw\\/.+\\.js/.test(path)) {\n            res.set({\n                'Content-Type': 'application/javascript',\n                'Service-Worker-Allowed': `/${sourceRoot}//home`,\n                'Cache-control': 'no-store'\n            });\n        }\n    }\n}));\n\n````\n\n#### 打包工具生成静态资源注册文件\n\n自己本地调试，可以一个个写进 Service Worker 的注册文件里调试；实际开发中可以借助 gulp / webpack 等打包工具等生成站点静态文件的 sw 注册文件；\n以 gulp 为例，使用 [`sw-precache`](https://github.com/GoogleChromeLabs/sw-precache) 插件生成注册文件：\n````javascript\ngulp.task('generate-service-worker', function(callback) {\n\n    swPrecache.write('./service-worker.js', {\n        staticFileGlobs: ['./build/public' + '/**/*.{js,css,png,jpg,webp,gif,svg,eot,ttf,woff}'],\n        stripPrefix: './build'\n    }, callback);\n\n});\n````\n\n### 四、Service Worker.js 注意事项\n1. __不要给 service-worker.js 设置不同的名字__\n实际开发过程中，为了避免静态资源缓存，通常的做法是在打包压缩静态资源的时候，在文件名后边加上 MD5 后缀，让浏览器认为这是一个新文件从而重新发起请求，但是这种做法在 service-worker.js 上是不可取的；\n第一种情况：如果缓存了 html 文件，service-worker.js 的文件因为是在 html 中引入的，所以更改 service-worker.js 的名字并不会更新。\n第二种情况：只缓存了css，js 文件，未缓存 html 文件；页面引入了新的 service-worker.js ，但是旧版本的 service-worker.js 还在使用中，会导致页面状态有问题。\n2. __不要给 service-worker.js 设置缓存__\n理由和第一点类似，也是为了防止在浏览器需要请求新版本的 sw 时，因为缓存的干扰而无法实现。毕竟我们不能要求用户去清除缓存。因此给 sw 及相关的 JS (例如 sw-register.js，如果独立出来的话)设置 Cache-control: no-store 是比较安全的。\n\n### 五、遇到的问题\n1. __接收不到浏览器的fetch事件：__\n原因：静态资源缓存：页面路径不能大于 Service worker 的 scope ([详情](https://juejin.im/post/5b06a7b3f265da0dd8567513#heading-8))\n2. __`public/*` 无法匹配public路径下的所有文件， addCaches 时只能写fileName？__\n原因：service worker 没有通配符 * 这个概念，`/sw-test/` 这个 path 只是让 sw 寻找缓存时的一个入口，用以区分各个路径的缓存（[详情](https://stackoverflow.com/questions/46830493/is-there-any-way-to-cache-all-files-of-defined-folder-path-in-service-worker)）；\n解决方案：service-worker.js 使用官方的 `sw-precache` 插件生成（[详情](https://stackoverflow.com/questions/46208326/for-serviceworker-cache-addall-how-do-the-urls-work/46213137#46213137)）；\n3. __如果 service worker 缓存的了全部的js和img 会不会导致 cacheStorage 很占用用户的系统空间？__\n不会，各个浏览器分配给各站点的 cacheStorrage 的值不一样，同时也受用户设备空间影响。\n\n### 落地情况\n个人觉得 Service Worker 更适合在单页应用、文档类应用的等场景使用，才能把离线缓存的优势发挥出来。比如 [Vue](https://cn.vuejs.org/) 的官网。<hr/>\n*2019.4.23*\n未落地。主要原因有两点： \n1. 工作中想要使用 Service worker 提供离线缓存服务的是一个负责 APP 内嵌页面的 H5 站点，HTML都是动态渲染的，活动数据是实时的，不能离线访问；\n2. 这个站点的页面入口都是几乎都是单独的活动页，没有一个统一 sw 注册的入口；\n\n<hr/>\n*2020.3.16*\n重新看这篇文章的时候，如果在几个主要的活动入口页引入 sw 的注册文件，那么这几个长期的活动就可以应用 sw 缓存了，但这并没有覆盖全站，所以依然不是好的解决方案。\n\n### 应用场景\n这部分总结摘录自这篇文章：[Service Worker 从入门到出门](https://juejin.im/post/5d26aec1f265da1ba56b47ea#heading-6)\n\n* 网站功能趋于稳定：频繁迭代的网站似乎不方便加 Service Worker。\n* 网站需要拥有大量用户：管理后台、OA系统等场景似乎不是很有必要加 Service Worker。\n* 网站真的在追求用户体验：Bug 多多、脸不好看的网站似乎不是很有必要加 Service Worker。\n* 网站用户体验关乎用户留存：12306 似乎完全不需要加 Service Worker。\n  \n简单总结：Service Worker 的初衷是极致优化用户体验，是用来锦上添花的，技术只是技术，但实际应用前，应考虑成本和收益。\n\n### 参考链接\n* [Service Worker ——这应该是一个挺全面的整理](https://juejin.im/post/5b06a7b3f265da0dd8567513#heading-1)\n* [【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案](https://www.jianshu.com/p/7eae75f46467)\n* [谨慎处理 Service Worker 的更新](https://zhuanlan.zhihu.com/p/51118741)\n* [使用 Service Worker 做一个 PWA 离线网页应用](https://www.sohu.com/a/197477344_463987)","source":"_posts/PWA-Service-Worker-小结（二）实践.md","raw":"---\ntitle: PWA-Service Worker 小结（二）实践\ndate: 2020-01-02 15:15:08\ntags: [Service Worker]\ncategories: [前端, PWA]\n---\nService Worker 的初衷是极致优化用户体验，带来丝滑般流畅的离线应用。但同时也可以用作站点缓存使用。它本身类似于一个介于浏览器和服务端之间的网络代理，可以拦截请求并操作响应内容。功能强大，但由于兼容性问题，更适合用作渐进增强来使用。\n\n<!--more-->\n\n### 一、前言\n* Service Worker 是独立于当前页面的一段运行在浏览器后台进程里的脚本，它有自己独立的注册文件；它是 Web Worker 的一种，不能够直接操作 DOM；\n* 出于安全问题考虑，它只能在 HTTPS 域名下或者 localhost 本地运行；\n* 可以通过 postMessage 接口传递数据给其他 JS 文件；\n* Service Worker 中运行的代码不会被阻塞，也不会阻塞其他页面的 JS 文件中的代码；\n* 每个 Service Worker（注册文件）都有自己的作用域，它只会处理自己作用域下的请求，而 Service Worker 的存放位置就是它的最大作用域；\n* 缓存的资源存储在 Cache Storage 中，缓存不会过期，但是浏览器对每个网站的 Cache Storage 的大小有硬性限制，所以需要清理不必要的缓存；\n\n### 二、Service Worker 的生命周期\n1. 注册 Service worker，在网页上生效；\n2. 安装成功，激活 或者 安装失败（下次加载会尝试重新安装）；\n3. 激活后，在 sw 的作用域下作用所有的页面，首次注册 sw 不会生效，下次加载页面才会生效；已经注册的 sw 不会重复注册；不会因为页面的关闭而被销毁；\n4. sw 作用页面后，处理 fetch（网络请求）和 postMessage（页面消息）事件 或者 被终止（节省内存）。\n\n![](/Service-Worker-Lifecycle.png \"Service Worker Lifecycle\")\n\n### 三、Service Worker 安装注册\n#### 注册文件\n````javascript\n// service worker 注册文件\nif ('serviceWorker' in window.navigator) {\n  navigator.serviceWorker.register('./sw.js', { scope: './' })\n    .then(function (reg) {\n      console.log('success', reg);\n    })\n    .catch(function (err) {\n      console.log('fail', err);\n    });\n\n````\nregister 方法接受两个参数，第一个是 service worker 文件的路径，第二个参数是 Serivce Worker 的配置项，可选填，其中比较重要的是 __scope__ 属性。\n\n#### 拓展 Service Worker 作用域\n\nscope的默认值为 `./`（注意，这里所有的相对路径不是相对于页面，而是相对于sw.js脚本的），因此，`navigator.serviceWorker.register('/static/home/js/sw.js')`代码中的 scope 实际上是`/static/home/js`，Service Worker也就注册在了`/static/home/js`路径下，显然无法在`/home`下生效。\n\n可以通过添加 `Service-Worker-Allowed` 响应头的方式来扩展 service worker 的作用域：\n````javascript\n// express 扩展 service worker scope\napp.use(serveStatic(`${sourceRoot}/home`, {\n    maxAge: 0,\n    setHeaders: function (res, path, stat) {\n        if (/\\/sw\\/.+\\.js/.test(path)) {\n            res.set({\n                'Content-Type': 'application/javascript',\n                'Service-Worker-Allowed': `/${sourceRoot}//home`,\n                'Cache-control': 'no-store'\n            });\n        }\n    }\n}));\n\n````\n\n#### 打包工具生成静态资源注册文件\n\n自己本地调试，可以一个个写进 Service Worker 的注册文件里调试；实际开发中可以借助 gulp / webpack 等打包工具等生成站点静态文件的 sw 注册文件；\n以 gulp 为例，使用 [`sw-precache`](https://github.com/GoogleChromeLabs/sw-precache) 插件生成注册文件：\n````javascript\ngulp.task('generate-service-worker', function(callback) {\n\n    swPrecache.write('./service-worker.js', {\n        staticFileGlobs: ['./build/public' + '/**/*.{js,css,png,jpg,webp,gif,svg,eot,ttf,woff}'],\n        stripPrefix: './build'\n    }, callback);\n\n});\n````\n\n### 四、Service Worker.js 注意事项\n1. __不要给 service-worker.js 设置不同的名字__\n实际开发过程中，为了避免静态资源缓存，通常的做法是在打包压缩静态资源的时候，在文件名后边加上 MD5 后缀，让浏览器认为这是一个新文件从而重新发起请求，但是这种做法在 service-worker.js 上是不可取的；\n第一种情况：如果缓存了 html 文件，service-worker.js 的文件因为是在 html 中引入的，所以更改 service-worker.js 的名字并不会更新。\n第二种情况：只缓存了css，js 文件，未缓存 html 文件；页面引入了新的 service-worker.js ，但是旧版本的 service-worker.js 还在使用中，会导致页面状态有问题。\n2. __不要给 service-worker.js 设置缓存__\n理由和第一点类似，也是为了防止在浏览器需要请求新版本的 sw 时，因为缓存的干扰而无法实现。毕竟我们不能要求用户去清除缓存。因此给 sw 及相关的 JS (例如 sw-register.js，如果独立出来的话)设置 Cache-control: no-store 是比较安全的。\n\n### 五、遇到的问题\n1. __接收不到浏览器的fetch事件：__\n原因：静态资源缓存：页面路径不能大于 Service worker 的 scope ([详情](https://juejin.im/post/5b06a7b3f265da0dd8567513#heading-8))\n2. __`public/*` 无法匹配public路径下的所有文件， addCaches 时只能写fileName？__\n原因：service worker 没有通配符 * 这个概念，`/sw-test/` 这个 path 只是让 sw 寻找缓存时的一个入口，用以区分各个路径的缓存（[详情](https://stackoverflow.com/questions/46830493/is-there-any-way-to-cache-all-files-of-defined-folder-path-in-service-worker)）；\n解决方案：service-worker.js 使用官方的 `sw-precache` 插件生成（[详情](https://stackoverflow.com/questions/46208326/for-serviceworker-cache-addall-how-do-the-urls-work/46213137#46213137)）；\n3. __如果 service worker 缓存的了全部的js和img 会不会导致 cacheStorage 很占用用户的系统空间？__\n不会，各个浏览器分配给各站点的 cacheStorrage 的值不一样，同时也受用户设备空间影响。\n\n### 落地情况\n个人觉得 Service Worker 更适合在单页应用、文档类应用的等场景使用，才能把离线缓存的优势发挥出来。比如 [Vue](https://cn.vuejs.org/) 的官网。<hr/>\n*2019.4.23*\n未落地。主要原因有两点： \n1. 工作中想要使用 Service worker 提供离线缓存服务的是一个负责 APP 内嵌页面的 H5 站点，HTML都是动态渲染的，活动数据是实时的，不能离线访问；\n2. 这个站点的页面入口都是几乎都是单独的活动页，没有一个统一 sw 注册的入口；\n\n<hr/>\n*2020.3.16*\n重新看这篇文章的时候，如果在几个主要的活动入口页引入 sw 的注册文件，那么这几个长期的活动就可以应用 sw 缓存了，但这并没有覆盖全站，所以依然不是好的解决方案。\n\n### 应用场景\n这部分总结摘录自这篇文章：[Service Worker 从入门到出门](https://juejin.im/post/5d26aec1f265da1ba56b47ea#heading-6)\n\n* 网站功能趋于稳定：频繁迭代的网站似乎不方便加 Service Worker。\n* 网站需要拥有大量用户：管理后台、OA系统等场景似乎不是很有必要加 Service Worker。\n* 网站真的在追求用户体验：Bug 多多、脸不好看的网站似乎不是很有必要加 Service Worker。\n* 网站用户体验关乎用户留存：12306 似乎完全不需要加 Service Worker。\n  \n简单总结：Service Worker 的初衷是极致优化用户体验，是用来锦上添花的，技术只是技术，但实际应用前，应考虑成本和收益。\n\n### 参考链接\n* [Service Worker ——这应该是一个挺全面的整理](https://juejin.im/post/5b06a7b3f265da0dd8567513#heading-1)\n* [【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案](https://www.jianshu.com/p/7eae75f46467)\n* [谨慎处理 Service Worker 的更新](https://zhuanlan.zhihu.com/p/51118741)\n* [使用 Service Worker 做一个 PWA 离线网页应用](https://www.sohu.com/a/197477344_463987)","slug":"PWA-Service-Worker-小结（二）实践","published":1,"updated":"2020-11-04T08:29:30.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0n000f7vvuel4i9vjy","content":"<p>Service Worker 的初衷是极致优化用户体验，带来丝滑般流畅的离线应用。但同时也可以用作站点缓存使用。它本身类似于一个介于浏览器和服务端之间的网络代理，可以拦截请求并操作响应内容。功能强大，但由于兼容性问题，更适合用作渐进增强来使用。</p>\n<a id=\"more\"></a>\n<h3 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h3><ul>\n<li>Service Worker 是独立于当前页面的一段运行在浏览器后台进程里的脚本，它有自己独立的注册文件；它是 Web Worker 的一种，不能够直接操作 DOM；</li>\n<li>出于安全问题考虑，它只能在 HTTPS 域名下或者 localhost 本地运行；</li>\n<li>可以通过 postMessage 接口传递数据给其他 JS 文件；</li>\n<li>Service Worker 中运行的代码不会被阻塞，也不会阻塞其他页面的 JS 文件中的代码；</li>\n<li>每个 Service Worker（注册文件）都有自己的作用域，它只会处理自己作用域下的请求，而 Service Worker 的存放位置就是它的最大作用域；</li>\n<li>缓存的资源存储在 Cache Storage 中，缓存不会过期，但是浏览器对每个网站的 Cache Storage 的大小有硬性限制，所以需要清理不必要的缓存；</li>\n</ul>\n<h3 id=\"二、Service-Worker-的生命周期\"><a href=\"#二、Service-Worker-的生命周期\" class=\"headerlink\" title=\"二、Service Worker 的生命周期\"></a>二、Service Worker 的生命周期</h3><ol>\n<li>注册 Service worker，在网页上生效；</li>\n<li>安装成功，激活 或者 安装失败（下次加载会尝试重新安装）；</li>\n<li>激活后，在 sw 的作用域下作用所有的页面，首次注册 sw 不会生效，下次加载页面才会生效；已经注册的 sw 不会重复注册；不会因为页面的关闭而被销毁；</li>\n<li>sw 作用页面后，处理 fetch（网络请求）和 postMessage（页面消息）事件 或者 被终止（节省内存）。</li>\n</ol>\n<p><img src=\"/2020/01/02/PWA-Service-Worker-小结（二）实践/Service-Worker-Lifecycle.png\" alt=\"\" title=\"Service Worker Lifecycle\"></p>\n<h3 id=\"三、Service-Worker-安装注册\"><a href=\"#三、Service-Worker-安装注册\" class=\"headerlink\" title=\"三、Service Worker 安装注册\"></a>三、Service Worker 安装注册</h3><h4 id=\"注册文件\"><a href=\"#注册文件\" class=\"headerlink\" title=\"注册文件\"></a>注册文件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// service worker 注册文件</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>.navigator) &#123;</span><br><span class=\"line\">  navigator.serviceWorker.register(<span class=\"string\">'./sw.js'</span>, &#123; <span class=\"attr\">scope</span>: <span class=\"string\">'./'</span> &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reg</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'success'</span>, reg);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'fail'</span>, err);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>register 方法接受两个参数，第一个是 service worker 文件的路径，第二个参数是 Serivce Worker 的配置项，可选填，其中比较重要的是 <strong>scope</strong> 属性。</p>\n<h4 id=\"拓展-Service-Worker-作用域\"><a href=\"#拓展-Service-Worker-作用域\" class=\"headerlink\" title=\"拓展 Service Worker 作用域\"></a>拓展 Service Worker 作用域</h4><p>scope的默认值为 <code>./</code>（注意，这里所有的相对路径不是相对于页面，而是相对于sw.js脚本的），因此，<code>navigator.serviceWorker.register(&#39;/static/home/js/sw.js&#39;)</code>代码中的 scope 实际上是<code>/static/home/js</code>，Service Worker也就注册在了<code>/static/home/js</code>路径下，显然无法在<code>/home</code>下生效。</p>\n<p>可以通过添加 <code>Service-Worker-Allowed</code> 响应头的方式来扩展 service worker 的作用域：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// express 扩展 service worker scope</span></span><br><span class=\"line\">app.use(serveStatic(<span class=\"string\">`<span class=\"subst\">$&#123;sourceRoot&#125;</span>/home`</span>, &#123;</span><br><span class=\"line\">    maxAge: <span class=\"number\">0</span>,</span><br><span class=\"line\">    setHeaders: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res, path, stat</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"regexp\">/\\/sw\\/.+\\.js/</span>.test(path)) &#123;</span><br><span class=\"line\">            res.set(&#123;</span><br><span class=\"line\">                <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/javascript'</span>,</span><br><span class=\"line\">                <span class=\"string\">'Service-Worker-Allowed'</span>: <span class=\"string\">`/<span class=\"subst\">$&#123;sourceRoot&#125;</span>//home`</span>,</span><br><span class=\"line\">                <span class=\"string\">'Cache-control'</span>: <span class=\"string\">'no-store'</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"打包工具生成静态资源注册文件\"><a href=\"#打包工具生成静态资源注册文件\" class=\"headerlink\" title=\"打包工具生成静态资源注册文件\"></a>打包工具生成静态资源注册文件</h4><p>自己本地调试，可以一个个写进 Service Worker 的注册文件里调试；实际开发中可以借助 gulp / webpack 等打包工具等生成站点静态文件的 sw 注册文件；<br>以 gulp 为例，使用 <a href=\"https://github.com/GoogleChromeLabs/sw-precache\" target=\"_blank\" rel=\"noopener\"><code>sw-precache</code></a> 插件生成注册文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'generate-service-worker'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    swPrecache.write(<span class=\"string\">'./service-worker.js'</span>, &#123;</span><br><span class=\"line\">        staticFileGlobs: [<span class=\"string\">'./build/public'</span> + <span class=\"string\">'/**/*.&#123;js,css,png,jpg,webp,gif,svg,eot,ttf,woff&#125;'</span>],</span><br><span class=\"line\">        stripPrefix: <span class=\"string\">'./build'</span></span><br><span class=\"line\">    &#125;, callback);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"四、Service-Worker-js-注意事项\"><a href=\"#四、Service-Worker-js-注意事项\" class=\"headerlink\" title=\"四、Service Worker.js 注意事项\"></a>四、Service Worker.js 注意事项</h3><ol>\n<li><strong>不要给 service-worker.js 设置不同的名字</strong><br>实际开发过程中，为了避免静态资源缓存，通常的做法是在打包压缩静态资源的时候，在文件名后边加上 MD5 后缀，让浏览器认为这是一个新文件从而重新发起请求，但是这种做法在 service-worker.js 上是不可取的；<br>第一种情况：如果缓存了 html 文件，service-worker.js 的文件因为是在 html 中引入的，所以更改 service-worker.js 的名字并不会更新。<br>第二种情况：只缓存了css，js 文件，未缓存 html 文件；页面引入了新的 service-worker.js ，但是旧版本的 service-worker.js 还在使用中，会导致页面状态有问题。</li>\n<li><strong>不要给 service-worker.js 设置缓存</strong><br>理由和第一点类似，也是为了防止在浏览器需要请求新版本的 sw 时，因为缓存的干扰而无法实现。毕竟我们不能要求用户去清除缓存。因此给 sw 及相关的 JS (例如 sw-register.js，如果独立出来的话)设置 Cache-control: no-store 是比较安全的。</li>\n</ol>\n<h3 id=\"五、遇到的问题\"><a href=\"#五、遇到的问题\" class=\"headerlink\" title=\"五、遇到的问题\"></a>五、遇到的问题</h3><ol>\n<li><strong>接收不到浏览器的fetch事件：</strong><br>原因：静态资源缓存：页面路径不能大于 Service worker 的 scope (<a href=\"https://juejin.im/post/5b06a7b3f265da0dd8567513#heading-8\" target=\"_blank\" rel=\"noopener\">详情</a>)</li>\n<li><strong><code>public/*</code> 无法匹配public路径下的所有文件， addCaches 时只能写fileName？</strong><br>原因：service worker 没有通配符 * 这个概念，<code>/sw-test/</code> 这个 path 只是让 sw 寻找缓存时的一个入口，用以区分各个路径的缓存（<a href=\"https://stackoverflow.com/questions/46830493/is-there-any-way-to-cache-all-files-of-defined-folder-path-in-service-worker\" target=\"_blank\" rel=\"noopener\">详情</a>）；<br>解决方案：service-worker.js 使用官方的 <code>sw-precache</code> 插件生成（<a href=\"https://stackoverflow.com/questions/46208326/for-serviceworker-cache-addall-how-do-the-urls-work/46213137#46213137\" target=\"_blank\" rel=\"noopener\">详情</a>）；</li>\n<li><strong>如果 service worker 缓存的了全部的js和img 会不会导致 cacheStorage 很占用用户的系统空间？</strong><br>不会，各个浏览器分配给各站点的 cacheStorrage 的值不一样，同时也受用户设备空间影响。</li>\n</ol>\n<h3 id=\"落地情况\"><a href=\"#落地情况\" class=\"headerlink\" title=\"落地情况\"></a>落地情况</h3><p>个人觉得 Service Worker 更适合在单页应用、文档类应用的等场景使用，才能把离线缓存的优势发挥出来。比如 <a href=\"https://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Vue</a> 的官网。<hr><br><em>2019.4.23</em><br>未落地。主要原因有两点： </p>\n<ol>\n<li>工作中想要使用 Service worker 提供离线缓存服务的是一个负责 APP 内嵌页面的 H5 站点，HTML都是动态渲染的，活动数据是实时的，不能离线访问；</li>\n<li>这个站点的页面入口都是几乎都是单独的活动页，没有一个统一 sw 注册的入口；</li>\n</ol>\n<p><hr><br><em>2020.3.16</em><br>重新看这篇文章的时候，如果在几个主要的活动入口页引入 sw 的注册文件，那么这几个长期的活动就可以应用 sw 缓存了，但这并没有覆盖全站，所以依然不是好的解决方案。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>这部分总结摘录自这篇文章：<a href=\"https://juejin.im/post/5d26aec1f265da1ba56b47ea#heading-6\" target=\"_blank\" rel=\"noopener\">Service Worker 从入门到出门</a></p>\n<ul>\n<li>网站功能趋于稳定：频繁迭代的网站似乎不方便加 Service Worker。</li>\n<li>网站需要拥有大量用户：管理后台、OA系统等场景似乎不是很有必要加 Service Worker。</li>\n<li>网站真的在追求用户体验：Bug 多多、脸不好看的网站似乎不是很有必要加 Service Worker。</li>\n<li>网站用户体验关乎用户留存：12306 似乎完全不需要加 Service Worker。</li>\n</ul>\n<p>简单总结：Service Worker 的初衷是极致优化用户体验，是用来锦上添花的，技术只是技术，但实际应用前，应考虑成本和收益。</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><ul>\n<li><a href=\"https://juejin.im/post/5b06a7b3f265da0dd8567513#heading-1\" target=\"_blank\" rel=\"noopener\">Service Worker ——这应该是一个挺全面的整理</a></li>\n<li><a href=\"https://www.jianshu.com/p/7eae75f46467\" target=\"_blank\" rel=\"noopener\">【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/51118741\" target=\"_blank\" rel=\"noopener\">谨慎处理 Service Worker 的更新</a></li>\n<li><a href=\"https://www.sohu.com/a/197477344_463987\" target=\"_blank\" rel=\"noopener\">使用 Service Worker 做一个 PWA 离线网页应用</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Service Worker 的初衷是极致优化用户体验，带来丝滑般流畅的离线应用。但同时也可以用作站点缓存使用。它本身类似于一个介于浏览器和服务端之间的网络代理，可以拦截请求并操作响应内容。功能强大，但由于兼容性问题，更适合用作渐进增强来使用。</p>","more":"<h3 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h3><ul>\n<li>Service Worker 是独立于当前页面的一段运行在浏览器后台进程里的脚本，它有自己独立的注册文件；它是 Web Worker 的一种，不能够直接操作 DOM；</li>\n<li>出于安全问题考虑，它只能在 HTTPS 域名下或者 localhost 本地运行；</li>\n<li>可以通过 postMessage 接口传递数据给其他 JS 文件；</li>\n<li>Service Worker 中运行的代码不会被阻塞，也不会阻塞其他页面的 JS 文件中的代码；</li>\n<li>每个 Service Worker（注册文件）都有自己的作用域，它只会处理自己作用域下的请求，而 Service Worker 的存放位置就是它的最大作用域；</li>\n<li>缓存的资源存储在 Cache Storage 中，缓存不会过期，但是浏览器对每个网站的 Cache Storage 的大小有硬性限制，所以需要清理不必要的缓存；</li>\n</ul>\n<h3 id=\"二、Service-Worker-的生命周期\"><a href=\"#二、Service-Worker-的生命周期\" class=\"headerlink\" title=\"二、Service Worker 的生命周期\"></a>二、Service Worker 的生命周期</h3><ol>\n<li>注册 Service worker，在网页上生效；</li>\n<li>安装成功，激活 或者 安装失败（下次加载会尝试重新安装）；</li>\n<li>激活后，在 sw 的作用域下作用所有的页面，首次注册 sw 不会生效，下次加载页面才会生效；已经注册的 sw 不会重复注册；不会因为页面的关闭而被销毁；</li>\n<li>sw 作用页面后，处理 fetch（网络请求）和 postMessage（页面消息）事件 或者 被终止（节省内存）。</li>\n</ol>\n<p><img src=\"/2020/01/02/PWA-Service-Worker-小结（二）实践/Service-Worker-Lifecycle.png\" alt=\"\" title=\"Service Worker Lifecycle\"></p>\n<h3 id=\"三、Service-Worker-安装注册\"><a href=\"#三、Service-Worker-安装注册\" class=\"headerlink\" title=\"三、Service Worker 安装注册\"></a>三、Service Worker 安装注册</h3><h4 id=\"注册文件\"><a href=\"#注册文件\" class=\"headerlink\" title=\"注册文件\"></a>注册文件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// service worker 注册文件</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>.navigator) &#123;</span><br><span class=\"line\">  navigator.serviceWorker.register(<span class=\"string\">'./sw.js'</span>, &#123; <span class=\"attr\">scope</span>: <span class=\"string\">'./'</span> &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">reg</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'success'</span>, reg);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'fail'</span>, err);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>register 方法接受两个参数，第一个是 service worker 文件的路径，第二个参数是 Serivce Worker 的配置项，可选填，其中比较重要的是 <strong>scope</strong> 属性。</p>\n<h4 id=\"拓展-Service-Worker-作用域\"><a href=\"#拓展-Service-Worker-作用域\" class=\"headerlink\" title=\"拓展 Service Worker 作用域\"></a>拓展 Service Worker 作用域</h4><p>scope的默认值为 <code>./</code>（注意，这里所有的相对路径不是相对于页面，而是相对于sw.js脚本的），因此，<code>navigator.serviceWorker.register(&#39;/static/home/js/sw.js&#39;)</code>代码中的 scope 实际上是<code>/static/home/js</code>，Service Worker也就注册在了<code>/static/home/js</code>路径下，显然无法在<code>/home</code>下生效。</p>\n<p>可以通过添加 <code>Service-Worker-Allowed</code> 响应头的方式来扩展 service worker 的作用域：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// express 扩展 service worker scope</span></span><br><span class=\"line\">app.use(serveStatic(<span class=\"string\">`<span class=\"subst\">$&#123;sourceRoot&#125;</span>/home`</span>, &#123;</span><br><span class=\"line\">    maxAge: <span class=\"number\">0</span>,</span><br><span class=\"line\">    setHeaders: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res, path, stat</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"regexp\">/\\/sw\\/.+\\.js/</span>.test(path)) &#123;</span><br><span class=\"line\">            res.set(&#123;</span><br><span class=\"line\">                <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/javascript'</span>,</span><br><span class=\"line\">                <span class=\"string\">'Service-Worker-Allowed'</span>: <span class=\"string\">`/<span class=\"subst\">$&#123;sourceRoot&#125;</span>//home`</span>,</span><br><span class=\"line\">                <span class=\"string\">'Cache-control'</span>: <span class=\"string\">'no-store'</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"打包工具生成静态资源注册文件\"><a href=\"#打包工具生成静态资源注册文件\" class=\"headerlink\" title=\"打包工具生成静态资源注册文件\"></a>打包工具生成静态资源注册文件</h4><p>自己本地调试，可以一个个写进 Service Worker 的注册文件里调试；实际开发中可以借助 gulp / webpack 等打包工具等生成站点静态文件的 sw 注册文件；<br>以 gulp 为例，使用 <a href=\"https://github.com/GoogleChromeLabs/sw-precache\" target=\"_blank\" rel=\"noopener\"><code>sw-precache</code></a> 插件生成注册文件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'generate-service-worker'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    swPrecache.write(<span class=\"string\">'./service-worker.js'</span>, &#123;</span><br><span class=\"line\">        staticFileGlobs: [<span class=\"string\">'./build/public'</span> + <span class=\"string\">'/**/*.&#123;js,css,png,jpg,webp,gif,svg,eot,ttf,woff&#125;'</span>],</span><br><span class=\"line\">        stripPrefix: <span class=\"string\">'./build'</span></span><br><span class=\"line\">    &#125;, callback);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"四、Service-Worker-js-注意事项\"><a href=\"#四、Service-Worker-js-注意事项\" class=\"headerlink\" title=\"四、Service Worker.js 注意事项\"></a>四、Service Worker.js 注意事项</h3><ol>\n<li><strong>不要给 service-worker.js 设置不同的名字</strong><br>实际开发过程中，为了避免静态资源缓存，通常的做法是在打包压缩静态资源的时候，在文件名后边加上 MD5 后缀，让浏览器认为这是一个新文件从而重新发起请求，但是这种做法在 service-worker.js 上是不可取的；<br>第一种情况：如果缓存了 html 文件，service-worker.js 的文件因为是在 html 中引入的，所以更改 service-worker.js 的名字并不会更新。<br>第二种情况：只缓存了css，js 文件，未缓存 html 文件；页面引入了新的 service-worker.js ，但是旧版本的 service-worker.js 还在使用中，会导致页面状态有问题。</li>\n<li><strong>不要给 service-worker.js 设置缓存</strong><br>理由和第一点类似，也是为了防止在浏览器需要请求新版本的 sw 时，因为缓存的干扰而无法实现。毕竟我们不能要求用户去清除缓存。因此给 sw 及相关的 JS (例如 sw-register.js，如果独立出来的话)设置 Cache-control: no-store 是比较安全的。</li>\n</ol>\n<h3 id=\"五、遇到的问题\"><a href=\"#五、遇到的问题\" class=\"headerlink\" title=\"五、遇到的问题\"></a>五、遇到的问题</h3><ol>\n<li><strong>接收不到浏览器的fetch事件：</strong><br>原因：静态资源缓存：页面路径不能大于 Service worker 的 scope (<a href=\"https://juejin.im/post/5b06a7b3f265da0dd8567513#heading-8\" target=\"_blank\" rel=\"noopener\">详情</a>)</li>\n<li><strong><code>public/*</code> 无法匹配public路径下的所有文件， addCaches 时只能写fileName？</strong><br>原因：service worker 没有通配符 * 这个概念，<code>/sw-test/</code> 这个 path 只是让 sw 寻找缓存时的一个入口，用以区分各个路径的缓存（<a href=\"https://stackoverflow.com/questions/46830493/is-there-any-way-to-cache-all-files-of-defined-folder-path-in-service-worker\" target=\"_blank\" rel=\"noopener\">详情</a>）；<br>解决方案：service-worker.js 使用官方的 <code>sw-precache</code> 插件生成（<a href=\"https://stackoverflow.com/questions/46208326/for-serviceworker-cache-addall-how-do-the-urls-work/46213137#46213137\" target=\"_blank\" rel=\"noopener\">详情</a>）；</li>\n<li><strong>如果 service worker 缓存的了全部的js和img 会不会导致 cacheStorage 很占用用户的系统空间？</strong><br>不会，各个浏览器分配给各站点的 cacheStorrage 的值不一样，同时也受用户设备空间影响。</li>\n</ol>\n<h3 id=\"落地情况\"><a href=\"#落地情况\" class=\"headerlink\" title=\"落地情况\"></a>落地情况</h3><p>个人觉得 Service Worker 更适合在单页应用、文档类应用的等场景使用，才能把离线缓存的优势发挥出来。比如 <a href=\"https://cn.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Vue</a> 的官网。<hr><br><em>2019.4.23</em><br>未落地。主要原因有两点： </p>\n<ol>\n<li>工作中想要使用 Service worker 提供离线缓存服务的是一个负责 APP 内嵌页面的 H5 站点，HTML都是动态渲染的，活动数据是实时的，不能离线访问；</li>\n<li>这个站点的页面入口都是几乎都是单独的活动页，没有一个统一 sw 注册的入口；</li>\n</ol>\n<p><hr><br><em>2020.3.16</em><br>重新看这篇文章的时候，如果在几个主要的活动入口页引入 sw 的注册文件，那么这几个长期的活动就可以应用 sw 缓存了，但这并没有覆盖全站，所以依然不是好的解决方案。</p>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>这部分总结摘录自这篇文章：<a href=\"https://juejin.im/post/5d26aec1f265da1ba56b47ea#heading-6\" target=\"_blank\" rel=\"noopener\">Service Worker 从入门到出门</a></p>\n<ul>\n<li>网站功能趋于稳定：频繁迭代的网站似乎不方便加 Service Worker。</li>\n<li>网站需要拥有大量用户：管理后台、OA系统等场景似乎不是很有必要加 Service Worker。</li>\n<li>网站真的在追求用户体验：Bug 多多、脸不好看的网站似乎不是很有必要加 Service Worker。</li>\n<li>网站用户体验关乎用户留存：12306 似乎完全不需要加 Service Worker。</li>\n</ul>\n<p>简单总结：Service Worker 的初衷是极致优化用户体验，是用来锦上添花的，技术只是技术，但实际应用前，应考虑成本和收益。</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><ul>\n<li><a href=\"https://juejin.im/post/5b06a7b3f265da0dd8567513#heading-1\" target=\"_blank\" rel=\"noopener\">Service Worker ——这应该是一个挺全面的整理</a></li>\n<li><a href=\"https://www.jianshu.com/p/7eae75f46467\" target=\"_blank\" rel=\"noopener\">【PWA学习与实践】(9)生产环境中PWA实践的问题与解决方案</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/51118741\" target=\"_blank\" rel=\"noopener\">谨慎处理 Service Worker 的更新</a></li>\n<li><a href=\"https://www.sohu.com/a/197477344_463987\" target=\"_blank\" rel=\"noopener\">使用 Service Worker 做一个 PWA 离线网页应用</a></li>\n</ul>"},{"title":"Prometheus 监控应用性能","date":"2019-07-15T02:21:58.000Z","_content":"&emsp;&emsp; Prometheus 是一个开源的监控系统。它可以自动化的监听应用各性能指标的变化情况，并发出报警信息。了解它目的，是想把前端页面的性能指标记录到公司的 Prometheus 监控系统上，利用它监听前端页面各类异常。\n<!--more-->\n### 一、Prometheus 系统简介\n[Prometheus](https://prometheus.io/) 是一个开源的服务监控系统，社区资源和开发者都很活跃。其主要原理是通过 HTTP 协议从远程的机器收集数据并存储在本地的[时序数据库](https://www.cnblogs.com/aiandbigdata/p/10052335.html)上。Prometheus 通过安装在远程机器上的 exporter (数据暴露)插件来收集监控数据。\n\n#### Prometheus 特点\nPrometheus 本身也是一个时序数据库，它通过 HTTP 的方式获取时序数据。Prometheus 自身的查询语言 PromQL 可多维度的查询并实时计算指标的值。通过 PromQL 提供的计算方法，可以自定义数据可视化的指标，以及报警临界值。它有四种数据类型，可针对不同场景使用不同数据类型。\n\n#### Prometheus 系统的组成部分\n![](/architecture.png \"Prometheus 架构\")\n在监控流程中，主要由三个部分组成：被监控的应用暴露性能指标(exporter)，promethues 应用采集性能指标(collector)，数据可视化分析界面(web UI)。详情参照下述：\n1. Prometheus server: 用于抓取数据，并存储到时序数据库;\n2. Prometheus exporter: 安装在监控目标的上，为 Prometheus server 提供数据抓取的接口;\n3. Prometheus web UI: 提供数据可视化分析界面;\n4. Alertmanager: 用于处理警报;\n5. Pushgateway: 用于 job 推送;\n\n### 二、Prometheus 监控流程图\n![](/flowChart.png \"Prometheus flow chart\")\n\n#### Promethues server\n主要负责数据采集和存储，提供 PromQL 查询语言的支持。可以通过 Prometheus 的 `.yml`文件中的`scrape_config` [(字段详情)](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config)来配置要抓取的应用指标地址。同时，Promethues 也会监控自身的健康情况，默认将指标暴露在自身的 `http://localhost:9090/metrics`。\n\n#### Promethues exporter\n参照[官方推荐的插件列表](https://prometheus.io/docs/instrumenting/clientlibs/)，由于本次监听的站点是 NodeJS 站点，所以选择 [prom-client](https://github.com/siimon/prom-client) 作为 exporter。\n注意：被监听的应用需要暴露指标接口供 server 抓取。\n\n#### Prometheus web UI\nGrafana 可以连接多种类型的库，选择 Promethues 即可，默认监听 Promethues server 的9090`/metrics` 路径。\n\n### 三、NodeJS 应用性能监控\n使用 [prom-client](https://github.com/siimon/prom-client) 和 [node-prometheus-gc-stats](https://github.com/SimenB/node-prometheus-gc-stats) 收集 NodeJS 的性能指标。\n* prom-client：收集服务端性能指标\n* node-prometheus-gc-stats：垃圾回收相关指标统计\n\n（prom-client 相当于一个exporter，将默认的指标暴露在 /metrics 接口，之后 Promethues service会根据 `.yml` 配置中的采集时间定期来这个接口采集数据信息，然后 web UI Grafana 再跟 Promethues server 进行同步）\n\n#### prom-client 文档\n一共支持四种数据格式：Histogram、Summary、Gauges 、Counters：\n\n* __Histogram(柱状图)__：统计数据的分布情况（比如 `Http_response_time` 的时间分布）\n* __Summary(摘要)__：主要用于表示一段时间内数据采样结果（请求持续的时间或响应大小）\n* __Gauges(仪表盘)__：最简单的度量指标，监测瞬间状态（监控硬盘容量或者内存的使用量）\n* __Counters(计数器)__：从数据量0开始累积计算，在理想状态下只能是永远的增长不会降低\n\n常用的采集方法：\n* collectDefaultMetrics() 返回 Promethues 的默认推荐指标，默认10s探测一次\n* AggregatorRegsitry 聚合注册器：监听集群的性能指标（主进程和其产生的子进程）\n  * clusterMetrics() 返回默认指标\n  * [抓取所有进程的 metrics 只能在主进程上抓取，在子进程上获取不到 metrics](https://github.com/siimon/prom-client/issues/257)\n\n收集到指标后，就可以利用 PromQL 进行计算了，计算时注意 PromQL __即时向量__ 和 __范围向量__ 两种向量的区别和转换：\n````\n    // 计算每分钟垃圾回收bytes数\n    delta(nodejs_gc_reclaimed_bytes_total{gctype=\"Scavenge\"}[1m])\n\n    // 计算个页面5min以内的DomReady均值\n    delta(FE_Timing_Performance_domReady_sum[5m])/delta(FE_Timing_Performance_domReady_count[5m])\n````\n\n#### ※[example-prometheus-nodejs](https://github.com/RisingStack/example-prometheus-nodejs)\n&emsp;&emsp; 这个 demo 是一个完整的 prom-client + Promethues + grafana 监控示例，有助于理解整个监控流程。\n\n### 四、前端异常记录实践结论\n__并不推荐使用 Prometheus 系统来记录前端页面性能等信息。__\n1. 从指标上来看，应用的基本性能指标：吞吐量、内存使用量、每秒请求数、请求平均耗时等。这些几乎都是“瞬时”值（由于时间窗口小，可看做瞬时值），而前端性能指标并不是“瞬时”，它更偏向于一段时间内的表现情况（时间窗口大）。Prometheus 系统主要用于监听应用的性能，它的数据类型更多是为应用服务。\n* 应用性能特点：一个应用，多个指标；\n* [前端页面的性能指标](https://kuro-p.github.io/2019/07/11/前端性能监控-Performance/#more)特点：一个页面，多个指标。多个页面。\n2. 从数据类型上来看：\n   * Gauges：不可以用来记录前端的性能表现。因为 Gauge 记录的某一刻的瞬时值，如果用来记录时间，则每次数据都会被最后访问的那名用户刷新；\n   * Counter：计数器虽然可以记录前端某个页面的访问次数，但若页面路由中携带参数，或者结尾带时间戳，则会生成多个重复页面的 Counter，遇到爬虫还会生成大量无用路径，表现并不好；\n   * Histogram、Summary：可以记录多个页面，多个指标；Histogram 和 Summary 很相似，只不过 Histogram 记录原始值，Summary 记录指标的各个占比。\n3. 从可视化web UI上来看：\n公司 Prometheus 系统默认使用的可视化UI是 Grafana。之前尝试用 Histogram 来记录前端各页面的性能表现，在 Grafana 中用折线图可视化数据。一个指标对应一个折线图，但由于页面路由多个，导致各个折线图中折线过多难以分辨；若取所有页面该指标的均值或者最大值来展示，又不知道峰值是哪个页面产生的。\n\n__综上可以看出，Prometheus 可以记录前端性能指标，但是受数据类型制约，它并不是最合适的。__\n\n### 参考资料\n* [Prometheus 官网](https://prometheus.io)\n* [Prometheus 的数据类型介绍](https://blog.csdn.net/polo2044/article/details/83277299)\n* [prom-client 监控示例](https://www.colabug.com/227611.html)\n* [如何区分 Prometheus 中 Histogram 和 Summary 类型的 metrics?](https://www.cnblogs.com/aguncn/p/9920545.html)","source":"_posts/Prometheus监控应用性能.md","raw":"---\ntitle: Prometheus 监控应用性能\ndate: 2019-07-15 10:21:58\ntags: [性能监控]\ncategories: 监控\n---\n&emsp;&emsp; Prometheus 是一个开源的监控系统。它可以自动化的监听应用各性能指标的变化情况，并发出报警信息。了解它目的，是想把前端页面的性能指标记录到公司的 Prometheus 监控系统上，利用它监听前端页面各类异常。\n<!--more-->\n### 一、Prometheus 系统简介\n[Prometheus](https://prometheus.io/) 是一个开源的服务监控系统，社区资源和开发者都很活跃。其主要原理是通过 HTTP 协议从远程的机器收集数据并存储在本地的[时序数据库](https://www.cnblogs.com/aiandbigdata/p/10052335.html)上。Prometheus 通过安装在远程机器上的 exporter (数据暴露)插件来收集监控数据。\n\n#### Prometheus 特点\nPrometheus 本身也是一个时序数据库，它通过 HTTP 的方式获取时序数据。Prometheus 自身的查询语言 PromQL 可多维度的查询并实时计算指标的值。通过 PromQL 提供的计算方法，可以自定义数据可视化的指标，以及报警临界值。它有四种数据类型，可针对不同场景使用不同数据类型。\n\n#### Prometheus 系统的组成部分\n![](/architecture.png \"Prometheus 架构\")\n在监控流程中，主要由三个部分组成：被监控的应用暴露性能指标(exporter)，promethues 应用采集性能指标(collector)，数据可视化分析界面(web UI)。详情参照下述：\n1. Prometheus server: 用于抓取数据，并存储到时序数据库;\n2. Prometheus exporter: 安装在监控目标的上，为 Prometheus server 提供数据抓取的接口;\n3. Prometheus web UI: 提供数据可视化分析界面;\n4. Alertmanager: 用于处理警报;\n5. Pushgateway: 用于 job 推送;\n\n### 二、Prometheus 监控流程图\n![](/flowChart.png \"Prometheus flow chart\")\n\n#### Promethues server\n主要负责数据采集和存储，提供 PromQL 查询语言的支持。可以通过 Prometheus 的 `.yml`文件中的`scrape_config` [(字段详情)](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config)来配置要抓取的应用指标地址。同时，Promethues 也会监控自身的健康情况，默认将指标暴露在自身的 `http://localhost:9090/metrics`。\n\n#### Promethues exporter\n参照[官方推荐的插件列表](https://prometheus.io/docs/instrumenting/clientlibs/)，由于本次监听的站点是 NodeJS 站点，所以选择 [prom-client](https://github.com/siimon/prom-client) 作为 exporter。\n注意：被监听的应用需要暴露指标接口供 server 抓取。\n\n#### Prometheus web UI\nGrafana 可以连接多种类型的库，选择 Promethues 即可，默认监听 Promethues server 的9090`/metrics` 路径。\n\n### 三、NodeJS 应用性能监控\n使用 [prom-client](https://github.com/siimon/prom-client) 和 [node-prometheus-gc-stats](https://github.com/SimenB/node-prometheus-gc-stats) 收集 NodeJS 的性能指标。\n* prom-client：收集服务端性能指标\n* node-prometheus-gc-stats：垃圾回收相关指标统计\n\n（prom-client 相当于一个exporter，将默认的指标暴露在 /metrics 接口，之后 Promethues service会根据 `.yml` 配置中的采集时间定期来这个接口采集数据信息，然后 web UI Grafana 再跟 Promethues server 进行同步）\n\n#### prom-client 文档\n一共支持四种数据格式：Histogram、Summary、Gauges 、Counters：\n\n* __Histogram(柱状图)__：统计数据的分布情况（比如 `Http_response_time` 的时间分布）\n* __Summary(摘要)__：主要用于表示一段时间内数据采样结果（请求持续的时间或响应大小）\n* __Gauges(仪表盘)__：最简单的度量指标，监测瞬间状态（监控硬盘容量或者内存的使用量）\n* __Counters(计数器)__：从数据量0开始累积计算，在理想状态下只能是永远的增长不会降低\n\n常用的采集方法：\n* collectDefaultMetrics() 返回 Promethues 的默认推荐指标，默认10s探测一次\n* AggregatorRegsitry 聚合注册器：监听集群的性能指标（主进程和其产生的子进程）\n  * clusterMetrics() 返回默认指标\n  * [抓取所有进程的 metrics 只能在主进程上抓取，在子进程上获取不到 metrics](https://github.com/siimon/prom-client/issues/257)\n\n收集到指标后，就可以利用 PromQL 进行计算了，计算时注意 PromQL __即时向量__ 和 __范围向量__ 两种向量的区别和转换：\n````\n    // 计算每分钟垃圾回收bytes数\n    delta(nodejs_gc_reclaimed_bytes_total{gctype=\"Scavenge\"}[1m])\n\n    // 计算个页面5min以内的DomReady均值\n    delta(FE_Timing_Performance_domReady_sum[5m])/delta(FE_Timing_Performance_domReady_count[5m])\n````\n\n#### ※[example-prometheus-nodejs](https://github.com/RisingStack/example-prometheus-nodejs)\n&emsp;&emsp; 这个 demo 是一个完整的 prom-client + Promethues + grafana 监控示例，有助于理解整个监控流程。\n\n### 四、前端异常记录实践结论\n__并不推荐使用 Prometheus 系统来记录前端页面性能等信息。__\n1. 从指标上来看，应用的基本性能指标：吞吐量、内存使用量、每秒请求数、请求平均耗时等。这些几乎都是“瞬时”值（由于时间窗口小，可看做瞬时值），而前端性能指标并不是“瞬时”，它更偏向于一段时间内的表现情况（时间窗口大）。Prometheus 系统主要用于监听应用的性能，它的数据类型更多是为应用服务。\n* 应用性能特点：一个应用，多个指标；\n* [前端页面的性能指标](https://kuro-p.github.io/2019/07/11/前端性能监控-Performance/#more)特点：一个页面，多个指标。多个页面。\n2. 从数据类型上来看：\n   * Gauges：不可以用来记录前端的性能表现。因为 Gauge 记录的某一刻的瞬时值，如果用来记录时间，则每次数据都会被最后访问的那名用户刷新；\n   * Counter：计数器虽然可以记录前端某个页面的访问次数，但若页面路由中携带参数，或者结尾带时间戳，则会生成多个重复页面的 Counter，遇到爬虫还会生成大量无用路径，表现并不好；\n   * Histogram、Summary：可以记录多个页面，多个指标；Histogram 和 Summary 很相似，只不过 Histogram 记录原始值，Summary 记录指标的各个占比。\n3. 从可视化web UI上来看：\n公司 Prometheus 系统默认使用的可视化UI是 Grafana。之前尝试用 Histogram 来记录前端各页面的性能表现，在 Grafana 中用折线图可视化数据。一个指标对应一个折线图，但由于页面路由多个，导致各个折线图中折线过多难以分辨；若取所有页面该指标的均值或者最大值来展示，又不知道峰值是哪个页面产生的。\n\n__综上可以看出，Prometheus 可以记录前端性能指标，但是受数据类型制约，它并不是最合适的。__\n\n### 参考资料\n* [Prometheus 官网](https://prometheus.io)\n* [Prometheus 的数据类型介绍](https://blog.csdn.net/polo2044/article/details/83277299)\n* [prom-client 监控示例](https://www.colabug.com/227611.html)\n* [如何区分 Prometheus 中 Histogram 和 Summary 类型的 metrics?](https://www.cnblogs.com/aguncn/p/9920545.html)","slug":"Prometheus监控应用性能","published":1,"updated":"2020-11-04T08:29:30.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0p000i7vvu8n4jb82d","content":"<p>&emsp;&emsp; Prometheus 是一个开源的监控系统。它可以自动化的监听应用各性能指标的变化情况，并发出报警信息。了解它目的，是想把前端页面的性能指标记录到公司的 Prometheus 监控系统上，利用它监听前端页面各类异常。<br><a id=\"more\"></a></p>\n<h3 id=\"一、Prometheus-系统简介\"><a href=\"#一、Prometheus-系统简介\" class=\"headerlink\" title=\"一、Prometheus 系统简介\"></a>一、Prometheus 系统简介</h3><p><a href=\"https://prometheus.io/\" target=\"_blank\" rel=\"noopener\">Prometheus</a> 是一个开源的服务监控系统，社区资源和开发者都很活跃。其主要原理是通过 HTTP 协议从远程的机器收集数据并存储在本地的<a href=\"https://www.cnblogs.com/aiandbigdata/p/10052335.html\" target=\"_blank\" rel=\"noopener\">时序数据库</a>上。Prometheus 通过安装在远程机器上的 exporter (数据暴露)插件来收集监控数据。</p>\n<h4 id=\"Prometheus-特点\"><a href=\"#Prometheus-特点\" class=\"headerlink\" title=\"Prometheus 特点\"></a>Prometheus 特点</h4><p>Prometheus 本身也是一个时序数据库，它通过 HTTP 的方式获取时序数据。Prometheus 自身的查询语言 PromQL 可多维度的查询并实时计算指标的值。通过 PromQL 提供的计算方法，可以自定义数据可视化的指标，以及报警临界值。它有四种数据类型，可针对不同场景使用不同数据类型。</p>\n<h4 id=\"Prometheus-系统的组成部分\"><a href=\"#Prometheus-系统的组成部分\" class=\"headerlink\" title=\"Prometheus 系统的组成部分\"></a>Prometheus 系统的组成部分</h4><p><img src=\"/2019/07/15/Prometheus监控应用性能/architecture.png\" alt=\"\" title=\"Prometheus 架构\"><br>在监控流程中，主要由三个部分组成：被监控的应用暴露性能指标(exporter)，promethues 应用采集性能指标(collector)，数据可视化分析界面(web UI)。详情参照下述：</p>\n<ol>\n<li>Prometheus server: 用于抓取数据，并存储到时序数据库;</li>\n<li>Prometheus exporter: 安装在监控目标的上，为 Prometheus server 提供数据抓取的接口;</li>\n<li>Prometheus web UI: 提供数据可视化分析界面;</li>\n<li>Alertmanager: 用于处理警报;</li>\n<li>Pushgateway: 用于 job 推送;</li>\n</ol>\n<h3 id=\"二、Prometheus-监控流程图\"><a href=\"#二、Prometheus-监控流程图\" class=\"headerlink\" title=\"二、Prometheus 监控流程图\"></a>二、Prometheus 监控流程图</h3><p><img src=\"/2019/07/15/Prometheus监控应用性能/flowChart.png\" alt=\"\" title=\"Prometheus flow chart\"></p>\n<h4 id=\"Promethues-server\"><a href=\"#Promethues-server\" class=\"headerlink\" title=\"Promethues server\"></a>Promethues server</h4><p>主要负责数据采集和存储，提供 PromQL 查询语言的支持。可以通过 Prometheus 的 <code>.yml</code>文件中的<code>scrape_config</code> <a href=\"https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config\" target=\"_blank\" rel=\"noopener\">(字段详情)</a>来配置要抓取的应用指标地址。同时，Promethues 也会监控自身的健康情况，默认将指标暴露在自身的 <code>http://localhost:9090/metrics</code>。</p>\n<h4 id=\"Promethues-exporter\"><a href=\"#Promethues-exporter\" class=\"headerlink\" title=\"Promethues exporter\"></a>Promethues exporter</h4><p>参照<a href=\"https://prometheus.io/docs/instrumenting/clientlibs/\" target=\"_blank\" rel=\"noopener\">官方推荐的插件列表</a>，由于本次监听的站点是 NodeJS 站点，所以选择 <a href=\"https://github.com/siimon/prom-client\" target=\"_blank\" rel=\"noopener\">prom-client</a> 作为 exporter。<br>注意：被监听的应用需要暴露指标接口供 server 抓取。</p>\n<h4 id=\"Prometheus-web-UI\"><a href=\"#Prometheus-web-UI\" class=\"headerlink\" title=\"Prometheus web UI\"></a>Prometheus web UI</h4><p>Grafana 可以连接多种类型的库，选择 Promethues 即可，默认监听 Promethues server 的9090<code>/metrics</code> 路径。</p>\n<h3 id=\"三、NodeJS-应用性能监控\"><a href=\"#三、NodeJS-应用性能监控\" class=\"headerlink\" title=\"三、NodeJS 应用性能监控\"></a>三、NodeJS 应用性能监控</h3><p>使用 <a href=\"https://github.com/siimon/prom-client\" target=\"_blank\" rel=\"noopener\">prom-client</a> 和 <a href=\"https://github.com/SimenB/node-prometheus-gc-stats\" target=\"_blank\" rel=\"noopener\">node-prometheus-gc-stats</a> 收集 NodeJS 的性能指标。</p>\n<ul>\n<li>prom-client：收集服务端性能指标</li>\n<li>node-prometheus-gc-stats：垃圾回收相关指标统计</li>\n</ul>\n<p>（prom-client 相当于一个exporter，将默认的指标暴露在 /metrics 接口，之后 Promethues service会根据 <code>.yml</code> 配置中的采集时间定期来这个接口采集数据信息，然后 web UI Grafana 再跟 Promethues server 进行同步）</p>\n<h4 id=\"prom-client-文档\"><a href=\"#prom-client-文档\" class=\"headerlink\" title=\"prom-client 文档\"></a>prom-client 文档</h4><p>一共支持四种数据格式：Histogram、Summary、Gauges 、Counters：</p>\n<ul>\n<li><strong>Histogram(柱状图)</strong>：统计数据的分布情况（比如 <code>Http_response_time</code> 的时间分布）</li>\n<li><strong>Summary(摘要)</strong>：主要用于表示一段时间内数据采样结果（请求持续的时间或响应大小）</li>\n<li><strong>Gauges(仪表盘)</strong>：最简单的度量指标，监测瞬间状态（监控硬盘容量或者内存的使用量）</li>\n<li><strong>Counters(计数器)</strong>：从数据量0开始累积计算，在理想状态下只能是永远的增长不会降低</li>\n</ul>\n<p>常用的采集方法：</p>\n<ul>\n<li>collectDefaultMetrics() 返回 Promethues 的默认推荐指标，默认10s探测一次</li>\n<li>AggregatorRegsitry 聚合注册器：监听集群的性能指标（主进程和其产生的子进程）<ul>\n<li>clusterMetrics() 返回默认指标</li>\n<li><a href=\"https://github.com/siimon/prom-client/issues/257\" target=\"_blank\" rel=\"noopener\">抓取所有进程的 metrics 只能在主进程上抓取，在子进程上获取不到 metrics</a></li>\n</ul>\n</li>\n</ul>\n<p>收集到指标后，就可以利用 PromQL 进行计算了，计算时注意 PromQL <strong>即时向量</strong> 和 <strong>范围向量</strong> 两种向量的区别和转换：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 计算每分钟垃圾回收bytes数</span><br><span class=\"line\">delta(nodejs_gc_reclaimed_bytes_total&#123;gctype=&quot;Scavenge&quot;&#125;[1m])</span><br><span class=\"line\"></span><br><span class=\"line\">// 计算个页面5min以内的DomReady均值</span><br><span class=\"line\">delta(FE_Timing_Performance_domReady_sum[5m])/delta(FE_Timing_Performance_domReady_count[5m])</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"※example-prometheus-nodejs\"><a href=\"#※example-prometheus-nodejs\" class=\"headerlink\" title=\"※example-prometheus-nodejs\"></a>※<a href=\"https://github.com/RisingStack/example-prometheus-nodejs\" target=\"_blank\" rel=\"noopener\">example-prometheus-nodejs</a></h4><p>&emsp;&emsp; 这个 demo 是一个完整的 prom-client + Promethues + grafana 监控示例，有助于理解整个监控流程。</p>\n<h3 id=\"四、前端异常记录实践结论\"><a href=\"#四、前端异常记录实践结论\" class=\"headerlink\" title=\"四、前端异常记录实践结论\"></a>四、前端异常记录实践结论</h3><p><strong>并不推荐使用 Prometheus 系统来记录前端页面性能等信息。</strong></p>\n<ol>\n<li>从指标上来看，应用的基本性能指标：吞吐量、内存使用量、每秒请求数、请求平均耗时等。这些几乎都是“瞬时”值（由于时间窗口小，可看做瞬时值），而前端性能指标并不是“瞬时”，它更偏向于一段时间内的表现情况（时间窗口大）。Prometheus 系统主要用于监听应用的性能，它的数据类型更多是为应用服务。</li>\n</ol>\n<ul>\n<li>应用性能特点：一个应用，多个指标；</li>\n<li><a href=\"https://kuro-p.github.io/2019/07/11/前端性能监控-Performance/#more\" target=\"_blank\" rel=\"noopener\">前端页面的性能指标</a>特点：一个页面，多个指标。多个页面。</li>\n</ul>\n<ol start=\"2\">\n<li>从数据类型上来看：<ul>\n<li>Gauges：不可以用来记录前端的性能表现。因为 Gauge 记录的某一刻的瞬时值，如果用来记录时间，则每次数据都会被最后访问的那名用户刷新；</li>\n<li>Counter：计数器虽然可以记录前端某个页面的访问次数，但若页面路由中携带参数，或者结尾带时间戳，则会生成多个重复页面的 Counter，遇到爬虫还会生成大量无用路径，表现并不好；</li>\n<li>Histogram、Summary：可以记录多个页面，多个指标；Histogram 和 Summary 很相似，只不过 Histogram 记录原始值，Summary 记录指标的各个占比。</li>\n</ul>\n</li>\n<li>从可视化web UI上来看：<br>公司 Prometheus 系统默认使用的可视化UI是 Grafana。之前尝试用 Histogram 来记录前端各页面的性能表现，在 Grafana 中用折线图可视化数据。一个指标对应一个折线图，但由于页面路由多个，导致各个折线图中折线过多难以分辨；若取所有页面该指标的均值或者最大值来展示，又不知道峰值是哪个页面产生的。</li>\n</ol>\n<p><strong>综上可以看出，Prometheus 可以记录前端性能指标，但是受数据类型制约，它并不是最合适的。</strong></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://prometheus.io\" target=\"_blank\" rel=\"noopener\">Prometheus 官网</a></li>\n<li><a href=\"https://blog.csdn.net/polo2044/article/details/83277299\" target=\"_blank\" rel=\"noopener\">Prometheus 的数据类型介绍</a></li>\n<li><a href=\"https://www.colabug.com/227611.html\" target=\"_blank\" rel=\"noopener\">prom-client 监控示例</a></li>\n<li><a href=\"https://www.cnblogs.com/aguncn/p/9920545.html\" target=\"_blank\" rel=\"noopener\">如何区分 Prometheus 中 Histogram 和 Summary 类型的 metrics?</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp; Prometheus 是一个开源的监控系统。它可以自动化的监听应用各性能指标的变化情况，并发出报警信息。了解它目的，是想把前端页面的性能指标记录到公司的 Prometheus 监控系统上，利用它监听前端页面各类异常。<br></p>","more":"<p></p>\n<h3 id=\"一、Prometheus-系统简介\"><a href=\"#一、Prometheus-系统简介\" class=\"headerlink\" title=\"一、Prometheus 系统简介\"></a>一、Prometheus 系统简介</h3><p><a href=\"https://prometheus.io/\" target=\"_blank\" rel=\"noopener\">Prometheus</a> 是一个开源的服务监控系统，社区资源和开发者都很活跃。其主要原理是通过 HTTP 协议从远程的机器收集数据并存储在本地的<a href=\"https://www.cnblogs.com/aiandbigdata/p/10052335.html\" target=\"_blank\" rel=\"noopener\">时序数据库</a>上。Prometheus 通过安装在远程机器上的 exporter (数据暴露)插件来收集监控数据。</p>\n<h4 id=\"Prometheus-特点\"><a href=\"#Prometheus-特点\" class=\"headerlink\" title=\"Prometheus 特点\"></a>Prometheus 特点</h4><p>Prometheus 本身也是一个时序数据库，它通过 HTTP 的方式获取时序数据。Prometheus 自身的查询语言 PromQL 可多维度的查询并实时计算指标的值。通过 PromQL 提供的计算方法，可以自定义数据可视化的指标，以及报警临界值。它有四种数据类型，可针对不同场景使用不同数据类型。</p>\n<h4 id=\"Prometheus-系统的组成部分\"><a href=\"#Prometheus-系统的组成部分\" class=\"headerlink\" title=\"Prometheus 系统的组成部分\"></a>Prometheus 系统的组成部分</h4><p><img src=\"/2019/07/15/Prometheus监控应用性能/architecture.png\" alt=\"\" title=\"Prometheus 架构\"><br>在监控流程中，主要由三个部分组成：被监控的应用暴露性能指标(exporter)，promethues 应用采集性能指标(collector)，数据可视化分析界面(web UI)。详情参照下述：</p>\n<ol>\n<li>Prometheus server: 用于抓取数据，并存储到时序数据库;</li>\n<li>Prometheus exporter: 安装在监控目标的上，为 Prometheus server 提供数据抓取的接口;</li>\n<li>Prometheus web UI: 提供数据可视化分析界面;</li>\n<li>Alertmanager: 用于处理警报;</li>\n<li>Pushgateway: 用于 job 推送;</li>\n</ol>\n<h3 id=\"二、Prometheus-监控流程图\"><a href=\"#二、Prometheus-监控流程图\" class=\"headerlink\" title=\"二、Prometheus 监控流程图\"></a>二、Prometheus 监控流程图</h3><p><img src=\"/2019/07/15/Prometheus监控应用性能/flowChart.png\" alt=\"\" title=\"Prometheus flow chart\"></p>\n<h4 id=\"Promethues-server\"><a href=\"#Promethues-server\" class=\"headerlink\" title=\"Promethues server\"></a>Promethues server</h4><p>主要负责数据采集和存储，提供 PromQL 查询语言的支持。可以通过 Prometheus 的 <code>.yml</code>文件中的<code>scrape_config</code> <a href=\"https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config\" target=\"_blank\" rel=\"noopener\">(字段详情)</a>来配置要抓取的应用指标地址。同时，Promethues 也会监控自身的健康情况，默认将指标暴露在自身的 <code>http://localhost:9090/metrics</code>。</p>\n<h4 id=\"Promethues-exporter\"><a href=\"#Promethues-exporter\" class=\"headerlink\" title=\"Promethues exporter\"></a>Promethues exporter</h4><p>参照<a href=\"https://prometheus.io/docs/instrumenting/clientlibs/\" target=\"_blank\" rel=\"noopener\">官方推荐的插件列表</a>，由于本次监听的站点是 NodeJS 站点，所以选择 <a href=\"https://github.com/siimon/prom-client\" target=\"_blank\" rel=\"noopener\">prom-client</a> 作为 exporter。<br>注意：被监听的应用需要暴露指标接口供 server 抓取。</p>\n<h4 id=\"Prometheus-web-UI\"><a href=\"#Prometheus-web-UI\" class=\"headerlink\" title=\"Prometheus web UI\"></a>Prometheus web UI</h4><p>Grafana 可以连接多种类型的库，选择 Promethues 即可，默认监听 Promethues server 的9090<code>/metrics</code> 路径。</p>\n<h3 id=\"三、NodeJS-应用性能监控\"><a href=\"#三、NodeJS-应用性能监控\" class=\"headerlink\" title=\"三、NodeJS 应用性能监控\"></a>三、NodeJS 应用性能监控</h3><p>使用 <a href=\"https://github.com/siimon/prom-client\" target=\"_blank\" rel=\"noopener\">prom-client</a> 和 <a href=\"https://github.com/SimenB/node-prometheus-gc-stats\" target=\"_blank\" rel=\"noopener\">node-prometheus-gc-stats</a> 收集 NodeJS 的性能指标。</p>\n<ul>\n<li>prom-client：收集服务端性能指标</li>\n<li>node-prometheus-gc-stats：垃圾回收相关指标统计</li>\n</ul>\n<p>（prom-client 相当于一个exporter，将默认的指标暴露在 /metrics 接口，之后 Promethues service会根据 <code>.yml</code> 配置中的采集时间定期来这个接口采集数据信息，然后 web UI Grafana 再跟 Promethues server 进行同步）</p>\n<h4 id=\"prom-client-文档\"><a href=\"#prom-client-文档\" class=\"headerlink\" title=\"prom-client 文档\"></a>prom-client 文档</h4><p>一共支持四种数据格式：Histogram、Summary、Gauges 、Counters：</p>\n<ul>\n<li><strong>Histogram(柱状图)</strong>：统计数据的分布情况（比如 <code>Http_response_time</code> 的时间分布）</li>\n<li><strong>Summary(摘要)</strong>：主要用于表示一段时间内数据采样结果（请求持续的时间或响应大小）</li>\n<li><strong>Gauges(仪表盘)</strong>：最简单的度量指标，监测瞬间状态（监控硬盘容量或者内存的使用量）</li>\n<li><strong>Counters(计数器)</strong>：从数据量0开始累积计算，在理想状态下只能是永远的增长不会降低</li>\n</ul>\n<p>常用的采集方法：</p>\n<ul>\n<li>collectDefaultMetrics() 返回 Promethues 的默认推荐指标，默认10s探测一次</li>\n<li>AggregatorRegsitry 聚合注册器：监听集群的性能指标（主进程和其产生的子进程）<ul>\n<li>clusterMetrics() 返回默认指标</li>\n<li><a href=\"https://github.com/siimon/prom-client/issues/257\" target=\"_blank\" rel=\"noopener\">抓取所有进程的 metrics 只能在主进程上抓取，在子进程上获取不到 metrics</a></li>\n</ul>\n</li>\n</ul>\n<p>收集到指标后，就可以利用 PromQL 进行计算了，计算时注意 PromQL <strong>即时向量</strong> 和 <strong>范围向量</strong> 两种向量的区别和转换：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 计算每分钟垃圾回收bytes数</span><br><span class=\"line\">delta(nodejs_gc_reclaimed_bytes_total&#123;gctype=&quot;Scavenge&quot;&#125;[1m])</span><br><span class=\"line\"></span><br><span class=\"line\">// 计算个页面5min以内的DomReady均值</span><br><span class=\"line\">delta(FE_Timing_Performance_domReady_sum[5m])/delta(FE_Timing_Performance_domReady_count[5m])</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"※example-prometheus-nodejs\"><a href=\"#※example-prometheus-nodejs\" class=\"headerlink\" title=\"※example-prometheus-nodejs\"></a>※<a href=\"https://github.com/RisingStack/example-prometheus-nodejs\" target=\"_blank\" rel=\"noopener\">example-prometheus-nodejs</a></h4><p>&emsp;&emsp; 这个 demo 是一个完整的 prom-client + Promethues + grafana 监控示例，有助于理解整个监控流程。</p>\n<h3 id=\"四、前端异常记录实践结论\"><a href=\"#四、前端异常记录实践结论\" class=\"headerlink\" title=\"四、前端异常记录实践结论\"></a>四、前端异常记录实践结论</h3><p><strong>并不推荐使用 Prometheus 系统来记录前端页面性能等信息。</strong></p>\n<ol>\n<li>从指标上来看，应用的基本性能指标：吞吐量、内存使用量、每秒请求数、请求平均耗时等。这些几乎都是“瞬时”值（由于时间窗口小，可看做瞬时值），而前端性能指标并不是“瞬时”，它更偏向于一段时间内的表现情况（时间窗口大）。Prometheus 系统主要用于监听应用的性能，它的数据类型更多是为应用服务。</li>\n</ol>\n<ul>\n<li>应用性能特点：一个应用，多个指标；</li>\n<li><a href=\"https://kuro-p.github.io/2019/07/11/前端性能监控-Performance/#more\" target=\"_blank\" rel=\"noopener\">前端页面的性能指标</a>特点：一个页面，多个指标。多个页面。</li>\n</ul>\n<ol start=\"2\">\n<li>从数据类型上来看：<ul>\n<li>Gauges：不可以用来记录前端的性能表现。因为 Gauge 记录的某一刻的瞬时值，如果用来记录时间，则每次数据都会被最后访问的那名用户刷新；</li>\n<li>Counter：计数器虽然可以记录前端某个页面的访问次数，但若页面路由中携带参数，或者结尾带时间戳，则会生成多个重复页面的 Counter，遇到爬虫还会生成大量无用路径，表现并不好；</li>\n<li>Histogram、Summary：可以记录多个页面，多个指标；Histogram 和 Summary 很相似，只不过 Histogram 记录原始值，Summary 记录指标的各个占比。</li>\n</ul>\n</li>\n<li>从可视化web UI上来看：<br>公司 Prometheus 系统默认使用的可视化UI是 Grafana。之前尝试用 Histogram 来记录前端各页面的性能表现，在 Grafana 中用折线图可视化数据。一个指标对应一个折线图，但由于页面路由多个，导致各个折线图中折线过多难以分辨；若取所有页面该指标的均值或者最大值来展示，又不知道峰值是哪个页面产生的。</li>\n</ol>\n<p><strong>综上可以看出，Prometheus 可以记录前端性能指标，但是受数据类型制约，它并不是最合适的。</strong></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://prometheus.io\" target=\"_blank\" rel=\"noopener\">Prometheus 官网</a></li>\n<li><a href=\"https://blog.csdn.net/polo2044/article/details/83277299\" target=\"_blank\" rel=\"noopener\">Prometheus 的数据类型介绍</a></li>\n<li><a href=\"https://www.colabug.com/227611.html\" target=\"_blank\" rel=\"noopener\">prom-client 监控示例</a></li>\n<li><a href=\"https://www.cnblogs.com/aguncn/p/9920545.html\" target=\"_blank\" rel=\"noopener\">如何区分 Prometheus 中 Histogram 和 Summary 类型的 metrics?</a></li>\n</ul>"},{"title":"PWA-Service Worker 小结（一）各类缓存对比","date":"2019-12-26T08:39:55.000Z","_content":"年底了，总结一下上半年探索的 PWA 的离线缓存技术。顺带总结了一下前端全流程每一步中都可能遇到的缓存，大部分都是概念、名词的理解和说明。涉及到的缓存有：HTTP 缓存、Manifest 缓存、CDN 缓存、Nginx 服务器缓存、Service Worker 缓存。\n\n<!--more-->\n\n缓存的好处：\n存储频繁访问的数据，降低服务器压力；\n减少网络延迟，加快页面打开速度；\n\n### 一、HTTP 缓存\n#### [浏览器缓存机制](https://www.cnblogs.com/slly/p/6732749.html)：\n1. [在未设置相应头缓存字段的时候，只有用户点击“回退”按钮的时候，页面才会从缓存中读取](https://segmentfault.com/a/1190000011286027)；\n2. __过期机制__：与服务器协商获取。对于浏览器来说，如何缓存一个资源是服务器端制定的策略，服务器对每个资源的 [HTTP 响应头设置属性和值](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)，自己只负责执行。常用的为以下几种：\n    * Expires: 设置过期时间(单位日期)，某日期之前都不再询问；浏览器再次命中这个资源，直至XXX时间前都不会发起 HTTP 请求，而是直接从缓存（在硬盘中）读取。\n      * 如：200 (from cache) 这种缓存速度最快。\n    * Last-Modified: 设置资源上次修改时间(单位日期)，每次请求命中资源，都去询问资源是否过期；通过这种缓存方式，无论资源是否发生变更，都会发生至少一来一去的 HTTP 头传输和接收，速度比不上 Expires；\n      * 如：304，若文件发生变更，则返回200。\n    * Cache-Control:\n      * max-age=<seconds> 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)；标准中规定 max-age 的值最大不能超过一年，且以秒为单位，所以值为 31536000；\n      * no-cache  字面意义“不缓存”。实际机制是对资源仍使用缓存，但每次使用前必须（MUST）向服务器对缓存资源进行验证；\n      * no-store 不使用任何缓存；\n3. __验证机制__：服务器返回资源的时候有时会在头信息中携带 __Etag（Entity Tag）__，它可作为浏览器再次请求过程的校验标识。如发现校验标识不匹配，说明资源已经修改或过期，浏览器需要重新获取资源内容。\nETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 ETag / If-None-Match 值来判断是否命中缓存。在精准度上，Etag 优于 Last-Modified。因为 Etag 是按照内容为资源增加标识，而 Last-Modified 是根据文件最后修改时间判断。\n![](/协商缓存命中过程.png \"协商缓存命中过程\")\n\n#### 常用的缓存策略：\n* 对于动态生成的 HTML 页面使用 HTTP 头: Cache-Control : no-cache;\n* 对于静态 HTML 页面使用 HTTP 头: Last-Modified;\n* 其他所有文件类型都设置 Cache-Control 头，并且在文件内容有所修改都时候修改文件名。\n\n#### 如何更新文件：\n按照 HTTP 规范，如果修改了请求资源的 Query String，就应该被视为一个新的文件。但是遇到运营商劫持时，会忽略 Query String，遇到这种情况只能修改文件名。\n\n#### 疑问：\n给 HTML 都设置了 Cache-Control: no-cache; 对 CSS 和 JS都用了 gulp 进行了打包编译处理，每次有变化都会变更文件名；那么此种情况下，是否还需要设置 Last-Modified？\n直接设置 Cache-Control max-age 或者 Expires 难道不会节省更多 HTTP 请求吗？避免服务器为做出应答返回大量 304。\n\n### 二、[Manifest 缓存](https://segmentfault.com/a/1190000019395237?utm_source=tag-newest)\nmanifest 在前端含义很多，常见的四个使用场景如下：\n1. HTML 标签的 manifest 属性，用来离线缓存 HTML 文档以及资源的；\n   * 如 <html manifest=\"xxx\"\\></html\\>，由于坑太多，现在已经被废弃；\n2. PWA 的 manifest 功能：将 web 应用程序安装到设备的主屏幕；\n   * 如 <link rel=\"manifest\" href=\"/manifest.json\"\\>；\n   * 在 manifest.json 中配置应用的图标、名称等信息；通过一系列配置，就可以为 Web App 添加一个图标到手机上，点击图标即可打开站点；\n3. webpack 打包时会生成个 manifest.json 的文件，用来分析打包后的文件；\n4. [gulp 处理静态资源时，使用 gulp 的 gulp-rev 插件生成 manifest.json，用来记录源文件与处理后的目标文件的对照](https://blog.csdn.net/wangjun5159/article/details/79287881)。\n\n### 三、CDN缓存\n即使为各类资源文件设置了 HTTP 头，当用户手动清除缓存 ，或者由于磁盘容量限制，先缓存的文件被挤出磁盘，此时依旧需要请求资源，为了快速响应用户请求，使用 CDN 加速。CDN的分流作用不仅减少了用户的访问延时，也减少了源站的负载。\n当用户手动清理本地缓存后，将去请求距离最近的 CDN 边缘节点。\nCDN 边缘节点缓存策略因服务商不同而不同，但一般会遵循 HTTP 标准协议。通过 HTTP 响应头中的 Cache-Control: max-age 的字段来设置CDN边缘节点数据缓存时间，若数据失效，则向源站发出回源请求，拉取最新的数据；当源站内容有更新的时候，源站主动把内容推到CDN节点。\n\n各家 CDN 缓存参考：[https://segmentfault.com/a/1190000006673084](https://segmentfault.com/a/1190000006673084)\n\nCDN 回源原理：[https://www.jianshu.com/p/e7751ecb6f21](https://www.jianshu.com/p/e7751ecb6f21)\n\n### 四、nginx 服务器缓存\n<del>这里又牵扯到了两个地方...就像家用路由器和企业级路由器虽然都叫路由器但是功能完全不一样...</del>\nnginx 大名 负载均衡服务器，它是服务器不是服务；CDN 加速是运营商提供的一种服务....，这俩玩意一点关系都没有。如果网站既使用了 CDN 加速，同时又使用了 Nginx 代理，那么 CDN 的位置相比于 Nginx 服务器更靠近用户。\n\n![](/CDN&&Nginx.jpg \"CDN && Nginx\")\n\n网站管理者可以通过为网站配置 Nginx 服务器来达到负载均衡的目的， Nginx 可以重写静态资源的 HTTP 头的缓存信息等，也可以用 Nginx 搭建自己的 CDN 节点（原理跟运营商 CDN 差不多，都是转发到合适的机器；只不过 CDN 是将静态资源存在运营商的机器上，Nginx 做 CDN 的话就缓存在自己的机器上）。具体选择时可通过银子的多少来判断是选 CDN 加速，还是 Nginx 搭建 CDN。\n\n综上，当 Nginx 服务器承载“CDN 加速”的功能时，可通过配置 proxy_cache 将文件缓存到本地的一个目录，缓存命中原理当与 CDN 相同；当 Nginx 服务器不充当 CDN，只是重写静态文件的响应头时，此时跟服务器写命令没差，缓存在浏览器中，原理见浏览器缓存命中机制，不再进行赘述。\n\n### 五、Service Worker 缓存\nService Worker  是一个位于浏览器和网络之间的客户端代理，可以拦截、处理流经的 HTTP 请求，使开发者可以从缓存中向 Web 应用提供资源。可以把它看成是用户设备中的缓存提供服务器，功能十分强大。它缓存的文件同样存储在客户端（用户设备）中：\n\n![](/web应用缓存位置图.png \"web应用缓存位置图\")\n\nService Worker 是 PWA 实现离线应用的核心技术。它可以：\n* 让网页可以离线访问；\n* 让网页在弱网情况，使用缓存快速打开应用，提升体验；\n* 同时在网络正常的情况下走网络缓存减少请求的带宽； \n* 对不支持的手机没有影响；\n\n__缓存有各自的优先级，当依次查找缓存且都没有命中的时候，才会去请求网络：__\n1. Service Worker\n2. Memory Cache\n3. Disk Cache\n4. 网络请求\n\n### 参考资料：\n* 《web全栈工程师的自我修养》\n* [由memoryCache和diskCache产生的浏览器缓存机制的思考](https://segmentfault.com/a/1190000011286027)\n* [HTTP强缓存和协商缓存](https://segmentfault.com/a/1190000008956069)\n* [Etag和Last-Modified](https://www.jianshu.com/p/b5c805f4e8d1)\n* [傻傻分不清的Manifest](https://segmentfault.com/a/1190000019395237?utm_source=tag-newest)\n* [定制修改gulp-rev返回的rev-manifest.json文件](https://blog.csdn.net/wangjun5159/article/details/79287881)\n* [从HTTP响应头看各家CDN缓存技术](https://segmentfault.com/a/1190000006673084)\n* [简述回源原理和CDN常见多级缓存](https://www.jianshu.com/p/e7751ecb6f21)\n* [渐进式网页应用(PWA)介绍](https://zhuanlan.zhihu.com/p/96934736)\n  ","source":"_posts/PWA-Service-Worker-小结（一）各类缓存对比.md","raw":"---\ntitle: PWA-Service Worker 小结（一）各类缓存对比\ndate: 2019-12-26 16:39:55\ntags: [Service Worker]\ncategories: [前端, PWA]\n---\n年底了，总结一下上半年探索的 PWA 的离线缓存技术。顺带总结了一下前端全流程每一步中都可能遇到的缓存，大部分都是概念、名词的理解和说明。涉及到的缓存有：HTTP 缓存、Manifest 缓存、CDN 缓存、Nginx 服务器缓存、Service Worker 缓存。\n\n<!--more-->\n\n缓存的好处：\n存储频繁访问的数据，降低服务器压力；\n减少网络延迟，加快页面打开速度；\n\n### 一、HTTP 缓存\n#### [浏览器缓存机制](https://www.cnblogs.com/slly/p/6732749.html)：\n1. [在未设置相应头缓存字段的时候，只有用户点击“回退”按钮的时候，页面才会从缓存中读取](https://segmentfault.com/a/1190000011286027)；\n2. __过期机制__：与服务器协商获取。对于浏览器来说，如何缓存一个资源是服务器端制定的策略，服务器对每个资源的 [HTTP 响应头设置属性和值](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)，自己只负责执行。常用的为以下几种：\n    * Expires: 设置过期时间(单位日期)，某日期之前都不再询问；浏览器再次命中这个资源，直至XXX时间前都不会发起 HTTP 请求，而是直接从缓存（在硬盘中）读取。\n      * 如：200 (from cache) 这种缓存速度最快。\n    * Last-Modified: 设置资源上次修改时间(单位日期)，每次请求命中资源，都去询问资源是否过期；通过这种缓存方式，无论资源是否发生变更，都会发生至少一来一去的 HTTP 头传输和接收，速度比不上 Expires；\n      * 如：304，若文件发生变更，则返回200。\n    * Cache-Control:\n      * max-age=<seconds> 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)；标准中规定 max-age 的值最大不能超过一年，且以秒为单位，所以值为 31536000；\n      * no-cache  字面意义“不缓存”。实际机制是对资源仍使用缓存，但每次使用前必须（MUST）向服务器对缓存资源进行验证；\n      * no-store 不使用任何缓存；\n3. __验证机制__：服务器返回资源的时候有时会在头信息中携带 __Etag（Entity Tag）__，它可作为浏览器再次请求过程的校验标识。如发现校验标识不匹配，说明资源已经修改或过期，浏览器需要重新获取资源内容。\nETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 ETag / If-None-Match 值来判断是否命中缓存。在精准度上，Etag 优于 Last-Modified。因为 Etag 是按照内容为资源增加标识，而 Last-Modified 是根据文件最后修改时间判断。\n![](/协商缓存命中过程.png \"协商缓存命中过程\")\n\n#### 常用的缓存策略：\n* 对于动态生成的 HTML 页面使用 HTTP 头: Cache-Control : no-cache;\n* 对于静态 HTML 页面使用 HTTP 头: Last-Modified;\n* 其他所有文件类型都设置 Cache-Control 头，并且在文件内容有所修改都时候修改文件名。\n\n#### 如何更新文件：\n按照 HTTP 规范，如果修改了请求资源的 Query String，就应该被视为一个新的文件。但是遇到运营商劫持时，会忽略 Query String，遇到这种情况只能修改文件名。\n\n#### 疑问：\n给 HTML 都设置了 Cache-Control: no-cache; 对 CSS 和 JS都用了 gulp 进行了打包编译处理，每次有变化都会变更文件名；那么此种情况下，是否还需要设置 Last-Modified？\n直接设置 Cache-Control max-age 或者 Expires 难道不会节省更多 HTTP 请求吗？避免服务器为做出应答返回大量 304。\n\n### 二、[Manifest 缓存](https://segmentfault.com/a/1190000019395237?utm_source=tag-newest)\nmanifest 在前端含义很多，常见的四个使用场景如下：\n1. HTML 标签的 manifest 属性，用来离线缓存 HTML 文档以及资源的；\n   * 如 <html manifest=\"xxx\"\\></html\\>，由于坑太多，现在已经被废弃；\n2. PWA 的 manifest 功能：将 web 应用程序安装到设备的主屏幕；\n   * 如 <link rel=\"manifest\" href=\"/manifest.json\"\\>；\n   * 在 manifest.json 中配置应用的图标、名称等信息；通过一系列配置，就可以为 Web App 添加一个图标到手机上，点击图标即可打开站点；\n3. webpack 打包时会生成个 manifest.json 的文件，用来分析打包后的文件；\n4. [gulp 处理静态资源时，使用 gulp 的 gulp-rev 插件生成 manifest.json，用来记录源文件与处理后的目标文件的对照](https://blog.csdn.net/wangjun5159/article/details/79287881)。\n\n### 三、CDN缓存\n即使为各类资源文件设置了 HTTP 头，当用户手动清除缓存 ，或者由于磁盘容量限制，先缓存的文件被挤出磁盘，此时依旧需要请求资源，为了快速响应用户请求，使用 CDN 加速。CDN的分流作用不仅减少了用户的访问延时，也减少了源站的负载。\n当用户手动清理本地缓存后，将去请求距离最近的 CDN 边缘节点。\nCDN 边缘节点缓存策略因服务商不同而不同，但一般会遵循 HTTP 标准协议。通过 HTTP 响应头中的 Cache-Control: max-age 的字段来设置CDN边缘节点数据缓存时间，若数据失效，则向源站发出回源请求，拉取最新的数据；当源站内容有更新的时候，源站主动把内容推到CDN节点。\n\n各家 CDN 缓存参考：[https://segmentfault.com/a/1190000006673084](https://segmentfault.com/a/1190000006673084)\n\nCDN 回源原理：[https://www.jianshu.com/p/e7751ecb6f21](https://www.jianshu.com/p/e7751ecb6f21)\n\n### 四、nginx 服务器缓存\n<del>这里又牵扯到了两个地方...就像家用路由器和企业级路由器虽然都叫路由器但是功能完全不一样...</del>\nnginx 大名 负载均衡服务器，它是服务器不是服务；CDN 加速是运营商提供的一种服务....，这俩玩意一点关系都没有。如果网站既使用了 CDN 加速，同时又使用了 Nginx 代理，那么 CDN 的位置相比于 Nginx 服务器更靠近用户。\n\n![](/CDN&&Nginx.jpg \"CDN && Nginx\")\n\n网站管理者可以通过为网站配置 Nginx 服务器来达到负载均衡的目的， Nginx 可以重写静态资源的 HTTP 头的缓存信息等，也可以用 Nginx 搭建自己的 CDN 节点（原理跟运营商 CDN 差不多，都是转发到合适的机器；只不过 CDN 是将静态资源存在运营商的机器上，Nginx 做 CDN 的话就缓存在自己的机器上）。具体选择时可通过银子的多少来判断是选 CDN 加速，还是 Nginx 搭建 CDN。\n\n综上，当 Nginx 服务器承载“CDN 加速”的功能时，可通过配置 proxy_cache 将文件缓存到本地的一个目录，缓存命中原理当与 CDN 相同；当 Nginx 服务器不充当 CDN，只是重写静态文件的响应头时，此时跟服务器写命令没差，缓存在浏览器中，原理见浏览器缓存命中机制，不再进行赘述。\n\n### 五、Service Worker 缓存\nService Worker  是一个位于浏览器和网络之间的客户端代理，可以拦截、处理流经的 HTTP 请求，使开发者可以从缓存中向 Web 应用提供资源。可以把它看成是用户设备中的缓存提供服务器，功能十分强大。它缓存的文件同样存储在客户端（用户设备）中：\n\n![](/web应用缓存位置图.png \"web应用缓存位置图\")\n\nService Worker 是 PWA 实现离线应用的核心技术。它可以：\n* 让网页可以离线访问；\n* 让网页在弱网情况，使用缓存快速打开应用，提升体验；\n* 同时在网络正常的情况下走网络缓存减少请求的带宽； \n* 对不支持的手机没有影响；\n\n__缓存有各自的优先级，当依次查找缓存且都没有命中的时候，才会去请求网络：__\n1. Service Worker\n2. Memory Cache\n3. Disk Cache\n4. 网络请求\n\n### 参考资料：\n* 《web全栈工程师的自我修养》\n* [由memoryCache和diskCache产生的浏览器缓存机制的思考](https://segmentfault.com/a/1190000011286027)\n* [HTTP强缓存和协商缓存](https://segmentfault.com/a/1190000008956069)\n* [Etag和Last-Modified](https://www.jianshu.com/p/b5c805f4e8d1)\n* [傻傻分不清的Manifest](https://segmentfault.com/a/1190000019395237?utm_source=tag-newest)\n* [定制修改gulp-rev返回的rev-manifest.json文件](https://blog.csdn.net/wangjun5159/article/details/79287881)\n* [从HTTP响应头看各家CDN缓存技术](https://segmentfault.com/a/1190000006673084)\n* [简述回源原理和CDN常见多级缓存](https://www.jianshu.com/p/e7751ecb6f21)\n* [渐进式网页应用(PWA)介绍](https://zhuanlan.zhihu.com/p/96934736)\n  ","slug":"PWA-Service-Worker-小结（一）各类缓存对比","published":1,"updated":"2020-11-04T08:29:30.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0s000l7vvuq19jmoef","content":"<p>年底了，总结一下上半年探索的 PWA 的离线缓存技术。顺带总结了一下前端全流程每一步中都可能遇到的缓存，大部分都是概念、名词的理解和说明。涉及到的缓存有：HTTP 缓存、Manifest 缓存、CDN 缓存、Nginx 服务器缓存、Service Worker 缓存。</p>\n<a id=\"more\"></a>\n<p>缓存的好处：<br>存储频繁访问的数据，降低服务器压力；<br>减少网络延迟，加快页面打开速度；</p>\n<h3 id=\"一、HTTP-缓存\"><a href=\"#一、HTTP-缓存\" class=\"headerlink\" title=\"一、HTTP 缓存\"></a>一、HTTP 缓存</h3><h4 id=\"浏览器缓存机制：\"><a href=\"#浏览器缓存机制：\" class=\"headerlink\" title=\"浏览器缓存机制：\"></a><a href=\"https://www.cnblogs.com/slly/p/6732749.html\" target=\"_blank\" rel=\"noopener\">浏览器缓存机制</a>：</h4><ol>\n<li><a href=\"https://segmentfault.com/a/1190000011286027\" target=\"_blank\" rel=\"noopener\">在未设置相应头缓存字段的时候，只有用户点击“回退”按钮的时候，页面才会从缓存中读取</a>；</li>\n<li><strong>过期机制</strong>：与服务器协商获取。对于浏览器来说，如何缓存一个资源是服务器端制定的策略，服务器对每个资源的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ\" target=\"_blank\" rel=\"noopener\">HTTP 响应头设置属性和值</a>，自己只负责执行。常用的为以下几种：<ul>\n<li>Expires: 设置过期时间(单位日期)，某日期之前都不再询问；浏览器再次命中这个资源，直至XXX时间前都不会发起 HTTP 请求，而是直接从缓存（在硬盘中）读取。<ul>\n<li>如：200 (from cache) 这种缓存速度最快。</li>\n</ul>\n</li>\n<li>Last-Modified: 设置资源上次修改时间(单位日期)，每次请求命中资源，都去询问资源是否过期；通过这种缓存方式，无论资源是否发生变更，都会发生至少一来一去的 HTTP 头传输和接收，速度比不上 Expires；<ul>\n<li>如：304，若文件发生变更，则返回200。</li>\n</ul>\n</li>\n<li>Cache-Control:<ul>\n<li>max-age=<seconds> 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)；标准中规定 max-age 的值最大不能超过一年，且以秒为单位，所以值为 31536000；</seconds></li>\n<li>no-cache  字面意义“不缓存”。实际机制是对资源仍使用缓存，但每次使用前必须（MUST）向服务器对缓存资源进行验证；</li>\n<li>no-store 不使用任何缓存；</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>验证机制</strong>：服务器返回资源的时候有时会在头信息中携带 <strong>Etag（Entity Tag）</strong>，它可作为浏览器再次请求过程的校验标识。如发现校验标识不匹配，说明资源已经修改或过期，浏览器需要重新获取资源内容。<br>ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 ETag / If-None-Match 值来判断是否命中缓存。在精准度上，Etag 优于 Last-Modified。因为 Etag 是按照内容为资源增加标识，而 Last-Modified 是根据文件最后修改时间判断。<br><img src=\"/2019/12/26/PWA-Service-Worker-小结（一）各类缓存对比/协商缓存命中过程.png\" alt=\"\" title=\"协商缓存命中过程\"></li>\n</ol>\n<h4 id=\"常用的缓存策略：\"><a href=\"#常用的缓存策略：\" class=\"headerlink\" title=\"常用的缓存策略：\"></a>常用的缓存策略：</h4><ul>\n<li>对于动态生成的 HTML 页面使用 HTTP 头: Cache-Control : no-cache;</li>\n<li>对于静态 HTML 页面使用 HTTP 头: Last-Modified;</li>\n<li>其他所有文件类型都设置 Cache-Control 头，并且在文件内容有所修改都时候修改文件名。</li>\n</ul>\n<h4 id=\"如何更新文件：\"><a href=\"#如何更新文件：\" class=\"headerlink\" title=\"如何更新文件：\"></a>如何更新文件：</h4><p>按照 HTTP 规范，如果修改了请求资源的 Query String，就应该被视为一个新的文件。但是遇到运营商劫持时，会忽略 Query String，遇到这种情况只能修改文件名。</p>\n<h4 id=\"疑问：\"><a href=\"#疑问：\" class=\"headerlink\" title=\"疑问：\"></a>疑问：</h4><p>给 HTML 都设置了 Cache-Control: no-cache; 对 CSS 和 JS都用了 gulp 进行了打包编译处理，每次有变化都会变更文件名；那么此种情况下，是否还需要设置 Last-Modified？<br>直接设置 Cache-Control max-age 或者 Expires 难道不会节省更多 HTTP 请求吗？避免服务器为做出应答返回大量 304。</p>\n<h3 id=\"二、Manifest-缓存\"><a href=\"#二、Manifest-缓存\" class=\"headerlink\" title=\"二、Manifest 缓存\"></a>二、<a href=\"https://segmentfault.com/a/1190000019395237?utm_source=tag-newest\" target=\"_blank\" rel=\"noopener\">Manifest 缓存</a></h3><p>manifest 在前端含义很多，常见的四个使用场景如下：</p>\n<ol>\n<li>HTML 标签的 manifest 属性，用来离线缓存 HTML 文档以及资源的；<ul>\n<li>如 &lt;html manifest=”xxx”>&lt;/html>，由于坑太多，现在已经被废弃；</li>\n</ul>\n</li>\n<li>PWA 的 manifest 功能：将 web 应用程序安装到设备的主屏幕；<ul>\n<li>如 &lt;link rel=”manifest” href=”/manifest.json”>；</li>\n<li>在 manifest.json 中配置应用的图标、名称等信息；通过一系列配置，就可以为 Web App 添加一个图标到手机上，点击图标即可打开站点；</li>\n</ul>\n</li>\n<li>webpack 打包时会生成个 manifest.json 的文件，用来分析打包后的文件；</li>\n<li><a href=\"https://blog.csdn.net/wangjun5159/article/details/79287881\" target=\"_blank\" rel=\"noopener\">gulp 处理静态资源时，使用 gulp 的 gulp-rev 插件生成 manifest.json，用来记录源文件与处理后的目标文件的对照</a>。</li>\n</ol>\n<h3 id=\"三、CDN缓存\"><a href=\"#三、CDN缓存\" class=\"headerlink\" title=\"三、CDN缓存\"></a>三、CDN缓存</h3><p>即使为各类资源文件设置了 HTTP 头，当用户手动清除缓存 ，或者由于磁盘容量限制，先缓存的文件被挤出磁盘，此时依旧需要请求资源，为了快速响应用户请求，使用 CDN 加速。CDN的分流作用不仅减少了用户的访问延时，也减少了源站的负载。<br>当用户手动清理本地缓存后，将去请求距离最近的 CDN 边缘节点。<br>CDN 边缘节点缓存策略因服务商不同而不同，但一般会遵循 HTTP 标准协议。通过 HTTP 响应头中的 Cache-Control: max-age 的字段来设置CDN边缘节点数据缓存时间，若数据失效，则向源站发出回源请求，拉取最新的数据；当源站内容有更新的时候，源站主动把内容推到CDN节点。</p>\n<p>各家 CDN 缓存参考：<a href=\"https://segmentfault.com/a/1190000006673084\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000006673084</a></p>\n<p>CDN 回源原理：<a href=\"https://www.jianshu.com/p/e7751ecb6f21\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/e7751ecb6f21</a></p>\n<h3 id=\"四、nginx-服务器缓存\"><a href=\"#四、nginx-服务器缓存\" class=\"headerlink\" title=\"四、nginx 服务器缓存\"></a>四、nginx 服务器缓存</h3><p><del>这里又牵扯到了两个地方…就像家用路由器和企业级路由器虽然都叫路由器但是功能完全不一样…</del><br>nginx 大名 负载均衡服务器，它是服务器不是服务；CDN 加速是运营商提供的一种服务….，这俩玩意一点关系都没有。如果网站既使用了 CDN 加速，同时又使用了 Nginx 代理，那么 CDN 的位置相比于 Nginx 服务器更靠近用户。</p>\n<p><img src=\"/2019/12/26/PWA-Service-Worker-小结（一）各类缓存对比/CDN&amp;&amp;Nginx.jpg\" alt=\"\" title=\"CDN &amp;&amp; Nginx\"></p>\n<p>网站管理者可以通过为网站配置 Nginx 服务器来达到负载均衡的目的， Nginx 可以重写静态资源的 HTTP 头的缓存信息等，也可以用 Nginx 搭建自己的 CDN 节点（原理跟运营商 CDN 差不多，都是转发到合适的机器；只不过 CDN 是将静态资源存在运营商的机器上，Nginx 做 CDN 的话就缓存在自己的机器上）。具体选择时可通过银子的多少来判断是选 CDN 加速，还是 Nginx 搭建 CDN。</p>\n<p>综上，当 Nginx 服务器承载“CDN 加速”的功能时，可通过配置 proxy_cache 将文件缓存到本地的一个目录，缓存命中原理当与 CDN 相同；当 Nginx 服务器不充当 CDN，只是重写静态文件的响应头时，此时跟服务器写命令没差，缓存在浏览器中，原理见浏览器缓存命中机制，不再进行赘述。</p>\n<h3 id=\"五、Service-Worker-缓存\"><a href=\"#五、Service-Worker-缓存\" class=\"headerlink\" title=\"五、Service Worker 缓存\"></a>五、Service Worker 缓存</h3><p>Service Worker  是一个位于浏览器和网络之间的客户端代理，可以拦截、处理流经的 HTTP 请求，使开发者可以从缓存中向 Web 应用提供资源。可以把它看成是用户设备中的缓存提供服务器，功能十分强大。它缓存的文件同样存储在客户端（用户设备）中：</p>\n<p><img src=\"/2019/12/26/PWA-Service-Worker-小结（一）各类缓存对比/web应用缓存位置图.png\" alt=\"\" title=\"web应用缓存位置图\"></p>\n<p>Service Worker 是 PWA 实现离线应用的核心技术。它可以：</p>\n<ul>\n<li>让网页可以离线访问；</li>\n<li>让网页在弱网情况，使用缓存快速打开应用，提升体验；</li>\n<li>同时在网络正常的情况下走网络缓存减少请求的带宽； </li>\n<li>对不支持的手机没有影响；</li>\n</ul>\n<p><strong>缓存有各自的优先级，当依次查找缓存且都没有命中的时候，才会去请求网络：</strong></p>\n<ol>\n<li>Service Worker</li>\n<li>Memory Cache</li>\n<li>Disk Cache</li>\n<li>网络请求</li>\n</ol>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><ul>\n<li>《web全栈工程师的自我修养》</li>\n<li><a href=\"https://segmentfault.com/a/1190000011286027\" target=\"_blank\" rel=\"noopener\">由memoryCache和diskCache产生的浏览器缓存机制的思考</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008956069\" target=\"_blank\" rel=\"noopener\">HTTP强缓存和协商缓存</a></li>\n<li><a href=\"https://www.jianshu.com/p/b5c805f4e8d1\" target=\"_blank\" rel=\"noopener\">Etag和Last-Modified</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000019395237?utm_source=tag-newest\" target=\"_blank\" rel=\"noopener\">傻傻分不清的Manifest</a></li>\n<li><a href=\"https://blog.csdn.net/wangjun5159/article/details/79287881\" target=\"_blank\" rel=\"noopener\">定制修改gulp-rev返回的rev-manifest.json文件</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006673084\" target=\"_blank\" rel=\"noopener\">从HTTP响应头看各家CDN缓存技术</a></li>\n<li><a href=\"https://www.jianshu.com/p/e7751ecb6f21\" target=\"_blank\" rel=\"noopener\">简述回源原理和CDN常见多级缓存</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/96934736\" target=\"_blank\" rel=\"noopener\">渐进式网页应用(PWA)介绍</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>年底了，总结一下上半年探索的 PWA 的离线缓存技术。顺带总结了一下前端全流程每一步中都可能遇到的缓存，大部分都是概念、名词的理解和说明。涉及到的缓存有：HTTP 缓存、Manifest 缓存、CDN 缓存、Nginx 服务器缓存、Service Worker 缓存。</p>","more":"<p>缓存的好处：<br>存储频繁访问的数据，降低服务器压力；<br>减少网络延迟，加快页面打开速度；</p>\n<h3 id=\"一、HTTP-缓存\"><a href=\"#一、HTTP-缓存\" class=\"headerlink\" title=\"一、HTTP 缓存\"></a>一、HTTP 缓存</h3><h4 id=\"浏览器缓存机制：\"><a href=\"#浏览器缓存机制：\" class=\"headerlink\" title=\"浏览器缓存机制：\"></a><a href=\"https://www.cnblogs.com/slly/p/6732749.html\" target=\"_blank\" rel=\"noopener\">浏览器缓存机制</a>：</h4><ol>\n<li><a href=\"https://segmentfault.com/a/1190000011286027\" target=\"_blank\" rel=\"noopener\">在未设置相应头缓存字段的时候，只有用户点击“回退”按钮的时候，页面才会从缓存中读取</a>；</li>\n<li><strong>过期机制</strong>：与服务器协商获取。对于浏览器来说，如何缓存一个资源是服务器端制定的策略，服务器对每个资源的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ\" target=\"_blank\" rel=\"noopener\">HTTP 响应头设置属性和值</a>，自己只负责执行。常用的为以下几种：<ul>\n<li>Expires: 设置过期时间(单位日期)，某日期之前都不再询问；浏览器再次命中这个资源，直至XXX时间前都不会发起 HTTP 请求，而是直接从缓存（在硬盘中）读取。<ul>\n<li>如：200 (from cache) 这种缓存速度最快。</li>\n</ul>\n</li>\n<li>Last-Modified: 设置资源上次修改时间(单位日期)，每次请求命中资源，都去询问资源是否过期；通过这种缓存方式，无论资源是否发生变更，都会发生至少一来一去的 HTTP 头传输和接收，速度比不上 Expires；<ul>\n<li>如：304，若文件发生变更，则返回200。</li>\n</ul>\n</li>\n<li>Cache-Control:<ul>\n<li>max-age=<seconds> 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)；标准中规定 max-age 的值最大不能超过一年，且以秒为单位，所以值为 31536000；</seconds></li>\n<li>no-cache  字面意义“不缓存”。实际机制是对资源仍使用缓存，但每次使用前必须（MUST）向服务器对缓存资源进行验证；</li>\n<li>no-store 不使用任何缓存；</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>验证机制</strong>：服务器返回资源的时候有时会在头信息中携带 <strong>Etag（Entity Tag）</strong>，它可作为浏览器再次请求过程的校验标识。如发现校验标识不匹配，说明资源已经修改或过期，浏览器需要重新获取资源内容。<br>ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 ETag / If-None-Match 值来判断是否命中缓存。在精准度上，Etag 优于 Last-Modified。因为 Etag 是按照内容为资源增加标识，而 Last-Modified 是根据文件最后修改时间判断。<br><img src=\"/2019/12/26/PWA-Service-Worker-小结（一）各类缓存对比/协商缓存命中过程.png\" alt=\"\" title=\"协商缓存命中过程\"></li>\n</ol>\n<h4 id=\"常用的缓存策略：\"><a href=\"#常用的缓存策略：\" class=\"headerlink\" title=\"常用的缓存策略：\"></a>常用的缓存策略：</h4><ul>\n<li>对于动态生成的 HTML 页面使用 HTTP 头: Cache-Control : no-cache;</li>\n<li>对于静态 HTML 页面使用 HTTP 头: Last-Modified;</li>\n<li>其他所有文件类型都设置 Cache-Control 头，并且在文件内容有所修改都时候修改文件名。</li>\n</ul>\n<h4 id=\"如何更新文件：\"><a href=\"#如何更新文件：\" class=\"headerlink\" title=\"如何更新文件：\"></a>如何更新文件：</h4><p>按照 HTTP 规范，如果修改了请求资源的 Query String，就应该被视为一个新的文件。但是遇到运营商劫持时，会忽略 Query String，遇到这种情况只能修改文件名。</p>\n<h4 id=\"疑问：\"><a href=\"#疑问：\" class=\"headerlink\" title=\"疑问：\"></a>疑问：</h4><p>给 HTML 都设置了 Cache-Control: no-cache; 对 CSS 和 JS都用了 gulp 进行了打包编译处理，每次有变化都会变更文件名；那么此种情况下，是否还需要设置 Last-Modified？<br>直接设置 Cache-Control max-age 或者 Expires 难道不会节省更多 HTTP 请求吗？避免服务器为做出应答返回大量 304。</p>\n<h3 id=\"二、Manifest-缓存\"><a href=\"#二、Manifest-缓存\" class=\"headerlink\" title=\"二、Manifest 缓存\"></a>二、<a href=\"https://segmentfault.com/a/1190000019395237?utm_source=tag-newest\" target=\"_blank\" rel=\"noopener\">Manifest 缓存</a></h3><p>manifest 在前端含义很多，常见的四个使用场景如下：</p>\n<ol>\n<li>HTML 标签的 manifest 属性，用来离线缓存 HTML 文档以及资源的；<ul>\n<li>如 &lt;html manifest=”xxx”>&lt;/html>，由于坑太多，现在已经被废弃；</li>\n</ul>\n</li>\n<li>PWA 的 manifest 功能：将 web 应用程序安装到设备的主屏幕；<ul>\n<li>如 &lt;link rel=”manifest” href=”/manifest.json”>；</li>\n<li>在 manifest.json 中配置应用的图标、名称等信息；通过一系列配置，就可以为 Web App 添加一个图标到手机上，点击图标即可打开站点；</li>\n</ul>\n</li>\n<li>webpack 打包时会生成个 manifest.json 的文件，用来分析打包后的文件；</li>\n<li><a href=\"https://blog.csdn.net/wangjun5159/article/details/79287881\" target=\"_blank\" rel=\"noopener\">gulp 处理静态资源时，使用 gulp 的 gulp-rev 插件生成 manifest.json，用来记录源文件与处理后的目标文件的对照</a>。</li>\n</ol>\n<h3 id=\"三、CDN缓存\"><a href=\"#三、CDN缓存\" class=\"headerlink\" title=\"三、CDN缓存\"></a>三、CDN缓存</h3><p>即使为各类资源文件设置了 HTTP 头，当用户手动清除缓存 ，或者由于磁盘容量限制，先缓存的文件被挤出磁盘，此时依旧需要请求资源，为了快速响应用户请求，使用 CDN 加速。CDN的分流作用不仅减少了用户的访问延时，也减少了源站的负载。<br>当用户手动清理本地缓存后，将去请求距离最近的 CDN 边缘节点。<br>CDN 边缘节点缓存策略因服务商不同而不同，但一般会遵循 HTTP 标准协议。通过 HTTP 响应头中的 Cache-Control: max-age 的字段来设置CDN边缘节点数据缓存时间，若数据失效，则向源站发出回源请求，拉取最新的数据；当源站内容有更新的时候，源站主动把内容推到CDN节点。</p>\n<p>各家 CDN 缓存参考：<a href=\"https://segmentfault.com/a/1190000006673084\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000006673084</a></p>\n<p>CDN 回源原理：<a href=\"https://www.jianshu.com/p/e7751ecb6f21\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/e7751ecb6f21</a></p>\n<h3 id=\"四、nginx-服务器缓存\"><a href=\"#四、nginx-服务器缓存\" class=\"headerlink\" title=\"四、nginx 服务器缓存\"></a>四、nginx 服务器缓存</h3><p><del>这里又牵扯到了两个地方…就像家用路由器和企业级路由器虽然都叫路由器但是功能完全不一样…</del><br>nginx 大名 负载均衡服务器，它是服务器不是服务；CDN 加速是运营商提供的一种服务….，这俩玩意一点关系都没有。如果网站既使用了 CDN 加速，同时又使用了 Nginx 代理，那么 CDN 的位置相比于 Nginx 服务器更靠近用户。</p>\n<p><img src=\"/2019/12/26/PWA-Service-Worker-小结（一）各类缓存对比/CDN&amp;&amp;Nginx.jpg\" alt=\"\" title=\"CDN &amp;&amp; Nginx\"></p>\n<p>网站管理者可以通过为网站配置 Nginx 服务器来达到负载均衡的目的， Nginx 可以重写静态资源的 HTTP 头的缓存信息等，也可以用 Nginx 搭建自己的 CDN 节点（原理跟运营商 CDN 差不多，都是转发到合适的机器；只不过 CDN 是将静态资源存在运营商的机器上，Nginx 做 CDN 的话就缓存在自己的机器上）。具体选择时可通过银子的多少来判断是选 CDN 加速，还是 Nginx 搭建 CDN。</p>\n<p>综上，当 Nginx 服务器承载“CDN 加速”的功能时，可通过配置 proxy_cache 将文件缓存到本地的一个目录，缓存命中原理当与 CDN 相同；当 Nginx 服务器不充当 CDN，只是重写静态文件的响应头时，此时跟服务器写命令没差，缓存在浏览器中，原理见浏览器缓存命中机制，不再进行赘述。</p>\n<h3 id=\"五、Service-Worker-缓存\"><a href=\"#五、Service-Worker-缓存\" class=\"headerlink\" title=\"五、Service Worker 缓存\"></a>五、Service Worker 缓存</h3><p>Service Worker  是一个位于浏览器和网络之间的客户端代理，可以拦截、处理流经的 HTTP 请求，使开发者可以从缓存中向 Web 应用提供资源。可以把它看成是用户设备中的缓存提供服务器，功能十分强大。它缓存的文件同样存储在客户端（用户设备）中：</p>\n<p><img src=\"/2019/12/26/PWA-Service-Worker-小结（一）各类缓存对比/web应用缓存位置图.png\" alt=\"\" title=\"web应用缓存位置图\"></p>\n<p>Service Worker 是 PWA 实现离线应用的核心技术。它可以：</p>\n<ul>\n<li>让网页可以离线访问；</li>\n<li>让网页在弱网情况，使用缓存快速打开应用，提升体验；</li>\n<li>同时在网络正常的情况下走网络缓存减少请求的带宽； </li>\n<li>对不支持的手机没有影响；</li>\n</ul>\n<p><strong>缓存有各自的优先级，当依次查找缓存且都没有命中的时候，才会去请求网络：</strong></p>\n<ol>\n<li>Service Worker</li>\n<li>Memory Cache</li>\n<li>Disk Cache</li>\n<li>网络请求</li>\n</ol>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><ul>\n<li>《web全栈工程师的自我修养》</li>\n<li><a href=\"https://segmentfault.com/a/1190000011286027\" target=\"_blank\" rel=\"noopener\">由memoryCache和diskCache产生的浏览器缓存机制的思考</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008956069\" target=\"_blank\" rel=\"noopener\">HTTP强缓存和协商缓存</a></li>\n<li><a href=\"https://www.jianshu.com/p/b5c805f4e8d1\" target=\"_blank\" rel=\"noopener\">Etag和Last-Modified</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000019395237?utm_source=tag-newest\" target=\"_blank\" rel=\"noopener\">傻傻分不清的Manifest</a></li>\n<li><a href=\"https://blog.csdn.net/wangjun5159/article/details/79287881\" target=\"_blank\" rel=\"noopener\">定制修改gulp-rev返回的rev-manifest.json文件</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000006673084\" target=\"_blank\" rel=\"noopener\">从HTTP响应头看各家CDN缓存技术</a></li>\n<li><a href=\"https://www.jianshu.com/p/e7751ecb6f21\" target=\"_blank\" rel=\"noopener\">简述回源原理和CDN常见多级缓存</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/96934736\" target=\"_blank\" rel=\"noopener\">渐进式网页应用(PWA)介绍</a></li>\n</ul>"},{"title":"z-index小结","date":"2019-08-05T08:36:13.000Z","_content":"z-index 这东西简单的用法大家都会用，但是当多个规则多个层级共同作用时，展现的效果往往跟自己的想法有很大差异，论 CSS 基本功的重要性。本文总结了 CSS 层叠的特性、基本准则和创建条件，内容大多参考了张鑫旭大神的《CSS世界》。\n<!--more-->\n\n### 层叠的基本概念\n* 层叠上下文(stacking context)：当前元素所处的层叠规则，即元素所处的 z 轴。一个页面中，层叠上下文不止一个。\n* 层叠水平(stacking level)：同一个层叠上下文中元 素在 z 轴上的显示等级。\n* 层叠顺序(stacking order)：\n  * background/border 指在同一层叠上下文元素的边框和背景色。\n  * inline水平盒子指的是包括inline/inline-block/inline-table元素的“层叠顺序”，它们都是同等级别的。\n  * 内联元素的层叠顺序要比浮动元素和块状元素都高，是因为float元素在起始时是作为布局元素存在的。由于“内容”的重要性远大于“装饰”和“布局”，所以内容元素层叠顺序比较高，详情见下图：\n![层叠顺序图](/stacking-order.png)\n\n### z-index\n__z-index 属性只有和定位元素(position 不为 static 的元素)在一起的时候才有作用，可以是正数也可以是负数。在同一层叠上下文中，数值越大层级越高。__ 在CSS3中，z-index 已经并非只对定位元素有效，flex 盒子的子元素 也可以设置 z-index 属性。\n\n#### 层叠准则\n1. 谁大谁上：在同一个层叠上下文领域，具有明显的层叠水平标识的时候，层叠水平值大的那一个覆盖小的那一个，例如 z-index 属性值。\n2. 后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。\n\n#### 层叠上下文的特性\n* 层叠上下文的层叠水平要比普通元素高。\n* 层叠上下文可以阻断元素的混合模式。\n* 层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。\n* 每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。\n* 每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。\n\n#### 页面中的层叠上下文\n* __根层叠上下文__：页面根元素具</html>有层叠上下文，称为“根层叠上下文”。故页面中所有的元素至少处于一个层叠上下文中。\n* __定位元素与传统层叠上下文__：对于 position 值为 relative/absolute 以及 Firefox/IE 浏览器(不包括 Chrome 浏览 器)下含有 position:fixed 声明的定位元素，当其 z-index 值不是 auto 的时候，会创建层叠上下文(__z-index 一旦变成数值，即使是 0，也创建一个层叠上下文__)。\n* __CSS3新属性的层叠上下文__：\n  * 元素为 flex 布局元素(父元素 display:flex|inline-flex)，同时 z-index 值不是 auto。\n  * 元素的 opacity 值不是 1\n  * 元素的 transform 值不是 none。\n  * 元素 mix-blend-mode 值不是 normal。\n  * 元素的 filter 值不是 none。\n  * 元素的 isolation 值是 isolate。\n  * 元素的 will-change 属性值为上面 2~6 的任意一个(如 will-change:opacity、will-chang:transform 等)。\n  * 元素的-webkit-overflow-scrolling 设为 touch。\n\n#### CSS3 属性与 z-index 的兼容性问题\n1. Safari 3D变换会忽略 z-index[(解决方案)](https://blog.csdn.net/sherry_0706/article/details/52593888)","source":"_posts/z-index小结.md","raw":"---\ntitle: z-index小结\ndate: 2019-08-05 16:36:13\ntags: [CSS]\ncategories: [前端, CSS]\n---\nz-index 这东西简单的用法大家都会用，但是当多个规则多个层级共同作用时，展现的效果往往跟自己的想法有很大差异，论 CSS 基本功的重要性。本文总结了 CSS 层叠的特性、基本准则和创建条件，内容大多参考了张鑫旭大神的《CSS世界》。\n<!--more-->\n\n### 层叠的基本概念\n* 层叠上下文(stacking context)：当前元素所处的层叠规则，即元素所处的 z 轴。一个页面中，层叠上下文不止一个。\n* 层叠水平(stacking level)：同一个层叠上下文中元 素在 z 轴上的显示等级。\n* 层叠顺序(stacking order)：\n  * background/border 指在同一层叠上下文元素的边框和背景色。\n  * inline水平盒子指的是包括inline/inline-block/inline-table元素的“层叠顺序”，它们都是同等级别的。\n  * 内联元素的层叠顺序要比浮动元素和块状元素都高，是因为float元素在起始时是作为布局元素存在的。由于“内容”的重要性远大于“装饰”和“布局”，所以内容元素层叠顺序比较高，详情见下图：\n![层叠顺序图](/stacking-order.png)\n\n### z-index\n__z-index 属性只有和定位元素(position 不为 static 的元素)在一起的时候才有作用，可以是正数也可以是负数。在同一层叠上下文中，数值越大层级越高。__ 在CSS3中，z-index 已经并非只对定位元素有效，flex 盒子的子元素 也可以设置 z-index 属性。\n\n#### 层叠准则\n1. 谁大谁上：在同一个层叠上下文领域，具有明显的层叠水平标识的时候，层叠水平值大的那一个覆盖小的那一个，例如 z-index 属性值。\n2. 后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。\n\n#### 层叠上下文的特性\n* 层叠上下文的层叠水平要比普通元素高。\n* 层叠上下文可以阻断元素的混合模式。\n* 层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。\n* 每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。\n* 每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。\n\n#### 页面中的层叠上下文\n* __根层叠上下文__：页面根元素具</html>有层叠上下文，称为“根层叠上下文”。故页面中所有的元素至少处于一个层叠上下文中。\n* __定位元素与传统层叠上下文__：对于 position 值为 relative/absolute 以及 Firefox/IE 浏览器(不包括 Chrome 浏览 器)下含有 position:fixed 声明的定位元素，当其 z-index 值不是 auto 的时候，会创建层叠上下文(__z-index 一旦变成数值，即使是 0，也创建一个层叠上下文__)。\n* __CSS3新属性的层叠上下文__：\n  * 元素为 flex 布局元素(父元素 display:flex|inline-flex)，同时 z-index 值不是 auto。\n  * 元素的 opacity 值不是 1\n  * 元素的 transform 值不是 none。\n  * 元素 mix-blend-mode 值不是 normal。\n  * 元素的 filter 值不是 none。\n  * 元素的 isolation 值是 isolate。\n  * 元素的 will-change 属性值为上面 2~6 的任意一个(如 will-change:opacity、will-chang:transform 等)。\n  * 元素的-webkit-overflow-scrolling 设为 touch。\n\n#### CSS3 属性与 z-index 的兼容性问题\n1. Safari 3D变换会忽略 z-index[(解决方案)](https://blog.csdn.net/sherry_0706/article/details/52593888)","slug":"z-index小结","published":1,"updated":"2020-11-04T08:29:30.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0t000n7vvuxdgvssz3","content":"<p>z-index 这东西简单的用法大家都会用，但是当多个规则多个层级共同作用时，展现的效果往往跟自己的想法有很大差异，论 CSS 基本功的重要性。本文总结了 CSS 层叠的特性、基本准则和创建条件，内容大多参考了张鑫旭大神的《CSS世界》。<br><a id=\"more\"></a></p>\n<h3 id=\"层叠的基本概念\"><a href=\"#层叠的基本概念\" class=\"headerlink\" title=\"层叠的基本概念\"></a>层叠的基本概念</h3><ul>\n<li>层叠上下文(stacking context)：当前元素所处的层叠规则，即元素所处的 z 轴。一个页面中，层叠上下文不止一个。</li>\n<li>层叠水平(stacking level)：同一个层叠上下文中元 素在 z 轴上的显示等级。</li>\n<li>层叠顺序(stacking order)：<ul>\n<li>background/border 指在同一层叠上下文元素的边框和背景色。</li>\n<li>inline水平盒子指的是包括inline/inline-block/inline-table元素的“层叠顺序”，它们都是同等级别的。</li>\n<li>内联元素的层叠顺序要比浮动元素和块状元素都高，是因为float元素在起始时是作为布局元素存在的。由于“内容”的重要性远大于“装饰”和“布局”，所以内容元素层叠顺序比较高，详情见下图：<br><img src=\"/2019/08/05/z-index小结/stacking-order.png\" alt=\"层叠顺序图\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"z-index\"><a href=\"#z-index\" class=\"headerlink\" title=\"z-index\"></a>z-index</h3><p><strong>z-index 属性只有和定位元素(position 不为 static 的元素)在一起的时候才有作用，可以是正数也可以是负数。在同一层叠上下文中，数值越大层级越高。</strong> 在CSS3中，z-index 已经并非只对定位元素有效，flex 盒子的子元素 也可以设置 z-index 属性。</p>\n<h4 id=\"层叠准则\"><a href=\"#层叠准则\" class=\"headerlink\" title=\"层叠准则\"></a>层叠准则</h4><ol>\n<li>谁大谁上：在同一个层叠上下文领域，具有明显的层叠水平标识的时候，层叠水平值大的那一个覆盖小的那一个，例如 z-index 属性值。</li>\n<li>后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。</li>\n</ol>\n<h4 id=\"层叠上下文的特性\"><a href=\"#层叠上下文的特性\" class=\"headerlink\" title=\"层叠上下文的特性\"></a>层叠上下文的特性</h4><ul>\n<li>层叠上下文的层叠水平要比普通元素高。</li>\n<li>层叠上下文可以阻断元素的混合模式。</li>\n<li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。</li>\n<li>每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。</li>\n<li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</li>\n</ul>\n<h4 id=\"页面中的层叠上下文\"><a href=\"#页面中的层叠上下文\" class=\"headerlink\" title=\"页面中的层叠上下文\"></a>页面中的层叠上下文</h4><ul>\n<li><strong>根层叠上下文</strong>：页面根元素具有层叠上下文，称为“根层叠上下文”。故页面中所有的元素至少处于一个层叠上下文中。</li>\n<li><strong>定位元素与传统层叠上下文</strong>：对于 position 值为 relative/absolute 以及 Firefox/IE 浏览器(不包括 Chrome 浏览 器)下含有 position:fixed 声明的定位元素，当其 z-index 值不是 auto 的时候，会创建层叠上下文(<strong>z-index 一旦变成数值，即使是 0，也创建一个层叠上下文</strong>)。</li>\n<li><strong>CSS3新属性的层叠上下文</strong>：<ul>\n<li>元素为 flex 布局元素(父元素 display:flex|inline-flex)，同时 z-index 值不是 auto。</li>\n<li>元素的 opacity 值不是 1</li>\n<li>元素的 transform 值不是 none。</li>\n<li>元素 mix-blend-mode 值不是 normal。</li>\n<li>元素的 filter 值不是 none。</li>\n<li>元素的 isolation 值是 isolate。</li>\n<li>元素的 will-change 属性值为上面 2~6 的任意一个(如 will-change:opacity、will-chang:transform 等)。</li>\n<li>元素的-webkit-overflow-scrolling 设为 touch。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"CSS3-属性与-z-index-的兼容性问题\"><a href=\"#CSS3-属性与-z-index-的兼容性问题\" class=\"headerlink\" title=\"CSS3 属性与 z-index 的兼容性问题\"></a>CSS3 属性与 z-index 的兼容性问题</h4><ol>\n<li>Safari 3D变换会忽略 z-index<a href=\"https://blog.csdn.net/sherry_0706/article/details/52593888\" target=\"_blank\" rel=\"noopener\">(解决方案)</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>z-index 这东西简单的用法大家都会用，但是当多个规则多个层级共同作用时，展现的效果往往跟自己的想法有很大差异，论 CSS 基本功的重要性。本文总结了 CSS 层叠的特性、基本准则和创建条件，内容大多参考了张鑫旭大神的《CSS世界》。<br></p>","more":"<p></p>\n<h3 id=\"层叠的基本概念\"><a href=\"#层叠的基本概念\" class=\"headerlink\" title=\"层叠的基本概念\"></a>层叠的基本概念</h3><ul>\n<li>层叠上下文(stacking context)：当前元素所处的层叠规则，即元素所处的 z 轴。一个页面中，层叠上下文不止一个。</li>\n<li>层叠水平(stacking level)：同一个层叠上下文中元 素在 z 轴上的显示等级。</li>\n<li>层叠顺序(stacking order)：<ul>\n<li>background/border 指在同一层叠上下文元素的边框和背景色。</li>\n<li>inline水平盒子指的是包括inline/inline-block/inline-table元素的“层叠顺序”，它们都是同等级别的。</li>\n<li>内联元素的层叠顺序要比浮动元素和块状元素都高，是因为float元素在起始时是作为布局元素存在的。由于“内容”的重要性远大于“装饰”和“布局”，所以内容元素层叠顺序比较高，详情见下图：<br><img src=\"/2019/08/05/z-index小结/stacking-order.png\" alt=\"层叠顺序图\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"z-index\"><a href=\"#z-index\" class=\"headerlink\" title=\"z-index\"></a>z-index</h3><p><strong>z-index 属性只有和定位元素(position 不为 static 的元素)在一起的时候才有作用，可以是正数也可以是负数。在同一层叠上下文中，数值越大层级越高。</strong> 在CSS3中，z-index 已经并非只对定位元素有效，flex 盒子的子元素 也可以设置 z-index 属性。</p>\n<h4 id=\"层叠准则\"><a href=\"#层叠准则\" class=\"headerlink\" title=\"层叠准则\"></a>层叠准则</h4><ol>\n<li>谁大谁上：在同一个层叠上下文领域，具有明显的层叠水平标识的时候，层叠水平值大的那一个覆盖小的那一个，例如 z-index 属性值。</li>\n<li>后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。</li>\n</ol>\n<h4 id=\"层叠上下文的特性\"><a href=\"#层叠上下文的特性\" class=\"headerlink\" title=\"层叠上下文的特性\"></a>层叠上下文的特性</h4><ul>\n<li>层叠上下文的层叠水平要比普通元素高。</li>\n<li>层叠上下文可以阻断元素的混合模式。</li>\n<li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。</li>\n<li>每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。</li>\n<li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</li>\n</ul>\n<h4 id=\"页面中的层叠上下文\"><a href=\"#页面中的层叠上下文\" class=\"headerlink\" title=\"页面中的层叠上下文\"></a>页面中的层叠上下文</h4><ul>\n<li><strong>根层叠上下文</strong>：页面根元素具有层叠上下文，称为“根层叠上下文”。故页面中所有的元素至少处于一个层叠上下文中。</li>\n<li><strong>定位元素与传统层叠上下文</strong>：对于 position 值为 relative/absolute 以及 Firefox/IE 浏览器(不包括 Chrome 浏览 器)下含有 position:fixed 声明的定位元素，当其 z-index 值不是 auto 的时候，会创建层叠上下文(<strong>z-index 一旦变成数值，即使是 0，也创建一个层叠上下文</strong>)。</li>\n<li><strong>CSS3新属性的层叠上下文</strong>：<ul>\n<li>元素为 flex 布局元素(父元素 display:flex|inline-flex)，同时 z-index 值不是 auto。</li>\n<li>元素的 opacity 值不是 1</li>\n<li>元素的 transform 值不是 none。</li>\n<li>元素 mix-blend-mode 值不是 normal。</li>\n<li>元素的 filter 值不是 none。</li>\n<li>元素的 isolation 值是 isolate。</li>\n<li>元素的 will-change 属性值为上面 2~6 的任意一个(如 will-change:opacity、will-chang:transform 等)。</li>\n<li>元素的-webkit-overflow-scrolling 设为 touch。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"CSS3-属性与-z-index-的兼容性问题\"><a href=\"#CSS3-属性与-z-index-的兼容性问题\" class=\"headerlink\" title=\"CSS3 属性与 z-index 的兼容性问题\"></a>CSS3 属性与 z-index 的兼容性问题</h4><ol>\n<li>Safari 3D变换会忽略 z-index<a href=\"https://blog.csdn.net/sherry_0706/article/details/52593888\" target=\"_blank\" rel=\"noopener\">(解决方案)</a></li>\n</ol>"},{"title":"《看见》-柴静","date":"2018-09-07T07:19:14.000Z","_content":"无意间逛知乎的时候发现的书籍片段，留下了很深的印象。从记者的视角看到平日里生活中接触不到的社会另一面，别有一番感触。不愧是著名记者，文笔犀利，干练不拖沓。值得一读的好书：★★★★★\n<!--more-->\n### 第二章 那个温热的跳动就是活着\n我对非典的印象还是停留在小学时候，有那么一段时间，教室里每天清晨和下午都要喷洒消毒水，学校的走廊里弥漫着一股医院的味道。那时还小，只知道这是在预防“非典”，但它到底是什么，我并不知道。\n> 这就是我之前听说的天井。四周楼群间的一块空地，一 个楼与楼之间的天井，加个盖，就成了个完全封闭的空间， 成了输液室，发热的病人都集中到这里来输液。二十七张床 几乎完全挨在一起，中间只有一只拳头的距离。白天也完全靠灯光，没有通风，没有窗，只有一个中央空调的排气口， 这个排气口把病菌传到各处。\n> 病历胡乱地堆在桌上，像小山一样，已经发黄发脆。我 犹豫了一秒钟。朱继红几乎是凄然地一笑，说:“我来吧。” 病例被翻开，上面写的都是“肺炎”。他指给我看墙上的黑 板，上面写了二十二个人的名字，其中十九个后面都用白粉 笔写着:肺炎、肺炎、肺炎......\n> “实际上都是 SARS。”他说。\n\n> 一个卫生系统的官员在这里感染，回家又把妻子儿子感染了，想尽办法要住院，只能找到一个床位，夫妇俩让儿子住了进去。两口子发烧得浑身透湿，站不住，只能顫抖着坐在 小板凳上输液。再后来连板凳都坐不住了。孩子痊愈的时候， 父母已经去世。\n\n明明只是在描述，却让人觉得无比震撼。","source":"_posts/《看见》-柴静.md","raw":"---\ntitle: 《看见》-柴静 \ndate: 2018-09-07 15:19:14\ntags: 读书小结\ncategories: 闲暇读物\n---\n无意间逛知乎的时候发现的书籍片段，留下了很深的印象。从记者的视角看到平日里生活中接触不到的社会另一面，别有一番感触。不愧是著名记者，文笔犀利，干练不拖沓。值得一读的好书：★★★★★\n<!--more-->\n### 第二章 那个温热的跳动就是活着\n我对非典的印象还是停留在小学时候，有那么一段时间，教室里每天清晨和下午都要喷洒消毒水，学校的走廊里弥漫着一股医院的味道。那时还小，只知道这是在预防“非典”，但它到底是什么，我并不知道。\n> 这就是我之前听说的天井。四周楼群间的一块空地，一 个楼与楼之间的天井，加个盖，就成了个完全封闭的空间， 成了输液室，发热的病人都集中到这里来输液。二十七张床 几乎完全挨在一起，中间只有一只拳头的距离。白天也完全靠灯光，没有通风，没有窗，只有一个中央空调的排气口， 这个排气口把病菌传到各处。\n> 病历胡乱地堆在桌上，像小山一样，已经发黄发脆。我 犹豫了一秒钟。朱继红几乎是凄然地一笑，说:“我来吧。” 病例被翻开，上面写的都是“肺炎”。他指给我看墙上的黑 板，上面写了二十二个人的名字，其中十九个后面都用白粉 笔写着:肺炎、肺炎、肺炎......\n> “实际上都是 SARS。”他说。\n\n> 一个卫生系统的官员在这里感染，回家又把妻子儿子感染了，想尽办法要住院，只能找到一个床位，夫妇俩让儿子住了进去。两口子发烧得浑身透湿，站不住，只能顫抖着坐在 小板凳上输液。再后来连板凳都坐不住了。孩子痊愈的时候， 父母已经去世。\n\n明明只是在描述，却让人觉得无比震撼。","slug":"《看见》-柴静","published":1,"updated":"2020-11-04T08:29:30.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0v000q7vvuauomikgq","content":"<p>无意间逛知乎的时候发现的书籍片段，留下了很深的印象。从记者的视角看到平日里生活中接触不到的社会另一面，别有一番感触。不愧是著名记者，文笔犀利，干练不拖沓。值得一读的好书：★★★★★<br><a id=\"more\"></a></p>\n<h3 id=\"第二章-那个温热的跳动就是活着\"><a href=\"#第二章-那个温热的跳动就是活着\" class=\"headerlink\" title=\"第二章 那个温热的跳动就是活着\"></a>第二章 那个温热的跳动就是活着</h3><p>我对非典的印象还是停留在小学时候，有那么一段时间，教室里每天清晨和下午都要喷洒消毒水，学校的走廊里弥漫着一股医院的味道。那时还小，只知道这是在预防“非典”，但它到底是什么，我并不知道。</p>\n<blockquote>\n<p>这就是我之前听说的天井。四周楼群间的一块空地，一 个楼与楼之间的天井，加个盖，就成了个完全封闭的空间， 成了输液室，发热的病人都集中到这里来输液。二十七张床 几乎完全挨在一起，中间只有一只拳头的距离。白天也完全靠灯光，没有通风，没有窗，只有一个中央空调的排气口， 这个排气口把病菌传到各处。<br>病历胡乱地堆在桌上，像小山一样，已经发黄发脆。我 犹豫了一秒钟。朱继红几乎是凄然地一笑，说:“我来吧。” 病例被翻开，上面写的都是“肺炎”。他指给我看墙上的黑 板，上面写了二十二个人的名字，其中十九个后面都用白粉 笔写着:肺炎、肺炎、肺炎……<br>“实际上都是 SARS。”他说。</p>\n</blockquote>\n<blockquote>\n<p>一个卫生系统的官员在这里感染，回家又把妻子儿子感染了，想尽办法要住院，只能找到一个床位，夫妇俩让儿子住了进去。两口子发烧得浑身透湿，站不住，只能顫抖着坐在 小板凳上输液。再后来连板凳都坐不住了。孩子痊愈的时候， 父母已经去世。</p>\n</blockquote>\n<p>明明只是在描述，却让人觉得无比震撼。</p>\n","site":{"data":{}},"excerpt":"<p>无意间逛知乎的时候发现的书籍片段，留下了很深的印象。从记者的视角看到平日里生活中接触不到的社会另一面，别有一番感触。不愧是著名记者，文笔犀利，干练不拖沓。值得一读的好书：★★★★★<br></p>","more":"<p></p>\n<h3 id=\"第二章-那个温热的跳动就是活着\"><a href=\"#第二章-那个温热的跳动就是活着\" class=\"headerlink\" title=\"第二章 那个温热的跳动就是活着\"></a>第二章 那个温热的跳动就是活着</h3><p>我对非典的印象还是停留在小学时候，有那么一段时间，教室里每天清晨和下午都要喷洒消毒水，学校的走廊里弥漫着一股医院的味道。那时还小，只知道这是在预防“非典”，但它到底是什么，我并不知道。</p>\n<blockquote>\n<p>这就是我之前听说的天井。四周楼群间的一块空地，一 个楼与楼之间的天井，加个盖，就成了个完全封闭的空间， 成了输液室，发热的病人都集中到这里来输液。二十七张床 几乎完全挨在一起，中间只有一只拳头的距离。白天也完全靠灯光，没有通风，没有窗，只有一个中央空调的排气口， 这个排气口把病菌传到各处。<br>病历胡乱地堆在桌上，像小山一样，已经发黄发脆。我 犹豫了一秒钟。朱继红几乎是凄然地一笑，说:“我来吧。” 病例被翻开，上面写的都是“肺炎”。他指给我看墙上的黑 板，上面写了二十二个人的名字，其中十九个后面都用白粉 笔写着:肺炎、肺炎、肺炎……<br>“实际上都是 SARS。”他说。</p>\n</blockquote>\n<blockquote>\n<p>一个卫生系统的官员在这里感染，回家又把妻子儿子感染了，想尽办法要住院，只能找到一个床位，夫妇俩让儿子住了进去。两口子发烧得浑身透湿，站不住，只能顫抖着坐在 小板凳上输液。再后来连板凳都坐不住了。孩子痊愈的时候， 父母已经去世。</p>\n</blockquote>\n<p>明明只是在描述，却让人觉得无比震撼。</p>"},{"title":"《计算机网络》- http 部分读书笔记","date":"2019-10-22T09:06:19.000Z","_content":"《计算机网络(第7版)-谢希仁》http 部分的读书小结和扩展，因为工作中最常打交道的就是这部分了。整本书都很不错，语言通俗易懂；各协议的关系、发展过程以及区别都概括的很好。\n本文主要概括 HTTP、HTTP1.0、HTTP2.0、HTTPS 的之间的差异。\n<!--more-->\n### 万维网WWW\n万维网(World Wide Web)是一个分布式的超媒体系统，是超文本系统的扩充。万维网使用 __统一资源定位符URL(Uniform Resource Locator)__ 来标志万维网上的各种文档。\n#### URL 的格式\nURL 的一般形式由以下四个部分组成：\n&nbsp;&nbsp;&nbsp;&nbsp; `<协议>://<主机>:<端口>/<路径>`\nURL 的<协议>就是指出使用什么协议来获取万维网文档。现在最常用的协议就是 http，其次是 ftp。有些浏览器为方便用户，在输入 URL 时，可以把最前面的“http://”甚至把主机名最前面的“www”省略，然后浏览器替用户把省略的字补上。\n__URL里面的字母不分大小写，但是为了便于阅读，有时故意使用一些大写字母。__\n#### 超文本传送协议 HTTP\nHTTP(HyperText Transfer Protocol，超文本传输协议)，使用了面向连接的 TCP 作为传输层协议，监听 80 端口，信息是明文传输，其本身是无状态的。\n* HTTP1.0 :(1996) 每次请求都会单独建立一个TCP连接，用完关闭；（缺点：每次请求都耗费时间在连接上，__非持续连接__ 使服务器开销很重）。\n* HTTP1.1 :(1999) 在服务器发送完响应后仍在一段时间内保持这条连接，浏览器和该服务器可以继续在该连接上传送后续的请求报文和响应报文，使用 __持续连接__ 。\n* HTTP2.0 :(2015) 使用了新的二进制格式、多路复用、以及 header 压缩，性能相对于 HTTP1.x 提升明显。改善了在 Http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞；基于 HTTPS，天生具有安全性，可以避免单纯使用 HTTPS 带来的性能下降。\n\n#### 影响 HTTP 网络请求的因素\n影响因素主要有两个：带宽和延迟。\n* __带宽__：在浏览器刚流行的时候，大部分用户是通过拨号来上网，由于受当时的带宽条件的限制，无法使得用户的同时多个请求被处理。同时，当时的服务器的配置也比现在差很多，所以限制每个浏览器的连接数的大小也是有必要的。浏览器默认对同一域下的资源，只保持一定的连接数，阻塞过多的连接,以提高访问速度和解决阻塞问题。不同浏览器的默认值不一样，对于不同的 HTTP 协议其值也不一样。\n\n| 浏览器 | HTTP 1.1 | HTTP 1.0 |\n| :-: | :-: | :-: | \n| IE 6、7 | 2| 4 | \n| IE 8 | 6 | 6 | \n| FireFox 2 | 2 | 8 |\n| FireFox 3 | 6 | 6 | \n| Safari 3、4 | 4 | 4 | \n\n如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。\n\n* __延迟__：\n  * 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制（见上表），后续请求就会被阻塞。\n  * DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。\n  * 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。\n\n#### 应用层安全协议 HTTPS\nHTTPS 是使用 SSL(Secure Socket Layer，安全套接字层)协议的 HTTP 协议。SSL 作用在 HTTP 和运输层之间，在 TCP 之上建立起一个安全通道，为通过 TCP 传输的应用层数据提供安全保障。\nHTTPS 监听 TCP 的 443 端口，信息是密文传输。","source":"_posts/《计算机网络》-http-部分读书笔记.md","raw":"---\ntitle: 《计算机网络》- http 部分读书笔记\ndate: 2019-10-22 17:06:19\ntags: [计算机网络]\ncategories: 计算机相关知识\n---\n《计算机网络(第7版)-谢希仁》http 部分的读书小结和扩展，因为工作中最常打交道的就是这部分了。整本书都很不错，语言通俗易懂；各协议的关系、发展过程以及区别都概括的很好。\n本文主要概括 HTTP、HTTP1.0、HTTP2.0、HTTPS 的之间的差异。\n<!--more-->\n### 万维网WWW\n万维网(World Wide Web)是一个分布式的超媒体系统，是超文本系统的扩充。万维网使用 __统一资源定位符URL(Uniform Resource Locator)__ 来标志万维网上的各种文档。\n#### URL 的格式\nURL 的一般形式由以下四个部分组成：\n&nbsp;&nbsp;&nbsp;&nbsp; `<协议>://<主机>:<端口>/<路径>`\nURL 的<协议>就是指出使用什么协议来获取万维网文档。现在最常用的协议就是 http，其次是 ftp。有些浏览器为方便用户，在输入 URL 时，可以把最前面的“http://”甚至把主机名最前面的“www”省略，然后浏览器替用户把省略的字补上。\n__URL里面的字母不分大小写，但是为了便于阅读，有时故意使用一些大写字母。__\n#### 超文本传送协议 HTTP\nHTTP(HyperText Transfer Protocol，超文本传输协议)，使用了面向连接的 TCP 作为传输层协议，监听 80 端口，信息是明文传输，其本身是无状态的。\n* HTTP1.0 :(1996) 每次请求都会单独建立一个TCP连接，用完关闭；（缺点：每次请求都耗费时间在连接上，__非持续连接__ 使服务器开销很重）。\n* HTTP1.1 :(1999) 在服务器发送完响应后仍在一段时间内保持这条连接，浏览器和该服务器可以继续在该连接上传送后续的请求报文和响应报文，使用 __持续连接__ 。\n* HTTP2.0 :(2015) 使用了新的二进制格式、多路复用、以及 header 压缩，性能相对于 HTTP1.x 提升明显。改善了在 Http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞；基于 HTTPS，天生具有安全性，可以避免单纯使用 HTTPS 带来的性能下降。\n\n#### 影响 HTTP 网络请求的因素\n影响因素主要有两个：带宽和延迟。\n* __带宽__：在浏览器刚流行的时候，大部分用户是通过拨号来上网，由于受当时的带宽条件的限制，无法使得用户的同时多个请求被处理。同时，当时的服务器的配置也比现在差很多，所以限制每个浏览器的连接数的大小也是有必要的。浏览器默认对同一域下的资源，只保持一定的连接数，阻塞过多的连接,以提高访问速度和解决阻塞问题。不同浏览器的默认值不一样，对于不同的 HTTP 协议其值也不一样。\n\n| 浏览器 | HTTP 1.1 | HTTP 1.0 |\n| :-: | :-: | :-: | \n| IE 6、7 | 2| 4 | \n| IE 8 | 6 | 6 | \n| FireFox 2 | 2 | 8 |\n| FireFox 3 | 6 | 6 | \n| Safari 3、4 | 4 | 4 | \n\n如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。\n\n* __延迟__：\n  * 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制（见上表），后续请求就会被阻塞。\n  * DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。\n  * 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。\n\n#### 应用层安全协议 HTTPS\nHTTPS 是使用 SSL(Secure Socket Layer，安全套接字层)协议的 HTTP 协议。SSL 作用在 HTTP 和运输层之间，在 TCP 之上建立起一个安全通道，为通过 TCP 传输的应用层数据提供安全保障。\nHTTPS 监听 TCP 的 443 端口，信息是密文传输。","slug":"《计算机网络》-http-部分读书笔记","published":1,"updated":"2020-11-04T08:29:30.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0w000s7vvuaz3i3c1l","content":"<p>《计算机网络(第7版)-谢希仁》http 部分的读书小结和扩展，因为工作中最常打交道的就是这部分了。整本书都很不错，语言通俗易懂；各协议的关系、发展过程以及区别都概括的很好。<br>本文主要概括 HTTP、HTTP1.0、HTTP2.0、HTTPS 的之间的差异。<br><a id=\"more\"></a></p>\n<h3 id=\"万维网WWW\"><a href=\"#万维网WWW\" class=\"headerlink\" title=\"万维网WWW\"></a>万维网WWW</h3><p>万维网(World Wide Web)是一个分布式的超媒体系统，是超文本系统的扩充。万维网使用 <strong>统一资源定位符URL(Uniform Resource Locator)</strong> 来标志万维网上的各种文档。</p>\n<h4 id=\"URL-的格式\"><a href=\"#URL-的格式\" class=\"headerlink\" title=\"URL 的格式\"></a>URL 的格式</h4><p>URL 的一般形式由以下四个部分组成：<br>&nbsp;&nbsp;&nbsp;&nbsp; <code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code><br>URL 的&lt;协议&gt;就是指出使用什么协议来获取万维网文档。现在最常用的协议就是 http，其次是 ftp。有些浏览器为方便用户，在输入 URL 时，可以把最前面的“http://”甚至把主机名最前面的“www”省略，然后浏览器替用户把省略的字补上。<br><strong>URL里面的字母不分大小写，但是为了便于阅读，有时故意使用一些大写字母。</strong></p>\n<h4 id=\"超文本传送协议-HTTP\"><a href=\"#超文本传送协议-HTTP\" class=\"headerlink\" title=\"超文本传送协议 HTTP\"></a>超文本传送协议 HTTP</h4><p>HTTP(HyperText Transfer Protocol，超文本传输协议)，使用了面向连接的 TCP 作为传输层协议，监听 80 端口，信息是明文传输，其本身是无状态的。</p>\n<ul>\n<li>HTTP1.0 :(1996) 每次请求都会单独建立一个TCP连接，用完关闭；（缺点：每次请求都耗费时间在连接上，<strong>非持续连接</strong> 使服务器开销很重）。</li>\n<li>HTTP1.1 :(1999) 在服务器发送完响应后仍在一段时间内保持这条连接，浏览器和该服务器可以继续在该连接上传送后续的请求报文和响应报文，使用 <strong>持续连接</strong> 。</li>\n<li>HTTP2.0 :(2015) 使用了新的二进制格式、多路复用、以及 header 压缩，性能相对于 HTTP1.x 提升明显。改善了在 Http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞；基于 HTTPS，天生具有安全性，可以避免单纯使用 HTTPS 带来的性能下降。</li>\n</ul>\n<h4 id=\"影响-HTTP-网络请求的因素\"><a href=\"#影响-HTTP-网络请求的因素\" class=\"headerlink\" title=\"影响 HTTP 网络请求的因素\"></a>影响 HTTP 网络请求的因素</h4><p>影响因素主要有两个：带宽和延迟。</p>\n<ul>\n<li><strong>带宽</strong>：在浏览器刚流行的时候，大部分用户是通过拨号来上网，由于受当时的带宽条件的限制，无法使得用户的同时多个请求被处理。同时，当时的服务器的配置也比现在差很多，所以限制每个浏览器的连接数的大小也是有必要的。浏览器默认对同一域下的资源，只保持一定的连接数，阻塞过多的连接,以提高访问速度和解决阻塞问题。不同浏览器的默认值不一样，对于不同的 HTTP 协议其值也不一样。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">浏览器</th>\n<th style=\"text-align:center\">HTTP 1.1</th>\n<th style=\"text-align:center\">HTTP 1.0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">IE 6、7</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IE 8</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">6</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">FireFox 2</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">FireFox 3</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">6</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Safari 3、4</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">4</td>\n</tr>\n</tbody>\n</table>\n<p>如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</p>\n<ul>\n<li><strong>延迟</strong>：<ul>\n<li>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制（见上表），后续请求就会被阻塞。</li>\n<li>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li>\n<li>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"应用层安全协议-HTTPS\"><a href=\"#应用层安全协议-HTTPS\" class=\"headerlink\" title=\"应用层安全协议 HTTPS\"></a>应用层安全协议 HTTPS</h4><p>HTTPS 是使用 SSL(Secure Socket Layer，安全套接字层)协议的 HTTP 协议。SSL 作用在 HTTP 和运输层之间，在 TCP 之上建立起一个安全通道，为通过 TCP 传输的应用层数据提供安全保障。<br>HTTPS 监听 TCP 的 443 端口，信息是密文传输。</p>\n","site":{"data":{}},"excerpt":"<p>《计算机网络(第7版)-谢希仁》http 部分的读书小结和扩展，因为工作中最常打交道的就是这部分了。整本书都很不错，语言通俗易懂；各协议的关系、发展过程以及区别都概括的很好。<br>本文主要概括 HTTP、HTTP1.0、HTTP2.0、HTTPS 的之间的差异。<br></p>","more":"<p></p>\n<h3 id=\"万维网WWW\"><a href=\"#万维网WWW\" class=\"headerlink\" title=\"万维网WWW\"></a>万维网WWW</h3><p>万维网(World Wide Web)是一个分布式的超媒体系统，是超文本系统的扩充。万维网使用 <strong>统一资源定位符URL(Uniform Resource Locator)</strong> 来标志万维网上的各种文档。</p>\n<h4 id=\"URL-的格式\"><a href=\"#URL-的格式\" class=\"headerlink\" title=\"URL 的格式\"></a>URL 的格式</h4><p>URL 的一般形式由以下四个部分组成：<br>&nbsp;&nbsp;&nbsp;&nbsp; <code>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code><br>URL 的&lt;协议&gt;就是指出使用什么协议来获取万维网文档。现在最常用的协议就是 http，其次是 ftp。有些浏览器为方便用户，在输入 URL 时，可以把最前面的“http://”甚至把主机名最前面的“www”省略，然后浏览器替用户把省略的字补上。<br><strong>URL里面的字母不分大小写，但是为了便于阅读，有时故意使用一些大写字母。</strong></p>\n<h4 id=\"超文本传送协议-HTTP\"><a href=\"#超文本传送协议-HTTP\" class=\"headerlink\" title=\"超文本传送协议 HTTP\"></a>超文本传送协议 HTTP</h4><p>HTTP(HyperText Transfer Protocol，超文本传输协议)，使用了面向连接的 TCP 作为传输层协议，监听 80 端口，信息是明文传输，其本身是无状态的。</p>\n<ul>\n<li>HTTP1.0 :(1996) 每次请求都会单独建立一个TCP连接，用完关闭；（缺点：每次请求都耗费时间在连接上，<strong>非持续连接</strong> 使服务器开销很重）。</li>\n<li>HTTP1.1 :(1999) 在服务器发送完响应后仍在一段时间内保持这条连接，浏览器和该服务器可以继续在该连接上传送后续的请求报文和响应报文，使用 <strong>持续连接</strong> 。</li>\n<li>HTTP2.0 :(2015) 使用了新的二进制格式、多路复用、以及 header 压缩，性能相对于 HTTP1.x 提升明显。改善了在 Http1.1 中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞；基于 HTTPS，天生具有安全性，可以避免单纯使用 HTTPS 带来的性能下降。</li>\n</ul>\n<h4 id=\"影响-HTTP-网络请求的因素\"><a href=\"#影响-HTTP-网络请求的因素\" class=\"headerlink\" title=\"影响 HTTP 网络请求的因素\"></a>影响 HTTP 网络请求的因素</h4><p>影响因素主要有两个：带宽和延迟。</p>\n<ul>\n<li><strong>带宽</strong>：在浏览器刚流行的时候，大部分用户是通过拨号来上网，由于受当时的带宽条件的限制，无法使得用户的同时多个请求被处理。同时，当时的服务器的配置也比现在差很多，所以限制每个浏览器的连接数的大小也是有必要的。浏览器默认对同一域下的资源，只保持一定的连接数，阻塞过多的连接,以提高访问速度和解决阻塞问题。不同浏览器的默认值不一样，对于不同的 HTTP 协议其值也不一样。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">浏览器</th>\n<th style=\"text-align:center\">HTTP 1.1</th>\n<th style=\"text-align:center\">HTTP 1.0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">IE 6、7</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IE 8</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">6</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">FireFox 2</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">FireFox 3</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">6</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Safari 3、4</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">4</td>\n</tr>\n</tbody>\n</table>\n<p>如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</p>\n<ul>\n<li><strong>延迟</strong>：<ul>\n<li>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制（见上表），后续请求就会被阻塞。</li>\n<li>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li>\n<li>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"应用层安全协议-HTTPS\"><a href=\"#应用层安全协议-HTTPS\" class=\"headerlink\" title=\"应用层安全协议 HTTPS\"></a>应用层安全协议 HTTPS</h4><p>HTTPS 是使用 SSL(Secure Socket Layer，安全套接字层)协议的 HTTP 协议。SSL 作用在 HTTP 和运输层之间，在 TCP 之上建立起一个安全通道，为通过 TCP 传输的应用层数据提供安全保障。<br>HTTPS 监听 TCP 的 443 端口，信息是密文传输。</p>"},{"title":"【译】Can NodeJS use ES6 import syntax ?","date":"2020-12-10T12:36:12.000Z","_content":"偶然在一篇文章中看到 Node 可以使用 import 语法了，无需再使用 babel 做额外的转换，遂去了解下 Node 相关的更新。本文主要介绍在最新版本 Node(14.15.1) 中如何使用 import 语法。大部分内容翻译自官网和外网文章。关于 JS 模块机制之前已经总结过一篇[文章](/2019/01/03/前端模块化/#more)，这里不再赘述。\n\n（ PS：原本是公司部门要求的 kpi 文章，现做了精简 ）\n<!--more-->\n\n## 概览\n本文主要内容：\n* Node 对 ES Modules 的支持\n* 在 Node 使用 import 语法\n* Node 中 ES Modules 的现状和未来\n\n## Node 对 ES Modules 支持\nNode 13.2.0 开始正式支持 ES Modules 特性（移除了 --experimental-modules 启动参数）.\n\n注意：相关的 ESM 的实验性标志都虽然被移除\n（但是由于 ESM loader 还是实验性的，所以运行 ES Modules 代码依然会有警告：\n````bash\n(node:47324) ExperimentalWarning: The ESM module loader is experimental.\n````\n\n## 在 NodeJS 中使用 ES Modules\n使 Node 支持 ES modules 有两种方式：\n1. 在 package.json中，增加 `type: \"module\"`配置，即可在 node 代码中使用 `import`和`export`语法:\n\n文件目录结构：\n````bash\n.\n├── index.js\n├── package.json\n└── utils\n    └── speak.js\n````\n\n````javascript\n// utils/speak.js\nexport function speak() {\n  console.log('Come from speak.')\n}\n\n// index.js\nimport { speak } from './utils/speak.js';\nspeak(); //come from speak\n````\n\n2. 在 .mjs 文件中直接使用 `import`和`export`；\n\n文件目录结构：\n````bash\n.\n├── index.mjs\n├── package.json\n└── utils\n    └── sing.mjs\n````\n\n````javascript\n// utils/sing.mjs\nexport function sing() {\n  console.log('Come from sing')\n}\n\n// index.mjs\nimport { sing } from './utils/sing.mjs';\nsing(); //come from sing\n````\n\n注意：\n  * 若不添加上述两项中任一项，直接使用在 Node 中使用 ES modules，则会抛出警告：\n  ````bash\n  Warning: To load an ES module, set \"type\": \"module\" in the package.json or use the .mjs extension.\n  ````\n  * __根据ESM规范，使用import关键字并不会像 CommonJS 模块那样，在默认情况下以文件扩展名完成文件路径。因此，ES Modules 必须明确文件扩展名。__\n\n### 模块作用域\n一个模块的作用域，由父级中有 `type: \"module\"` 的 package.json 文件路径定义。而使用`.mjs`扩展文件加载模块，则不受限于包的作用域。\n同理，`package.json`中没有`type`标志的包都会默认采用 CommonJS 模块机制，`.cjs`类型的扩展文件使用 CommonJS 方式加载模块同样不受限于包的作用域。\n\n### 包的入口\n定义包的入口有两种方式，在 package.json 中定义`main`字段或者`exports`字段\n````javascript\n{\n  \"main\": \"./main.js\",\n  \"exports\": \"./main.js\"\n}\n````\n需要注意的是，当`exports`字段被定义后，包的所有子路径都将被封装，子路径的文件不可再被导入。例如 require('pkg/subpath.js') 将会报错：\n````bash\nERR_PACKAGE_PATH_NOT_EXPORTED error.\n````\n参考官方文档：https://nodejs.org/api/packages.html#packages_main_entry_point_export\n\n### 两个模块机制在执行时机上的区别\n* ES Modules 导入的模块会被预解析，以便在代码运行前导入：\n  * 根据 EMS 规范 import / export 必须位于模块顶级，不能位于作用域内；\n  * 模块内的 import/export 会提升到模块顶部；\n* 在 CommonJS 中，模块将在运行时解析；\n\n举一个简单的例子来直观的对比下二者的差别：\n````javascript\n// ES Modules\n\n// a.js\nconsole.log('Come from a.js.');\nimport { hello } from './b.js';\nconsole.log(hello);\n\n// b.js\nconsole.log('Come from b.js.');\nexport const hello = 'Hello from b.js';\n````\n输出：\n````bash\nCome from b.js.\nCome from a.js.\nHello from b.js\n````\n\n同样的代码使用 CommonJS 机制：\n````javascript\n// CommonJS\n\n// a.js\nconsole.log('Come from a.js.');\nconst hello = require('./b.js');\nconsole.log(hello);\n\n// b.js\nconsole.log('Come from b.js.');\nmodule.exports = 'Hello from b.js';\n````\n输出：\n````bash\nCome from a.js.\nCome from b.js.\nHello from b.js\n````\n可以看到 ES Modules 预先解析了模块代码，而 CommonJS 是代码运行的时候解析的。\n\n### 两个模块在原理上的区别\n\n1. CommonJS\n\nNode 将每个文件都视为独立的模块，它定义了一个 Module 构造函数，它代表模块自身：\n````javascript\nfunction Module(id = '', parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  this.exports = {};\n  this.parent = parent;\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n};\n````\n\n而 require 函数接收一个代表模块ID或者路径的值作为参数，它返回的是用`module.exports`导出的对象。在执行代码模块之前，NodeJs 将使一  个包装器对模块中的代码其进行封装：\n````javascript\n(function(exports, require, module, __filename, __dirname) { \n    // Module code actually lives in here \n}); \n````\n\n> 引自 NodeJS 官网\n> \n> 通过这样做，Node.js 实现了以下几点：\n> * 它保持了顶层的变量（用 var、 const 或 let 定义）作用在模块范围内，而不是全局对象。\n> * 它有助于提供一些看似全局的但实际上是模块特定的变量，例如：\n>   * 实现者可以用于从模块中导出值的 module 和 exports 对象。\n>   * 包含模块绝对文件名和目录路径的快捷变量 __filename 和 __dirname 。\n\n简言之，每个模块都有自己的函数包装器， Node 通过此种方式确保模块内的代码对它是私有的。在包装器执行之前，模块内的导出内容是不确定的。\n除此之外，第一次加载的模块会被缓存到 `Module._cache`中。一个完整的加载周期大致如下：\n````bash\n  Resolution (解析) –> Loading (加载) –> Wrapping (私有化) –> Evaluation (执行) –> Caching (缓存)\n````\n\n2. ES Modules\n\n在 ESM 中，import 语句用于在解析代码时导入模块依赖的静态链接。文件的依赖关系在编译阶段就确定了。对于 ESM，模块的加载大致分为三步：\n````bash\n  Construction (解析) -> Instantiation (实例化、建立链接) -> Evaluation (执行)\n````\n这些步骤是异步执行的，每一步都可以看作是相互独立的。这一点跟 CommonJS 有很大不同，对于 CommonJS 来说，每一步都是同步进行的。\n\n### 两种模块间的相互引用\nCommonJS 和 ES Modules 都支持 `Dynamic import()`。它可以支持两种模块机制的导入：\n#### 在 CommonJS 文件中导入 ES Modules 模块\n由于 ES Modules 的加载、解析和执行都是异步的，而 require() 的过程是同步的、所以不能通过 require() 来引用一个 ES6 模块。ES6 提议的 import() 函数将会返回一个 Promise，它在 ES Modules 加载后标记完成。借助于此，我们可以在 CommonJS 中使用异步的方式导入 ES Modules：\n````javascript\n// 使用 then() 来进行模块导入后的操作\nimport(\"es6-modules.mjs\").then((module)=>{/*…*/}).catch((err)=>{/**…*/})\n// 或者使用 async 函数\n(async () => {\n  await import('./es6-modules.mjs');\n})();\n````\n\n### 在 ES Modules 文件中导入 CommonJS 模块\n在 ES6 模块里可以很方便地使用 import 来引用一个 CommonJS 模块，因为在 ES6 模块里异步加载并非是必须的：\n````javascript\nimport { default as cjs } from 'cjs';\n\n// The following import statement is \"syntax sugar\" (equivalent but sweeter)\n// for `{ default as cjsSugar }` in the above import statement:\nimport cjsSugar from 'cjs';\n\nconsole.log(cjs);\nconsole.log(cjs === cjsSugar);\n````\n\n## Node 中 ES Modules 的现状和未来\n在引入 ES6 标准之前，服务器端 JavaScript 代码都是依赖 CommonJS 模块机制进行包管理的。\n如今，随着 ES Modules 的引入，开发人员可以享受到与发布规范相关的许多好处。但需要注意的是，截止至当前时间(2020.11.30)，在最新版 Node v15.1.0 中，该特性依然是实验性的（Stability: 1），不建议在生产环境中使用该功能。\n\n最后，由于两种模块格式之间存在不兼容问题，将当前项目从 CommonJS 到 ES Modules 转换将是一个很大的挑战。可以借助 Babel 相关插件实现 CommonJS 和 ES Modules 间的相互转换：\n* [plugin-transform-modules-commonjs](https://babel.docschina.org/docs/en/babel-plugin-transform-modules-commonjs)\n* [babel-plugin-transform-commonjs](https://www.npmjs.com/package/babel-plugin-transform-commonjs)\n\n## 参考链接\n### 翻译原文\n* [es-modules-in-node-today](https://blog.logrocket.com/es-modules-in-node-today/)\n* [an-update-on-es6-modules-in-node-js](https://aotu.io/notes/2017/04/22/an-update-on-es6-modules-in-node-js/index.html)\n\n### 官方文档\n* [Node Documentation](https://nodejs.org/dist/latest-v14.x/docs/api/modules.html)\n* [Node version13+ release log](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V13.md#13.4.0)\n* [Node version14+ release log](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V14.md#14.15.0)\n* [Node modules wrapper](https://github.com/nodejs/ecmascript-modules/blob/modules-lkgr/doc/api/modules.md#the-module-wrapper)\n* [Node Source code: cjs](https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L195)\n* [ECMA262 Modules](https://tc39.es/ecma262/#sec-modules)\n* [TC39 Proposal Dynamic import](https://github.com/tc39/proposal-dynamic-import)\n","source":"_posts/【译】Can-NodeJS-use-ES6-import-syntax.md","raw":"---\ntitle: 【译】Can NodeJS use ES6 import syntax ?\ndate: 2020-12-10 20:36:12\ntags: [NodeJS]\ncategories: [后端]\n---\n偶然在一篇文章中看到 Node 可以使用 import 语法了，无需再使用 babel 做额外的转换，遂去了解下 Node 相关的更新。本文主要介绍在最新版本 Node(14.15.1) 中如何使用 import 语法。大部分内容翻译自官网和外网文章。关于 JS 模块机制之前已经总结过一篇[文章](/2019/01/03/前端模块化/#more)，这里不再赘述。\n\n（ PS：原本是公司部门要求的 kpi 文章，现做了精简 ）\n<!--more-->\n\n## 概览\n本文主要内容：\n* Node 对 ES Modules 的支持\n* 在 Node 使用 import 语法\n* Node 中 ES Modules 的现状和未来\n\n## Node 对 ES Modules 支持\nNode 13.2.0 开始正式支持 ES Modules 特性（移除了 --experimental-modules 启动参数）.\n\n注意：相关的 ESM 的实验性标志都虽然被移除\n（但是由于 ESM loader 还是实验性的，所以运行 ES Modules 代码依然会有警告：\n````bash\n(node:47324) ExperimentalWarning: The ESM module loader is experimental.\n````\n\n## 在 NodeJS 中使用 ES Modules\n使 Node 支持 ES modules 有两种方式：\n1. 在 package.json中，增加 `type: \"module\"`配置，即可在 node 代码中使用 `import`和`export`语法:\n\n文件目录结构：\n````bash\n.\n├── index.js\n├── package.json\n└── utils\n    └── speak.js\n````\n\n````javascript\n// utils/speak.js\nexport function speak() {\n  console.log('Come from speak.')\n}\n\n// index.js\nimport { speak } from './utils/speak.js';\nspeak(); //come from speak\n````\n\n2. 在 .mjs 文件中直接使用 `import`和`export`；\n\n文件目录结构：\n````bash\n.\n├── index.mjs\n├── package.json\n└── utils\n    └── sing.mjs\n````\n\n````javascript\n// utils/sing.mjs\nexport function sing() {\n  console.log('Come from sing')\n}\n\n// index.mjs\nimport { sing } from './utils/sing.mjs';\nsing(); //come from sing\n````\n\n注意：\n  * 若不添加上述两项中任一项，直接使用在 Node 中使用 ES modules，则会抛出警告：\n  ````bash\n  Warning: To load an ES module, set \"type\": \"module\" in the package.json or use the .mjs extension.\n  ````\n  * __根据ESM规范，使用import关键字并不会像 CommonJS 模块那样，在默认情况下以文件扩展名完成文件路径。因此，ES Modules 必须明确文件扩展名。__\n\n### 模块作用域\n一个模块的作用域，由父级中有 `type: \"module\"` 的 package.json 文件路径定义。而使用`.mjs`扩展文件加载模块，则不受限于包的作用域。\n同理，`package.json`中没有`type`标志的包都会默认采用 CommonJS 模块机制，`.cjs`类型的扩展文件使用 CommonJS 方式加载模块同样不受限于包的作用域。\n\n### 包的入口\n定义包的入口有两种方式，在 package.json 中定义`main`字段或者`exports`字段\n````javascript\n{\n  \"main\": \"./main.js\",\n  \"exports\": \"./main.js\"\n}\n````\n需要注意的是，当`exports`字段被定义后，包的所有子路径都将被封装，子路径的文件不可再被导入。例如 require('pkg/subpath.js') 将会报错：\n````bash\nERR_PACKAGE_PATH_NOT_EXPORTED error.\n````\n参考官方文档：https://nodejs.org/api/packages.html#packages_main_entry_point_export\n\n### 两个模块机制在执行时机上的区别\n* ES Modules 导入的模块会被预解析，以便在代码运行前导入：\n  * 根据 EMS 规范 import / export 必须位于模块顶级，不能位于作用域内；\n  * 模块内的 import/export 会提升到模块顶部；\n* 在 CommonJS 中，模块将在运行时解析；\n\n举一个简单的例子来直观的对比下二者的差别：\n````javascript\n// ES Modules\n\n// a.js\nconsole.log('Come from a.js.');\nimport { hello } from './b.js';\nconsole.log(hello);\n\n// b.js\nconsole.log('Come from b.js.');\nexport const hello = 'Hello from b.js';\n````\n输出：\n````bash\nCome from b.js.\nCome from a.js.\nHello from b.js\n````\n\n同样的代码使用 CommonJS 机制：\n````javascript\n// CommonJS\n\n// a.js\nconsole.log('Come from a.js.');\nconst hello = require('./b.js');\nconsole.log(hello);\n\n// b.js\nconsole.log('Come from b.js.');\nmodule.exports = 'Hello from b.js';\n````\n输出：\n````bash\nCome from a.js.\nCome from b.js.\nHello from b.js\n````\n可以看到 ES Modules 预先解析了模块代码，而 CommonJS 是代码运行的时候解析的。\n\n### 两个模块在原理上的区别\n\n1. CommonJS\n\nNode 将每个文件都视为独立的模块，它定义了一个 Module 构造函数，它代表模块自身：\n````javascript\nfunction Module(id = '', parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  this.exports = {};\n  this.parent = parent;\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n};\n````\n\n而 require 函数接收一个代表模块ID或者路径的值作为参数，它返回的是用`module.exports`导出的对象。在执行代码模块之前，NodeJs 将使一  个包装器对模块中的代码其进行封装：\n````javascript\n(function(exports, require, module, __filename, __dirname) { \n    // Module code actually lives in here \n}); \n````\n\n> 引自 NodeJS 官网\n> \n> 通过这样做，Node.js 实现了以下几点：\n> * 它保持了顶层的变量（用 var、 const 或 let 定义）作用在模块范围内，而不是全局对象。\n> * 它有助于提供一些看似全局的但实际上是模块特定的变量，例如：\n>   * 实现者可以用于从模块中导出值的 module 和 exports 对象。\n>   * 包含模块绝对文件名和目录路径的快捷变量 __filename 和 __dirname 。\n\n简言之，每个模块都有自己的函数包装器， Node 通过此种方式确保模块内的代码对它是私有的。在包装器执行之前，模块内的导出内容是不确定的。\n除此之外，第一次加载的模块会被缓存到 `Module._cache`中。一个完整的加载周期大致如下：\n````bash\n  Resolution (解析) –> Loading (加载) –> Wrapping (私有化) –> Evaluation (执行) –> Caching (缓存)\n````\n\n2. ES Modules\n\n在 ESM 中，import 语句用于在解析代码时导入模块依赖的静态链接。文件的依赖关系在编译阶段就确定了。对于 ESM，模块的加载大致分为三步：\n````bash\n  Construction (解析) -> Instantiation (实例化、建立链接) -> Evaluation (执行)\n````\n这些步骤是异步执行的，每一步都可以看作是相互独立的。这一点跟 CommonJS 有很大不同，对于 CommonJS 来说，每一步都是同步进行的。\n\n### 两种模块间的相互引用\nCommonJS 和 ES Modules 都支持 `Dynamic import()`。它可以支持两种模块机制的导入：\n#### 在 CommonJS 文件中导入 ES Modules 模块\n由于 ES Modules 的加载、解析和执行都是异步的，而 require() 的过程是同步的、所以不能通过 require() 来引用一个 ES6 模块。ES6 提议的 import() 函数将会返回一个 Promise，它在 ES Modules 加载后标记完成。借助于此，我们可以在 CommonJS 中使用异步的方式导入 ES Modules：\n````javascript\n// 使用 then() 来进行模块导入后的操作\nimport(\"es6-modules.mjs\").then((module)=>{/*…*/}).catch((err)=>{/**…*/})\n// 或者使用 async 函数\n(async () => {\n  await import('./es6-modules.mjs');\n})();\n````\n\n### 在 ES Modules 文件中导入 CommonJS 模块\n在 ES6 模块里可以很方便地使用 import 来引用一个 CommonJS 模块，因为在 ES6 模块里异步加载并非是必须的：\n````javascript\nimport { default as cjs } from 'cjs';\n\n// The following import statement is \"syntax sugar\" (equivalent but sweeter)\n// for `{ default as cjsSugar }` in the above import statement:\nimport cjsSugar from 'cjs';\n\nconsole.log(cjs);\nconsole.log(cjs === cjsSugar);\n````\n\n## Node 中 ES Modules 的现状和未来\n在引入 ES6 标准之前，服务器端 JavaScript 代码都是依赖 CommonJS 模块机制进行包管理的。\n如今，随着 ES Modules 的引入，开发人员可以享受到与发布规范相关的许多好处。但需要注意的是，截止至当前时间(2020.11.30)，在最新版 Node v15.1.0 中，该特性依然是实验性的（Stability: 1），不建议在生产环境中使用该功能。\n\n最后，由于两种模块格式之间存在不兼容问题，将当前项目从 CommonJS 到 ES Modules 转换将是一个很大的挑战。可以借助 Babel 相关插件实现 CommonJS 和 ES Modules 间的相互转换：\n* [plugin-transform-modules-commonjs](https://babel.docschina.org/docs/en/babel-plugin-transform-modules-commonjs)\n* [babel-plugin-transform-commonjs](https://www.npmjs.com/package/babel-plugin-transform-commonjs)\n\n## 参考链接\n### 翻译原文\n* [es-modules-in-node-today](https://blog.logrocket.com/es-modules-in-node-today/)\n* [an-update-on-es6-modules-in-node-js](https://aotu.io/notes/2017/04/22/an-update-on-es6-modules-in-node-js/index.html)\n\n### 官方文档\n* [Node Documentation](https://nodejs.org/dist/latest-v14.x/docs/api/modules.html)\n* [Node version13+ release log](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V13.md#13.4.0)\n* [Node version14+ release log](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V14.md#14.15.0)\n* [Node modules wrapper](https://github.com/nodejs/ecmascript-modules/blob/modules-lkgr/doc/api/modules.md#the-module-wrapper)\n* [Node Source code: cjs](https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L195)\n* [ECMA262 Modules](https://tc39.es/ecma262/#sec-modules)\n* [TC39 Proposal Dynamic import](https://github.com/tc39/proposal-dynamic-import)\n","slug":"【译】Can-NodeJS-use-ES6-import-syntax","published":1,"updated":"2020-12-12T06:27:20.329Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0x000w7vvuaqtylenm","content":"<p>偶然在一篇文章中看到 Node 可以使用 import 语法了，无需再使用 babel 做额外的转换，遂去了解下 Node 相关的更新。本文主要介绍在最新版本 Node(14.15.1) 中如何使用 import 语法。大部分内容翻译自官网和外网文章。关于 JS 模块机制之前已经总结过一篇<a href=\"/2019/01/03/前端模块化/#more\">文章</a>，这里不再赘述。</p>\n<p>（ PS：原本是公司部门要求的 kpi 文章，现做了精简 ）<br><a id=\"more\"></a></p>\n<h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><p>本文主要内容：</p>\n<ul>\n<li>Node 对 ES Modules 的支持</li>\n<li>在 Node 使用 import 语法</li>\n<li>Node 中 ES Modules 的现状和未来</li>\n</ul>\n<h2 id=\"Node-对-ES-Modules-支持\"><a href=\"#Node-对-ES-Modules-支持\" class=\"headerlink\" title=\"Node 对 ES Modules 支持\"></a>Node 对 ES Modules 支持</h2><p>Node 13.2.0 开始正式支持 ES Modules 特性（移除了 –experimental-modules 启动参数）.</p>\n<p>注意：相关的 ESM 的实验性标志都虽然被移除<br>（但是由于 ESM loader 还是实验性的，所以运行 ES Modules 代码依然会有警告：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(node:47324) ExperimentalWarning: The ESM module loader is experimental.</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"在-NodeJS-中使用-ES-Modules\"><a href=\"#在-NodeJS-中使用-ES-Modules\" class=\"headerlink\" title=\"在 NodeJS 中使用 ES Modules\"></a>在 NodeJS 中使用 ES Modules</h2><p>使 Node 支持 ES modules 有两种方式：</p>\n<ol>\n<li>在 package.json中，增加 <code>type: &quot;module&quot;</code>配置，即可在 node 代码中使用 <code>import</code>和<code>export</code>语法:</li>\n</ol>\n<p>文件目录结构：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── index.js</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">└── utils</span><br><span class=\"line\">    └── speak.js</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// utils/speak.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">speak</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Come from speak.'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; speak &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./utils/speak.js'</span>;</span><br><span class=\"line\">speak(); <span class=\"comment\">//come from speak</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在 .mjs 文件中直接使用 <code>import</code>和<code>export</code>；</li>\n</ol>\n<p>文件目录结构：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── index.mjs</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">└── utils</span><br><span class=\"line\">    └── sing.mjs</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// utils/sing.mjs</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sing</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Come from sing'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// index.mjs</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; sing &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./utils/sing.mjs'</span>;</span><br><span class=\"line\">sing(); <span class=\"comment\">//come from sing</span></span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<ul>\n<li><p>若不添加上述两项中任一项，直接使用在 Node 中使用 ES modules，则会抛出警告：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Warning: To load an ES module, <span class=\"built_in\">set</span> <span class=\"string\">\"type\"</span>: <span class=\"string\">\"module\"</span> <span class=\"keyword\">in</span> the package.json or use the .mjs extension.</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>根据ESM规范，使用import关键字并不会像 CommonJS 模块那样，在默认情况下以文件扩展名完成文件路径。因此，ES Modules 必须明确文件扩展名。</strong></p>\n</li>\n</ul>\n<h3 id=\"模块作用域\"><a href=\"#模块作用域\" class=\"headerlink\" title=\"模块作用域\"></a>模块作用域</h3><p>一个模块的作用域，由父级中有 <code>type: &quot;module&quot;</code> 的 package.json 文件路径定义。而使用<code>.mjs</code>扩展文件加载模块，则不受限于包的作用域。<br>同理，<code>package.json</code>中没有<code>type</code>标志的包都会默认采用 CommonJS 模块机制，<code>.cjs</code>类型的扩展文件使用 CommonJS 方式加载模块同样不受限于包的作用域。</p>\n<h3 id=\"包的入口\"><a href=\"#包的入口\" class=\"headerlink\" title=\"包的入口\"></a>包的入口</h3><p>定义包的入口有两种方式，在 package.json 中定义<code>main</code>字段或者<code>exports</code>字段<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"main\"</span>: <span class=\"string\">\"./main.js\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"exports\"</span>: <span class=\"string\">\"./main.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，当<code>exports</code>字段被定义后，包的所有子路径都将被封装，子路径的文件不可再被导入。例如 require(‘pkg/subpath.js’) 将会报错：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERR_PACKAGE_PATH_NOT_EXPORTED error.</span><br></pre></td></tr></table></figure></p>\n<p>参考官方文档：<a href=\"https://nodejs.org/api/packages.html#packages_main_entry_point_export\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/api/packages.html#packages_main_entry_point_export</a></p>\n<h3 id=\"两个模块机制在执行时机上的区别\"><a href=\"#两个模块机制在执行时机上的区别\" class=\"headerlink\" title=\"两个模块机制在执行时机上的区别\"></a>两个模块机制在执行时机上的区别</h3><ul>\n<li>ES Modules 导入的模块会被预解析，以便在代码运行前导入：<ul>\n<li>根据 EMS 规范 import / export 必须位于模块顶级，不能位于作用域内；</li>\n<li>模块内的 import/export 会提升到模块顶部；</li>\n</ul>\n</li>\n<li>在 CommonJS 中，模块将在运行时解析；</li>\n</ul>\n<p>举一个简单的例子来直观的对比下二者的差别：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES Modules</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Come from a.js.'</span>);</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; hello &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./b.js'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b.js</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Come from b.js.'</span>);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> hello = <span class=\"string\">'Hello from b.js'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Come from b.js.</span><br><span class=\"line\">Come from a.js.</span><br><span class=\"line\">Hello from b.js</span><br></pre></td></tr></table></figure></p>\n<p>同样的代码使用 CommonJS 机制：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CommonJS</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Come from a.js.'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> hello = <span class=\"built_in\">require</span>(<span class=\"string\">'./b.js'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b.js</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Come from b.js.'</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"string\">'Hello from b.js'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Come from a.js.</span><br><span class=\"line\">Come from b.js.</span><br><span class=\"line\">Hello from b.js</span><br></pre></td></tr></table></figure></p>\n<p>可以看到 ES Modules 预先解析了模块代码，而 CommonJS 是代码运行的时候解析的。</p>\n<h3 id=\"两个模块在原理上的区别\"><a href=\"#两个模块在原理上的区别\" class=\"headerlink\" title=\"两个模块在原理上的区别\"></a>两个模块在原理上的区别</h3><ol>\n<li>CommonJS</li>\n</ol>\n<p>Node 将每个文件都视为独立的模块，它定义了一个 Module 构造函数，它代表模块自身：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Module</span>(<span class=\"params\">id = <span class=\"string\">''</span>, parent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.path = path.dirname(id);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.exports = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.parent = parent;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.filename = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.loaded = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.children = [];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>而 require 函数接收一个代表模块ID或者路径的值作为参数，它返回的是用<code>module.exports</code>导出的对象。在执行代码模块之前，NodeJs 将使一  个包装器对模块中的代码其进行封装：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">exports, require, module, __filename, __dirname</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// Module code actually lives in here </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>引自 NodeJS 官网</p>\n<p>通过这样做，Node.js 实现了以下几点：</p>\n<ul>\n<li>它保持了顶层的变量（用 var、 const 或 let 定义）作用在模块范围内，而不是全局对象。</li>\n<li>它有助于提供一些看似全局的但实际上是模块特定的变量，例如：<ul>\n<li>实现者可以用于从模块中导出值的 module 和 exports 对象。</li>\n<li>包含模块绝对文件名和目录路径的快捷变量 <strong>filename 和 </strong>dirname 。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>简言之，每个模块都有自己的函数包装器， Node 通过此种方式确保模块内的代码对它是私有的。在包装器执行之前，模块内的导出内容是不确定的。<br>除此之外，第一次加载的模块会被缓存到 <code>Module._cache</code>中。一个完整的加载周期大致如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Resolution (解析) –&gt; Loading (加载) –&gt; Wrapping (私有化) –&gt; Evaluation (执行) –&gt; Caching (缓存)</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>ES Modules</li>\n</ol>\n<p>在 ESM 中，import 语句用于在解析代码时导入模块依赖的静态链接。文件的依赖关系在编译阶段就确定了。对于 ESM，模块的加载大致分为三步：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Construction (解析) -&gt; Instantiation (实例化、建立链接) -&gt; Evaluation (执行)</span><br></pre></td></tr></table></figure></p>\n<p>这些步骤是异步执行的，每一步都可以看作是相互独立的。这一点跟 CommonJS 有很大不同，对于 CommonJS 来说，每一步都是同步进行的。</p>\n<h3 id=\"两种模块间的相互引用\"><a href=\"#两种模块间的相互引用\" class=\"headerlink\" title=\"两种模块间的相互引用\"></a>两种模块间的相互引用</h3><p>CommonJS 和 ES Modules 都支持 <code>Dynamic import()</code>。它可以支持两种模块机制的导入：</p>\n<h4 id=\"在-CommonJS-文件中导入-ES-Modules-模块\"><a href=\"#在-CommonJS-文件中导入-ES-Modules-模块\" class=\"headerlink\" title=\"在 CommonJS 文件中导入 ES Modules 模块\"></a>在 CommonJS 文件中导入 ES Modules 模块</h4><p>由于 ES Modules 的加载、解析和执行都是异步的，而 require() 的过程是同步的、所以不能通过 require() 来引用一个 ES6 模块。ES6 提议的 import() 函数将会返回一个 Promise，它在 ES Modules 加载后标记完成。借助于此，我们可以在 CommonJS 中使用异步的方式导入 ES Modules：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 then() 来进行模块导入后的操作</span></span><br><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"string\">\"es6-modules.mjs\"</span>).then(<span class=\"function\">(<span class=\"params\"><span class=\"built_in\">module</span></span>)=&gt;</span>&#123;<span class=\"comment\">/*…*/</span>&#125;).catch(<span class=\"function\">(<span class=\"params\">err</span>)=&gt;</span>&#123;<span class=\"comment\">/**…*/</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 或者使用 async 函数</span></span><br><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./es6-modules.mjs'</span>);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"在-ES-Modules-文件中导入-CommonJS-模块\"><a href=\"#在-ES-Modules-文件中导入-CommonJS-模块\" class=\"headerlink\" title=\"在 ES Modules 文件中导入 CommonJS 模块\"></a>在 ES Modules 文件中导入 CommonJS 模块</h3><p>在 ES6 模块里可以很方便地使用 import 来引用一个 CommonJS 模块，因为在 ES6 模块里异步加载并非是必须的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"keyword\">default</span> <span class=\"keyword\">as</span> cjs &#125; <span class=\"keyword\">from</span> <span class=\"string\">'cjs'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The following import statement is \"syntax sugar\" (equivalent but sweeter)</span></span><br><span class=\"line\"><span class=\"comment\">// for `&#123; default as cjsSugar &#125;` in the above import statement:</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> cjsSugar <span class=\"keyword\">from</span> <span class=\"string\">'cjs'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cjs);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cjs === cjsSugar);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Node-中-ES-Modules-的现状和未来\"><a href=\"#Node-中-ES-Modules-的现状和未来\" class=\"headerlink\" title=\"Node 中 ES Modules 的现状和未来\"></a>Node 中 ES Modules 的现状和未来</h2><p>在引入 ES6 标准之前，服务器端 JavaScript 代码都是依赖 CommonJS 模块机制进行包管理的。<br>如今，随着 ES Modules 的引入，开发人员可以享受到与发布规范相关的许多好处。但需要注意的是，截止至当前时间(2020.11.30)，在最新版 Node v15.1.0 中，该特性依然是实验性的（Stability: 1），不建议在生产环境中使用该功能。</p>\n<p>最后，由于两种模块格式之间存在不兼容问题，将当前项目从 CommonJS 到 ES Modules 转换将是一个很大的挑战。可以借助 Babel 相关插件实现 CommonJS 和 ES Modules 间的相互转换：</p>\n<ul>\n<li><a href=\"https://babel.docschina.org/docs/en/babel-plugin-transform-modules-commonjs\" target=\"_blank\" rel=\"noopener\">plugin-transform-modules-commonjs</a></li>\n<li><a href=\"https://www.npmjs.com/package/babel-plugin-transform-commonjs\" target=\"_blank\" rel=\"noopener\">babel-plugin-transform-commonjs</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><h3 id=\"翻译原文\"><a href=\"#翻译原文\" class=\"headerlink\" title=\"翻译原文\"></a>翻译原文</h3><ul>\n<li><a href=\"https://blog.logrocket.com/es-modules-in-node-today/\" target=\"_blank\" rel=\"noopener\">es-modules-in-node-today</a></li>\n<li><a href=\"https://aotu.io/notes/2017/04/22/an-update-on-es6-modules-in-node-js/index.html\" target=\"_blank\" rel=\"noopener\">an-update-on-es6-modules-in-node-js</a></li>\n</ul>\n<h3 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h3><ul>\n<li><a href=\"https://nodejs.org/dist/latest-v14.x/docs/api/modules.html\" target=\"_blank\" rel=\"noopener\">Node Documentation</a></li>\n<li><a href=\"https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V13.md#13.4.0\" target=\"_blank\" rel=\"noopener\">Node version13+ release log</a></li>\n<li><a href=\"https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V14.md#14.15.0\" target=\"_blank\" rel=\"noopener\">Node version14+ release log</a></li>\n<li><a href=\"https://github.com/nodejs/ecmascript-modules/blob/modules-lkgr/doc/api/modules.md#the-module-wrapper\" target=\"_blank\" rel=\"noopener\">Node modules wrapper</a></li>\n<li><a href=\"https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L195\" target=\"_blank\" rel=\"noopener\">Node Source code: cjs</a></li>\n<li><a href=\"https://tc39.es/ecma262/#sec-modules\" target=\"_blank\" rel=\"noopener\">ECMA262 Modules</a></li>\n<li><a href=\"https://github.com/tc39/proposal-dynamic-import\" target=\"_blank\" rel=\"noopener\">TC39 Proposal Dynamic import</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>偶然在一篇文章中看到 Node 可以使用 import 语法了，无需再使用 babel 做额外的转换，遂去了解下 Node 相关的更新。本文主要介绍在最新版本 Node(14.15.1) 中如何使用 import 语法。大部分内容翻译自官网和外网文章。关于 JS 模块机制之前已经总结过一篇<a href=\"/2019/01/03/前端模块化/#more\">文章</a>，这里不再赘述。</p>\n<p>（ PS：原本是公司部门要求的 kpi 文章，现做了精简 ）<br></p>","more":"<p></p>\n<h2 id=\"概览\"><a href=\"#概览\" class=\"headerlink\" title=\"概览\"></a>概览</h2><p>本文主要内容：</p>\n<ul>\n<li>Node 对 ES Modules 的支持</li>\n<li>在 Node 使用 import 语法</li>\n<li>Node 中 ES Modules 的现状和未来</li>\n</ul>\n<h2 id=\"Node-对-ES-Modules-支持\"><a href=\"#Node-对-ES-Modules-支持\" class=\"headerlink\" title=\"Node 对 ES Modules 支持\"></a>Node 对 ES Modules 支持</h2><p>Node 13.2.0 开始正式支持 ES Modules 特性（移除了 –experimental-modules 启动参数）.</p>\n<p>注意：相关的 ESM 的实验性标志都虽然被移除<br>（但是由于 ESM loader 还是实验性的，所以运行 ES Modules 代码依然会有警告：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(node:47324) ExperimentalWarning: The ESM module loader is experimental.</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"在-NodeJS-中使用-ES-Modules\"><a href=\"#在-NodeJS-中使用-ES-Modules\" class=\"headerlink\" title=\"在 NodeJS 中使用 ES Modules\"></a>在 NodeJS 中使用 ES Modules</h2><p>使 Node 支持 ES modules 有两种方式：</p>\n<ol>\n<li>在 package.json中，增加 <code>type: &quot;module&quot;</code>配置，即可在 node 代码中使用 <code>import</code>和<code>export</code>语法:</li>\n</ol>\n<p>文件目录结构：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── index.js</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">└── utils</span><br><span class=\"line\">    └── speak.js</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// utils/speak.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">speak</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Come from speak.'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// index.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; speak &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./utils/speak.js'</span>;</span><br><span class=\"line\">speak(); <span class=\"comment\">//come from speak</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在 .mjs 文件中直接使用 <code>import</code>和<code>export</code>；</li>\n</ol>\n<p>文件目录结构：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── index.mjs</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">└── utils</span><br><span class=\"line\">    └── sing.mjs</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// utils/sing.mjs</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sing</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Come from sing'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// index.mjs</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; sing &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./utils/sing.mjs'</span>;</span><br><span class=\"line\">sing(); <span class=\"comment\">//come from sing</span></span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<ul>\n<li><p>若不添加上述两项中任一项，直接使用在 Node 中使用 ES modules，则会抛出警告：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Warning: To load an ES module, <span class=\"built_in\">set</span> <span class=\"string\">\"type\"</span>: <span class=\"string\">\"module\"</span> <span class=\"keyword\">in</span> the package.json or use the .mjs extension.</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>根据ESM规范，使用import关键字并不会像 CommonJS 模块那样，在默认情况下以文件扩展名完成文件路径。因此，ES Modules 必须明确文件扩展名。</strong></p>\n</li>\n</ul>\n<h3 id=\"模块作用域\"><a href=\"#模块作用域\" class=\"headerlink\" title=\"模块作用域\"></a>模块作用域</h3><p>一个模块的作用域，由父级中有 <code>type: &quot;module&quot;</code> 的 package.json 文件路径定义。而使用<code>.mjs</code>扩展文件加载模块，则不受限于包的作用域。<br>同理，<code>package.json</code>中没有<code>type</code>标志的包都会默认采用 CommonJS 模块机制，<code>.cjs</code>类型的扩展文件使用 CommonJS 方式加载模块同样不受限于包的作用域。</p>\n<h3 id=\"包的入口\"><a href=\"#包的入口\" class=\"headerlink\" title=\"包的入口\"></a>包的入口</h3><p>定义包的入口有两种方式，在 package.json 中定义<code>main</code>字段或者<code>exports</code>字段<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"main\"</span>: <span class=\"string\">\"./main.js\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"exports\"</span>: <span class=\"string\">\"./main.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，当<code>exports</code>字段被定义后，包的所有子路径都将被封装，子路径的文件不可再被导入。例如 require(‘pkg/subpath.js’) 将会报错：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERR_PACKAGE_PATH_NOT_EXPORTED error.</span><br></pre></td></tr></table></figure></p>\n<p>参考官方文档：<a href=\"https://nodejs.org/api/packages.html#packages_main_entry_point_export\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/api/packages.html#packages_main_entry_point_export</a></p>\n<h3 id=\"两个模块机制在执行时机上的区别\"><a href=\"#两个模块机制在执行时机上的区别\" class=\"headerlink\" title=\"两个模块机制在执行时机上的区别\"></a>两个模块机制在执行时机上的区别</h3><ul>\n<li>ES Modules 导入的模块会被预解析，以便在代码运行前导入：<ul>\n<li>根据 EMS 规范 import / export 必须位于模块顶级，不能位于作用域内；</li>\n<li>模块内的 import/export 会提升到模块顶部；</li>\n</ul>\n</li>\n<li>在 CommonJS 中，模块将在运行时解析；</li>\n</ul>\n<p>举一个简单的例子来直观的对比下二者的差别：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES Modules</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Come from a.js.'</span>);</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; hello &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./b.js'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b.js</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Come from b.js.'</span>);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> hello = <span class=\"string\">'Hello from b.js'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Come from b.js.</span><br><span class=\"line\">Come from a.js.</span><br><span class=\"line\">Hello from b.js</span><br></pre></td></tr></table></figure></p>\n<p>同样的代码使用 CommonJS 机制：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CommonJS</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Come from a.js.'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> hello = <span class=\"built_in\">require</span>(<span class=\"string\">'./b.js'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b.js</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Come from b.js.'</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"string\">'Hello from b.js'</span>;</span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Come from a.js.</span><br><span class=\"line\">Come from b.js.</span><br><span class=\"line\">Hello from b.js</span><br></pre></td></tr></table></figure></p>\n<p>可以看到 ES Modules 预先解析了模块代码，而 CommonJS 是代码运行的时候解析的。</p>\n<h3 id=\"两个模块在原理上的区别\"><a href=\"#两个模块在原理上的区别\" class=\"headerlink\" title=\"两个模块在原理上的区别\"></a>两个模块在原理上的区别</h3><ol>\n<li>CommonJS</li>\n</ol>\n<p>Node 将每个文件都视为独立的模块，它定义了一个 Module 构造函数，它代表模块自身：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Module</span>(<span class=\"params\">id = <span class=\"string\">''</span>, parent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.path = path.dirname(id);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.exports = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.parent = parent;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.filename = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.loaded = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.children = [];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>而 require 函数接收一个代表模块ID或者路径的值作为参数，它返回的是用<code>module.exports</code>导出的对象。在执行代码模块之前，NodeJs 将使一  个包装器对模块中的代码其进行封装：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">exports, require, module, __filename, __dirname</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// Module code actually lives in here </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>引自 NodeJS 官网</p>\n<p>通过这样做，Node.js 实现了以下几点：</p>\n<ul>\n<li>它保持了顶层的变量（用 var、 const 或 let 定义）作用在模块范围内，而不是全局对象。</li>\n<li>它有助于提供一些看似全局的但实际上是模块特定的变量，例如：<ul>\n<li>实现者可以用于从模块中导出值的 module 和 exports 对象。</li>\n<li>包含模块绝对文件名和目录路径的快捷变量 <strong>filename 和 </strong>dirname 。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>简言之，每个模块都有自己的函数包装器， Node 通过此种方式确保模块内的代码对它是私有的。在包装器执行之前，模块内的导出内容是不确定的。<br>除此之外，第一次加载的模块会被缓存到 <code>Module._cache</code>中。一个完整的加载周期大致如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Resolution (解析) –&gt; Loading (加载) –&gt; Wrapping (私有化) –&gt; Evaluation (执行) –&gt; Caching (缓存)</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>ES Modules</li>\n</ol>\n<p>在 ESM 中，import 语句用于在解析代码时导入模块依赖的静态链接。文件的依赖关系在编译阶段就确定了。对于 ESM，模块的加载大致分为三步：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Construction (解析) -&gt; Instantiation (实例化、建立链接) -&gt; Evaluation (执行)</span><br></pre></td></tr></table></figure></p>\n<p>这些步骤是异步执行的，每一步都可以看作是相互独立的。这一点跟 CommonJS 有很大不同，对于 CommonJS 来说，每一步都是同步进行的。</p>\n<h3 id=\"两种模块间的相互引用\"><a href=\"#两种模块间的相互引用\" class=\"headerlink\" title=\"两种模块间的相互引用\"></a>两种模块间的相互引用</h3><p>CommonJS 和 ES Modules 都支持 <code>Dynamic import()</code>。它可以支持两种模块机制的导入：</p>\n<h4 id=\"在-CommonJS-文件中导入-ES-Modules-模块\"><a href=\"#在-CommonJS-文件中导入-ES-Modules-模块\" class=\"headerlink\" title=\"在 CommonJS 文件中导入 ES Modules 模块\"></a>在 CommonJS 文件中导入 ES Modules 模块</h4><p>由于 ES Modules 的加载、解析和执行都是异步的，而 require() 的过程是同步的、所以不能通过 require() 来引用一个 ES6 模块。ES6 提议的 import() 函数将会返回一个 Promise，它在 ES Modules 加载后标记完成。借助于此，我们可以在 CommonJS 中使用异步的方式导入 ES Modules：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 then() 来进行模块导入后的操作</span></span><br><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"string\">\"es6-modules.mjs\"</span>).then(<span class=\"function\">(<span class=\"params\"><span class=\"built_in\">module</span></span>)=&gt;</span>&#123;<span class=\"comment\">/*…*/</span>&#125;).catch(<span class=\"function\">(<span class=\"params\">err</span>)=&gt;</span>&#123;<span class=\"comment\">/**…*/</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 或者使用 async 函数</span></span><br><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./es6-modules.mjs'</span>);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"在-ES-Modules-文件中导入-CommonJS-模块\"><a href=\"#在-ES-Modules-文件中导入-CommonJS-模块\" class=\"headerlink\" title=\"在 ES Modules 文件中导入 CommonJS 模块\"></a>在 ES Modules 文件中导入 CommonJS 模块</h3><p>在 ES6 模块里可以很方便地使用 import 来引用一个 CommonJS 模块，因为在 ES6 模块里异步加载并非是必须的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"keyword\">default</span> <span class=\"keyword\">as</span> cjs &#125; <span class=\"keyword\">from</span> <span class=\"string\">'cjs'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The following import statement is \"syntax sugar\" (equivalent but sweeter)</span></span><br><span class=\"line\"><span class=\"comment\">// for `&#123; default as cjsSugar &#125;` in the above import statement:</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> cjsSugar <span class=\"keyword\">from</span> <span class=\"string\">'cjs'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cjs);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cjs === cjsSugar);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Node-中-ES-Modules-的现状和未来\"><a href=\"#Node-中-ES-Modules-的现状和未来\" class=\"headerlink\" title=\"Node 中 ES Modules 的现状和未来\"></a>Node 中 ES Modules 的现状和未来</h2><p>在引入 ES6 标准之前，服务器端 JavaScript 代码都是依赖 CommonJS 模块机制进行包管理的。<br>如今，随着 ES Modules 的引入，开发人员可以享受到与发布规范相关的许多好处。但需要注意的是，截止至当前时间(2020.11.30)，在最新版 Node v15.1.0 中，该特性依然是实验性的（Stability: 1），不建议在生产环境中使用该功能。</p>\n<p>最后，由于两种模块格式之间存在不兼容问题，将当前项目从 CommonJS 到 ES Modules 转换将是一个很大的挑战。可以借助 Babel 相关插件实现 CommonJS 和 ES Modules 间的相互转换：</p>\n<ul>\n<li><a href=\"https://babel.docschina.org/docs/en/babel-plugin-transform-modules-commonjs\" target=\"_blank\" rel=\"noopener\">plugin-transform-modules-commonjs</a></li>\n<li><a href=\"https://www.npmjs.com/package/babel-plugin-transform-commonjs\" target=\"_blank\" rel=\"noopener\">babel-plugin-transform-commonjs</a></li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><h3 id=\"翻译原文\"><a href=\"#翻译原文\" class=\"headerlink\" title=\"翻译原文\"></a>翻译原文</h3><ul>\n<li><a href=\"https://blog.logrocket.com/es-modules-in-node-today/\" target=\"_blank\" rel=\"noopener\">es-modules-in-node-today</a></li>\n<li><a href=\"https://aotu.io/notes/2017/04/22/an-update-on-es6-modules-in-node-js/index.html\" target=\"_blank\" rel=\"noopener\">an-update-on-es6-modules-in-node-js</a></li>\n</ul>\n<h3 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h3><ul>\n<li><a href=\"https://nodejs.org/dist/latest-v14.x/docs/api/modules.html\" target=\"_blank\" rel=\"noopener\">Node Documentation</a></li>\n<li><a href=\"https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V13.md#13.4.0\" target=\"_blank\" rel=\"noopener\">Node version13+ release log</a></li>\n<li><a href=\"https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V14.md#14.15.0\" target=\"_blank\" rel=\"noopener\">Node version14+ release log</a></li>\n<li><a href=\"https://github.com/nodejs/ecmascript-modules/blob/modules-lkgr/doc/api/modules.md#the-module-wrapper\" target=\"_blank\" rel=\"noopener\">Node modules wrapper</a></li>\n<li><a href=\"https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js#L195\" target=\"_blank\" rel=\"noopener\">Node Source code: cjs</a></li>\n<li><a href=\"https://tc39.es/ecma262/#sec-modules\" target=\"_blank\" rel=\"noopener\">ECMA262 Modules</a></li>\n<li><a href=\"https://github.com/tc39/proposal-dynamic-import\" target=\"_blank\" rel=\"noopener\">TC39 Proposal Dynamic import</a></li>\n</ul>"},{"title":"【译】从 ES2016 到 ES2020 的所有特性","date":"2020-07-23T02:24:10.000Z","_content":"自 ECMA2015 (6th) 大幅更新之后, ECMA 标准变更成每年6月发布一个版本进行小幅度更新。为方便温习和查找，汇总一下近五年的所有版本特性。本文共涵盖了 ES2016、ES2017、ES2018、ES2019、ES2020 五个版本的更新内容。翻译有删改，仅供快速查找使用。\n<!--more-->\n\n### 前言：关于ECMA\nECMA 相关stage-x 处于某个阶段，描述的是 ECMA 标准相关的内容。根据提案划分界限，stage-x 大致分为以下阶段:\n\n* stage-0：还是一个设想，只能由 TC39 成员或 TC39 贡献者提出。\n* stage-1：提案阶段，比较正式的提议，只能由 TC39 成员发起，这个提案要解决的问题必须有正式的书面描述。\n* stage-2：草案，有了初始规范，必须对功能语法和语义进行正式描述，包括一些实验性的实现。\n* stage-3：候选，该提议基本已经实现，需要等待实验验证，用户反馈及验收测试通过。\n* stage-4：已完成，必须通过 Test262 验收测试，下一步就纳入 ECMA 标准。\n\n总结起来就是数字越大，越成熟。\n\n### ES2016 新特性\nES2016 只更新了两个特性：\n* Array.prototype.includes()\n* 指数运算符\n\n#### Array.prototype.includes()\n该方法用于检测数组中是否包含某个值，包含则返回 true，否则返回 false。\n````javascript\nlet array = [1, 2, 4, 5];\n\narray.includes(2);\n// true\narray.includes(3);\n// false\n````\n> 结合 fromIndex 使用：\n\n可以为 `.includes()` 提供一个起始索引，默认是 0，接受负数值。\n````javascript\nlet array = [ 1, 3, 5, 7, 9, 11 ];\n\narray.includes(3, 1);\n// find the number 3 starting from array index 1\n// true\narray.includes(5, 4);\n//false\narray.includes(1, -1);\n// find the number 1 starting from the ending of the array going backwards\n// false\narray.includes(11, -3);\n// true\n````\n\n#### 指数操作符 (**)\n在 ES2016 前我们会这样写：\n````javascript\nMath.pow(2, 2);\n// 4\nMath.pow(2, 3);\n// 8\n````\n\n现在，有了指数运算符之后，可以这样写：\n````javascript\n2 ** 2;\n// 4\n2 ** 3;\n// 8\n````\n这在多次操作指数运算的时候很有用：\n````javascript\n2 ** 2 ** 2\n// 16\nMath.pow(Math.pow(2, 2), 2);\n// 16\n````\n`Math.pow()` 需要连续调用，这会使代码看起来很长不宜阅读。使用指数运算符的方式更快更简洁。\n### ES2017 新特性\nES2017 介绍了更多新特性，如 String padding，Object.entries(), Object.values(), 原子性操作， 以及 Async、Await 等。\n#### 字符串填充 ( String.padStart() 和 String.padEnd() )\n`.padStart()` 对字符串头部进行填充， `.padEnd()` 对字符串尾部进行填充：\n````javascript\n\"hello\".padStart(6);\n// \" hello\"\n\"hello\".padEnd(6);\n// \"hello \"\n````\n为什么只填充1个空格而不是6个？是因为 \"hello\" 一共是五个字符，而 `.padStart` 和 `.padEnd` 的入参是填充后的字符串长度，所以之只会填充一个空格。 \n\n> 使用 padStart 实现文本右对齐\n````javascript\nconst strings = [\"short\", \"medium length\", \"very long string\"];\n\nconst longestString = strings.sort((s1, s2) => s2.length - s1.length).map(str => str.length)[0];\n\nstrings.forEach(str => console.log(str.padStart(longestString)));\n\n// very long string\n//    medium length\n//            short\n\n````\n第一步获取了数组中最长字符串的长度，接下来用该长度填充数组中的每个字符串，即打印出一组右对齐的字符串。\n\n> 自定义填充值\n\n除了默认的空格，还可以使用字符串和数字进行填充。\n````javascript\n\"hello\".padEnd(13,\" Alberto\");\n// \"hello Alberto\"\n\"1\".padStart(3, 0);\n// \"001\"\n\"99\".padStart(3, 0);\n// \"099\"\n````\n\n#### Object.entries() 和 Object.values()\n首先创建一个Object：\n````javascript\nconst family = {\n  father: \"Jonathan Kent\",\n  mother: \"Martha Kent\",\n  son: \"Clark Kent\",\n}\n````\n在上个版本的 javascript 中，我们可以使用如下方式获取 Object 中的值：\n````javascript\nObject.keys(family);\n// [\"father\", \"mother\", \"son\"]\nfamily.father;\n\"Jonathan Kent\"\n````\n`Object.keys()` 仅会返回对象中所有的键名。\n\n现在又多了两种可以访问对象的方法：\n\n````javascript\nObject.values(family);\n// [\"Jonathan Kent\", \"Martha Kent\", \"Clark Kent\"]\n\nObject.entries(family);\n// [\"father\", \"Jonathan Kent\"]\n// [\"mother\", \"Martha Kent\"]\n// [\"son\", \"Clark Kent\"]\n````\n`Object.values()` 以数组形式返回对象所有值。\n`Object.entries()` 同样以数组形式返回对象中的键值对。\n\n#### Object.getOwnPropertyDescriptors()\n这个方法会返回对象所有自身属性的描述。描述性的字段有：`value`，`writable`, `get`, `set`, `configurable` 和 `enumerable`。\n````javascript\nconst myObj = {\n  name: \"Alberto\",\n  age: 25,\n  greet() {\n    console.log(\"hello\");\n  },\n}\nObject.getOwnPropertyDescriptors(myObj);\n// age: {value: 25, writable: true, enumerable: true, configurable: true}\n\n// greet: {value: ƒ, writable: true, enumerable: true, configurable: true}\n\n// name: {value: \"Alberto\", writable: true, enumerable: true, configurable: true}\n````\n\n#### 尾行逗号\n这仅仅是语法上的一个小改变。现在在写 Object 属性值时，我们可以在每个值后边加上一个逗号，不论它是否是最后一个。\n````javascript\n// from this\nconst object = {\n  prop1: \"prop\",\n  prop2: \"propop\"\n}\n\n// to this\nconst object = {\n  prop1: \"prop\",\n  prop2: \"propop\",\n}\n````\n注意上述第二个例子中的最后一个逗号，即使你不写它也不会报错，只是写上会更方便的开发者们协作。\n\n#### 共享内存和原子性操作\n下述引自 [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics):\n> 多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。\n\n这些原子操作属于 Atomics 模块。与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math  对象一样）。\n\n方法示例：\n* add / sub\n* and / or / xor\n* load / store\n\n`Atomics` 通常和 `SharedArrayBuffer` 对象（通用的固定长度二进制数据缓冲区）一起使用。\n来看一下几个 `Atomics`方法的使用示例：\n\n##### Atomics.add(), Atomics.sub(), Atomics.load(), and Atomics.store()\n`Atomics.add()` 共接受三个参数：array、index、value。并返回该索引在执行操作前的值。\n\n````javascript\n// create a `SharedArrayBuffer`\nconst buffer = new SharedArrayBuffer(16);\nconst uint8 = new Uint8Array(buffer);\n\n// add a value at the first position\nuint8[0] = 10;\n\nconsole.log(Atomics.add(uint8, 0, 5));\n// 10\n\n// 10 + 5 = 15\nconsole.log(uint8[0])\n// 15\nconsole.log(Atomics.load(uint8, 0));\n// 15\n````\n\n要从数组中检索特定的值，可以使用 `Atomics.load()` 并传递两个参数，一个数组和一个索引。\n`Atomics.sub()` 的使用方式与 `Atomics.add()` 类似，只不过它是减去某个值。\n\n````javascript\n// create a `SharedArrayBuffer`\nconst buffer = new SharedArrayBuffer(16);\nconst uint8 = new Uint8Array(buffer);\n\n// add a value at the first position\nuint8[0] = 10;\n\nconsole.log(Atomics.sub(uint8, 0, 5));\n// 10\n\n// 10 - 5 = 5\nconsole.log(uint8[0])\n// 5\nconsole.log(Atomics.store(uint8, 0, 3));\n// 3\nconsole.log(Atomics.load(uint8, 0));\n// 3\n````\n上述示例调用 `Atomics.sub()` 方法，实现 unit8[0] - 5 ，相当于 10 - 5。如同 `Atomics.add()` 一样，该方法也会返回数组中该索引在执行操作前的值。\n\n使用 `Atomics.store()` 来存储一个值，使用 `Atomics.load()` 来加载一个值。\n\n##### Atomics.and(), Atomics.or(), Atomics.xor()\n这三个方法都在数组的给定位置执行按位的 AND、OR 和 XOR 操作。不再赘述。\n\n#### Async 和 Await\nES2017 提供了两个操作 Promise 的新方法：\"async/await\"。\n\n##### 回顾一下 Promise\n在介绍新语法之前，让我们快速浏览下之前我们是怎么使用 Promise 的：\n````javascript\n// fetch a user from github\nfetch('api.github.com/user/AlbertoMontalesi').then( res => {\n  // return the data in json format\n  return res.json();\n}).then(res => {\n  // if everything went well, print the data\n  console.log(res);\n}).catch( err => {\n  // or print the error\n  console.log(err);\n})\n````\n上述是一个非常简单的例子：请求一个 Github 用户的数据，并打印。下面来看个复杂点的：\n\n````javascript\nfunction walk(amount) {\n  return new Promise((resolve, reject) => {\n    if (amount < 500) {\n      reject (\"the value is too small\");\n    }\n    setTimeout(() => resolve(`you walked for ${amount}ms`),amount);\n  });\n}\n\nwalk(1000).then(res => {\n  console.log(res);\n  return walk(500);\n}).then(res => {\n  console.log(res);\n  return walk(700);\n}).then(res => {\n  console.log(res);\n  return walk(800);\n}).then(res => {\n  console.log(res);\n  return walk(100);\n}).then(res => {\n  console.log(res);\n  return walk(400);\n}).then(res => {\n  console.log(res);\n  return walk(600);\n});\n\n// you walked for 1000ms\n// you walked for 500ms\n// you walked for 700ms\n// you walked for 800ms\n// uncaught exception: the value is too small\n````\n来看下，如何用新语法 async / await 来重写 `Promise`。\n\n##### Async 和 Await\n````javascript\nfunction walk(amount) {\n  return new Promise((resolve, reject) => {\n    if (amount < 500) {\n      reject (\"the value is too small\");\n    }\n    setTimeout(() => resolve(`you walked for ${amount}ms`),amount);\n  });\n}\n\n// create an async function\nasync function go() {\n  // use the keyword `await` to wait for the response\n  const res = await walk(500);\n  console.log(res);\n  const res2 = await walk(900);\n  console.log(res2);\n  const res3 = await walk(600);\n  console.log(res3);\n  const res4 = await walk(700);\n  console.log(res4);\n  const res5 = await walk(400);\n  console.log(res5);\n  console.log(\"finished\");\n}\n\ngo();\n\n// you walked for 500ms \n// you walked for 900ms \n// you walked for 600ms \n// you walked for 700ms \n// uncaught exception: the value is too small\n````\n让我们来分解一下上述代码都做了什么：\n* 创建一个异步函数需要在 function 前面添加 async 关键词\n* 这个关键词会告诉 Javascript 返回一个 Promise\n* 如果指定 async 函数返回一个非 Promise 的值，那么这个值将会被包含在 Promise 中然后被返回\n* 顾名思义， await 会告诉 Javascript 等待 promise 返回结果\n\n##### 错误处理\n通常在 promise 中，我们使用 `.catch()` 捕获最终的错误。现在有一点不同了：\n````javascript\nasync function asyncFunc() {\n\n  try {\n    let response = await fetch('http:your-url');\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nasyncFunc();\n// TypeError: failed to fetch\n````\n\n### ES2018 新特性\n\n#### 对象扩展运算符\n还记得 ES6 中我们可以使用扩展运算符来做什么吗：\n````javascript\nconst veggie = [\"tomato\", \"cucumber\", \"beans\"];\nconst meat = [\"pork\", \"beef\", \"chicken\"];\n\nconst menu = [...veggie, \"pasta\", ...meat];\nconsole.log(menu);\n// Array [ \"tomato\", \"cucumber\", \"beans\", \"pasta\", \"pork\", \"beef\", \"chicken\" ]\n````\n现在，扩展运算符同样适用于对象：\n````javascript\nlet myObj = {\n  a: 1,\n  b: 3,\n  c: 5,\n  d: 8,\n}\n\n// we use the rest operator to grab everything else left in the object.\nlet { a, b, ...z } = myObj;\nconsole.log(a);     // 1\nconsole.log(b);     // 3\nconsole.log(z);     // {c: 5, d: 8}\n\n// using the spread syntax we cloned our Object\nlet clone = { ...myObj };\nconsole.log(clone);\n// {a: 1, b: 3, c: 5, d: 8}\nmyObj.e = 15;\nconsole.log(clone)\n// {a: 1, b: 3, c: 5, d: 8}\nconsole.log(myObj)\n// {a: 1, b: 3, c: 5, d: 8, e: 15}\n````\n使用扩展运算符，我们可以轻松的复制对象（浅复制）。\n\n#### 异步的迭代\n使用异步的迭代，我们可以异步的遍历数据。\n[引自文档](https://github.com/tc39/proposal-async-iteration)\n> 异步迭代器很像迭代器，只不过迭代器的 next 方法返回一对 { value, done }\n\n为此，我们将使用一个 `for-await-of` 循环，它将迭代转换成 Promise。\n````javascript\nconst iterables = [1, 2, 3];\n\nasync function test() {\n  for await (const value of iterables) {\n    console.log(value);\n  }\n}\n\ntest();\n// 1\n// 2\n// 3\n````\n在执行过程中，`[Symbol.asyncIterator]()` 方法将会创造一个异步的迭代器，每次访问序列中的下一个值时，我们都会隐式地等待迭代器方法返回 Promise。\n\n#### Promise.prototype.finally()\n引自 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally):\n> \n> finally() 方法返回一个 Promise。在 Promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。这为在 Promise 是否成功完成后都需要执行的代码提供了一种方式。避免了同样的语句需要在 then() 和 catch() 中各写一次的情况。\n````javascript\nconst myPromise = new Promise((resolve, reject) => {\n  resolve();\n})；\n\nmyPromise\n  .then(() => {\n    console.log('still working');\n  })\n  .catch(() => {\n    console.log('there was an error');\n  })\n  .finally(()=> {\n    console.log('Done!');\n  })\n````\n`.finally()` 同样会返回一个 promise，所以我们可以继续链式调用 `then` 和 `catch` 方法，但是它们是基于之前的 promise 进行调用的。\n````javascript\nconst myPromise = new Promise((resolve, reject) => {\n  resolve();\n})；\n\nmyPromise\n  .then(() => {\n    console.log('still working');\n    return 'still working';\n  })\n  .finally(()=> {\n    console.log('Done!');\n    return 'Done!';\n  })\n  .then(res => {\n    console.log(res);\n  })\n// still working\n// Done!\n// still working\n````\n从上边代码可以看到 `finally` 后边的 `then` 返回的值是由第一个 `then` 创建的，而不是 `finally`。\n\n#### 正则表达式的新特性\n在新版的 ECMA 中，共更新了 4 个关于正则的特性。\n\n* 正则表达式的 s (doAll) 标志\n* 正则表达式捕获组命名\n* 正则表达式反向断言 (Lookbehind Assertions)\n* unicode 字符转义 (Unicode property escapes) \n\n##### s (doAll) 标志\n> 引自[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll)\n\n`dotAll` 属性表明是否在正则表达式中一起使用 \"`s`\" 修饰符（引入 /s 修饰符，使得`.`可以匹配任意单个字符，包括换行符和回车符）\n````javascript\n/foo.bar/s.test('foo\\nbar');\n// true\n````\n\n##### 捕获组命名\n> 想要引用正则匹配到的某一部分字符串可以为捕获组编号。每个捕获组的数字都是唯一的，可以对应的数字引用它们，但是这使正则表达式难以阅读和维护。例如 `/(\\d{4})-(\\d{2})-(\\d{2})/` 匹配一个日期，但如果不看上下文的代码，就无法确定哪一组对应于月份，哪一组是一天。当然，如果哪一天需要交换日期和月份的顺序，那么对应的组引用也需要更新。现在，可以使用 `(?<name>...)` 来为捕获组命名，以表示任何标识符名称。重写上述例子：`/(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u` 每一个命名都是唯一且遵循 ECMA 命名规范的。命名的组可以通过匹配结果的 `result` 属性来访问。对组的数字引用也会被建立，就像未命名的组一样。看下边几个例子：\n\n````javascript\nlet re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\nlet result = re.exec('2015-01-02');\n// result.groups.year === '2015';\n// result.groups.month === '01';\n// result.groups.day === '02';\n\n// result[0] === '2015-01-02';\n// result[1] === '2015';\n// result[2] === '01';\n// result[3] === '02';\n\nlet { groups: { one, two } } = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');\nconsole.log(`one: ${one}, two: ${two}`); \n// one: foo, two: bar\n````\n\n##### 反向断言\n> 使用反向断言可以确保匹配之前或者之后没有其他匹配。反向断言的语法表示为 `(?<=...)` 。\n> 例如：匹配一个美元数值且不包含美元符号可以这样写 `/(?<=$)\\d+(\\.\\d*)?/`，这个表达式会匹配 `$10.53` 并返回 `10.53`，而并不会匹配 `€10.53`。而 `(?<!...)` 匹配的规则正相反，它会匹配不存在表达式中的匹配项，例如 `/(?<!$)\\d+(?:\\.\\d*)/` 不会匹配 `$10.53`，但是会匹配 `€10.53`。\n\n##### Unicode 字符转义\n> Unicode 字符转义是一种新的转义序列，`u` 作为字符转义的标志， `\\p{...}` 和 `\\P{...}` 用来添加转义符。有了这个特性，匹配 Unicode 字符可以这样写：\n````javascript\nconst regexGreekSymbol = /\\p{Script=Greek}/u;\nregexGreekSymbol.test('π');\n// true\n````\n\n#### 解除模板字符限制\n当使用 Tagged 模板字符串时，转义字符的限制被移除了（[阅读更多](https://tc39.github.io/proposal-template-literal-revision/#sec-template-literals)）\n\n### ES2019 新特性\n\n#### Array.prototype.flat() / Array.prototype.flatMap()\n`Array.prototype.flat()` 会递归地展平一个数组并作为新值返回，它接受一个表示递归深度的值，未传值则默认深度为1。可以用 `Infinity` 去展平所有嵌套的数组。\n\n````javascript\nconst letters = ['a', 'b', ['c', 'd', ['e', 'f']]];\n// default depth of 1\nletters.flat();\n// ['a', 'b', 'c', 'd', ['e', 'f']]\n\n// depth of 2\nletters.flat(2);\n// ['a', 'b', 'c', 'd', 'e', 'f']\n\n// which is the same as executing flat with depth of 1 twice\nletters.flat().flat();\n// ['a', 'b', 'c', 'd', 'e', 'f']\n\n// Flattens recursively until the array contains no nested arrays\nletters.flat(Infinity)\n// ['a', 'b', 'c', 'd', 'e', 'f']\n````\n\n`Array.prototype.flatMap()` 与深度值为1的 flat 几乎相同，但它并非仅仅展平数组。 flatMap 接收一个处理函数，使用 `flatMap()` 可以在展平的同时更改对应的值并返回一个新的数组。\n````javascript\nlet greeting = [\"Greetings from\", \" \", \"Vietnam\"];\ngreeting.flatMap(x => x.split(\" \"))\n// [\"Greetings\", \"from\", \"\", \"\", \"Vietnam\"]\n````\n这有点类似于 `map()` 方法，只不过多了一次展平操作。\n\n#### Object.fromEntries()\nObject.fromEntries() 将一组键值对转换成对象。\n\n````javascript\nconst keyValueArray = [\n  ['key1', 'value1'],\n  ['key2', 'value2']\n]\n\nconst obj = Object.fromEntries(keyValueArray)\n// {key1: \"value1\", key2: \"value2\"}\n````\n我们可以将任何可迭代的值作为 `Object.entries()` 方法的参数，不论它是一个 `Array` 还是 `Map`，或是其他实现了迭代协议的值。\n\n注：可迭代协议( Iteration Protocols )是 ES2015 提出的，通常通过常量 `Symbol.iterator` 访问该对象的可迭代属性。\n````javascript\nvar someString = \"hi\";\ntypeof someString[Symbol.iterator]; // \"function\"\nvar iterator = someString[Symbol.iterator]();\n\niterator + \"\";  // \"[object String Iterator]\"\niterator.next()    // { value: \"h\", done: false }\niterator.next();   // { value: \"i\", done: false }\niterator.next();   // { value: undefined, done: true }\n````\n[阅读更多关于迭代协议的内容](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)\n\n#### String.prototype.trimStart() / .trimEnd()\n`String.prototype.trimStart()` 移除字符串前面的空白符，`String.prototype.trimEnd()` 移除字符串后面的空白符。\n````javascript\nlet str = \"    this string has a lot of whitespace   \";\n\nstr.length;\n// 42\n\nstr = str.trimStart();\n// \"this string has a lot of whitespace   \"\nstr.length;\n// 38\n\nstr = str.trimEnd();\n// \"this string has a lot of whitespace\"\nstr.length;\n// 35\n````\n也可以使用 `.trimStart()` 和 `trimEnd()` 的别名： `.trimLeft()` 和 `.trimRight()` 。\n\n#### 可选的 catch 捕获参数\n在 ES2019 之前，你必须为 catch 捕获传递一个表示异常的变量，现在这个变量不是必要的了。\n````javascript\n// Before\ntry {\n   ...\n} catch(error) {\n   ...\n}\n\n// ES2019\ntry {\n   ...\n} catch {\n   ...\n}\n````\n这在你想忽略错误参数的时候很有用。\n\n#### Function.ptototype.toString()\n`.toString()` 方法返回一个代表函数源码的字符串。\n````javascript\nfunction sum(a, b) {\n  return a + b;\n}\n\nconsole.log(sum.toString());\n// function sum(a, b) {\n//    return a + b;\n//  }\n````\n\n注释也会被包含其中：\n````javascript\nfunction sum(a, b) {\n  // perform a sum\n  return a + b;\n}\n\nconsole.log(sum.toString());\n// function sum(a, b) {\n//   // perform a sum\n//   return a + b;\n// }\n````\n\n#### Symbol.prototype.description\n`.description` 返回 `Symbol` 对象可选描述的字符串。\n````javascript\nconst me = Symbol(\"Alberto\");\nme.description;\n// \"Alberto\"\n\nme.toString()\n//  \"Symbol(Alberto)\"\n````\n\n### ES2020 特性\n#### BigInt 类型\nBigInt 是 JavaScript 第七个原始类型，它允许开发者操作非常大的整型。\n数字类型可以处理 `2 ** 53 - 1` 即 `9007199254740991` 以内的数。可以通过常量 `MAX_SAFE_INTEGER` 来访问这个值。\n````javascript\nNumber.MAX_SAFE_INTEGER; // 9007199254740991\n````\n顾名思义，若操作的 number 值超过最大值时,运行结果就会变的奇怪。使用 `BigInt` 类型则没有明确的界限，因为它的界限取决于运行设备的内存。\n定义 `BigInt` 类型，你即可以通过给 `BigInt()` 构造函数传递一个字符串值来创建，也可以像平常一样使用字面量语法来创建，但是要在尾部加上一个字符 `n`。\n````javascript\nconst myBigInt = BigInt(\"999999999999999999999999999999\");\nconst mySecondBigInt = 999999999999999999999999999999n;\n\ntypeof myBigInt; // \"bigint\"\n````\n注意，`BigInt` 类型与常规类型的数字并不是完全兼容的，这意味这你确定最好仅在操作比较大的数据时使用它。\n\n````javascript\nconst bigInt = 1n; // small number, but still of BigInt type\nconst num = 1;\n\nnum === bigInt; // false -> they aren't strictly equal\nnum == bigInt; // true\nnum >= bigInt; // true -> they can be compared\nnum + bigInt; // error -> they can't operate with one another\n````\n总之，使用 JS 做比较复杂的数学运算时 `BigInt` 是个不错的选择。它在替换专门用于处理大量数字的库方面表现良好。现在至少在整型方向有所进展，而目前我们对 `BigDecimal` 的提案了解的还很少。\n\n#### 动态导入（Dynamic imports）\n动态导入，允许在浏览器端动态地加载代码模块。使用 `import()` 语法来导入你的代码块。\n````javascript\nimport(\"module.js\").then((module) => {\n  // ...\n});\n\n// or\nasync () => {\n  const module = await import(\"module.js\");\n};\n````\n`import()` 返回一个 promise，resolve 中会返回代码模块加载后的内容。可以使用 ES6 的 `.then()` 方法或者 `async/await` 来处理加载结果。\n\n#### 空值合并操作符（??）\n空值合并操作符（??）是一个新的 JS 运算符，当所访问的值是 null 或者 undefined 时，它会提供一个默认值。\n````javascript\nconst basicValue = \"test\";\nconst nullishValue = null;\n\nconst firstExample = basicValue ?? \"example\"; // \"test\"\nconst secondExample = nullishValue ?? \"example\"; // \"example\"\n````\n但是这跟 逻辑或（||）有什么区别呢？当第一个数是虚值 (在 Boolean 上下文中认定为 false 的值)，如 `false`, `0`, 或者`\"\"`，以及空值 `null` 和 `undefined`，那么 逻辑或 将会使用第二个操作数。而空值合并操作符仅仅是在第一个值为空值而不是虚值的时候才会使用第二个操作数。如果你的代码可以接受除了 `null` 和 `undefined` 以外的任何值，那么空值合并操作符就是最佳选择。\n\n````javascript\nconst falseValue = false;\nconst zeroValue = 0;\nconst emptyValue = \"\";\nconst nullishValue = null;\n\nconst firstExampleOR = falseValue || \"example\"; // \"example\"\nconst secondExampleOR = zeroValue || \"example\"; // \"example\"\nconst thirdExampleOR = emptyValue || \"example\"; // \"example\"\nconst forthExampleOR = nullish || \"example\"; // \"example\"\n\nconst firstExample = falseValue ?? \"example\"; // false\nconst secondExample = zeroValue ?? \"example\"; // 0\nconst thirdExample = emptyValue ?? \"example\"; // \"\"\nconst forthExample = nullish ?? \"example\"; // \"example\"\n````\n#### 可选链（?.）\n与空值合并操作符类似，只不过可选链是处理 Object 中 `null` 和 `undefined` 的。鉴于直接从空值中国获取属性值会报错，现在可选链会直接将空值返回。\n````javascript\nconst obj = {\n  prop: {\n    subProp: {\n      value: 1,\n    },\n  },\n};\n\nobj.prop.subProp.value; // 1\nobj.prop.secondSubProp.value; // error\n\nobj?.prop?.subProp?.value; // 1\nobj?.prop?.secondSubProp?.value; // undefined\n````\n当然，这只是一个语法糖，但也是一个很受欢迎的补充。记住不要在代码里到处使用这些操作符，他们虽然用起来方便，但从性能角度来说，它比普通的 `.` 开销要大。而且，若是代码是经过 Babel 和 TypeScript 转义的，则更要谨慎使用。\n\n#### GlobalThis\n由于 JavaScript 的代码可以运行在多个不同的环境，例如 浏览器、Node.js、Web Worker 等，要实现这种交叉兼容性绝非易事，globalThis 的出现方便了这些操作。\n`globalThis` 是一个新的全局属性，通常它引用的是当前环境下的全局对象。就像是 `self` 对于 Web Workers，`window` 对于浏览器，`global` 对于 Node.js，以及其他实现了ES2020标准的运行环境。\n\n````javascript\n// Hacky globalThis polyfill you had to use pre-ES2020\nconst getGlobal = () => {\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"Couldn't detect global\");\n};\n\ngetGlobal() === globalThis; // true (for browser, Web Worker and Node.js)\nglobalThis === window; // true (if you're in browser)\n````\n\n#### Promise.allSettled()\n这个新增的方法看起来有点像 `Promise.all()`。\n`Promise.all()` 的参数中的 promise 若有一个失败，则此实例回调失败。而 `Promise.allSettled()`不论成功或者失败，都会返回处理结束后的对象数组。\n\n#### String.matchAll()\n如果你之前使用正则，那么相比于在 `while` 循环中使用 `RegExp.exec()` 并开启标志 `g` 来匹配，`String.matchAll()` 会是更好的选择。它会返回一个包含了所有匹配结果的数组，包括捕获组的匹配结果。\n\n````javascript\nconst regexp = /t(e)(st(\\d?))/g;\nconst str = \"test1test2\";\nconst resultsArr = [...str.matchAll(regexp)]; // convert iterator to an array\n\nresultsArr[0]; // [\"test1\", \"e\", \"st1\", \"1\"]\nresultsArr[1]; // [\"test2\", \"e\", \"st2\", \"2\"]\n````\n\n### 原文链接\n* [everything-from-es-2016-to-es-2019](https://inspiredwebdev.com/everything-from-es-2016-to-es-2019)\n* [ecmascript-2020-biggest-new-features](https://areknawo.com/ecmascript-2020-biggest-new-features/)","source":"_posts/【译】从-ES2016-到-ES2020-的所有特性.md","raw":"---\ntitle: 【译】从 ES2016 到 ES2020 的所有特性\ndate: 2020-07-23 10:24:10\ntags: [JavaScript]\ncategories: [前端，JavaScript]\n---\n自 ECMA2015 (6th) 大幅更新之后, ECMA 标准变更成每年6月发布一个版本进行小幅度更新。为方便温习和查找，汇总一下近五年的所有版本特性。本文共涵盖了 ES2016、ES2017、ES2018、ES2019、ES2020 五个版本的更新内容。翻译有删改，仅供快速查找使用。\n<!--more-->\n\n### 前言：关于ECMA\nECMA 相关stage-x 处于某个阶段，描述的是 ECMA 标准相关的内容。根据提案划分界限，stage-x 大致分为以下阶段:\n\n* stage-0：还是一个设想，只能由 TC39 成员或 TC39 贡献者提出。\n* stage-1：提案阶段，比较正式的提议，只能由 TC39 成员发起，这个提案要解决的问题必须有正式的书面描述。\n* stage-2：草案，有了初始规范，必须对功能语法和语义进行正式描述，包括一些实验性的实现。\n* stage-3：候选，该提议基本已经实现，需要等待实验验证，用户反馈及验收测试通过。\n* stage-4：已完成，必须通过 Test262 验收测试，下一步就纳入 ECMA 标准。\n\n总结起来就是数字越大，越成熟。\n\n### ES2016 新特性\nES2016 只更新了两个特性：\n* Array.prototype.includes()\n* 指数运算符\n\n#### Array.prototype.includes()\n该方法用于检测数组中是否包含某个值，包含则返回 true，否则返回 false。\n````javascript\nlet array = [1, 2, 4, 5];\n\narray.includes(2);\n// true\narray.includes(3);\n// false\n````\n> 结合 fromIndex 使用：\n\n可以为 `.includes()` 提供一个起始索引，默认是 0，接受负数值。\n````javascript\nlet array = [ 1, 3, 5, 7, 9, 11 ];\n\narray.includes(3, 1);\n// find the number 3 starting from array index 1\n// true\narray.includes(5, 4);\n//false\narray.includes(1, -1);\n// find the number 1 starting from the ending of the array going backwards\n// false\narray.includes(11, -3);\n// true\n````\n\n#### 指数操作符 (**)\n在 ES2016 前我们会这样写：\n````javascript\nMath.pow(2, 2);\n// 4\nMath.pow(2, 3);\n// 8\n````\n\n现在，有了指数运算符之后，可以这样写：\n````javascript\n2 ** 2;\n// 4\n2 ** 3;\n// 8\n````\n这在多次操作指数运算的时候很有用：\n````javascript\n2 ** 2 ** 2\n// 16\nMath.pow(Math.pow(2, 2), 2);\n// 16\n````\n`Math.pow()` 需要连续调用，这会使代码看起来很长不宜阅读。使用指数运算符的方式更快更简洁。\n### ES2017 新特性\nES2017 介绍了更多新特性，如 String padding，Object.entries(), Object.values(), 原子性操作， 以及 Async、Await 等。\n#### 字符串填充 ( String.padStart() 和 String.padEnd() )\n`.padStart()` 对字符串头部进行填充， `.padEnd()` 对字符串尾部进行填充：\n````javascript\n\"hello\".padStart(6);\n// \" hello\"\n\"hello\".padEnd(6);\n// \"hello \"\n````\n为什么只填充1个空格而不是6个？是因为 \"hello\" 一共是五个字符，而 `.padStart` 和 `.padEnd` 的入参是填充后的字符串长度，所以之只会填充一个空格。 \n\n> 使用 padStart 实现文本右对齐\n````javascript\nconst strings = [\"short\", \"medium length\", \"very long string\"];\n\nconst longestString = strings.sort((s1, s2) => s2.length - s1.length).map(str => str.length)[0];\n\nstrings.forEach(str => console.log(str.padStart(longestString)));\n\n// very long string\n//    medium length\n//            short\n\n````\n第一步获取了数组中最长字符串的长度，接下来用该长度填充数组中的每个字符串，即打印出一组右对齐的字符串。\n\n> 自定义填充值\n\n除了默认的空格，还可以使用字符串和数字进行填充。\n````javascript\n\"hello\".padEnd(13,\" Alberto\");\n// \"hello Alberto\"\n\"1\".padStart(3, 0);\n// \"001\"\n\"99\".padStart(3, 0);\n// \"099\"\n````\n\n#### Object.entries() 和 Object.values()\n首先创建一个Object：\n````javascript\nconst family = {\n  father: \"Jonathan Kent\",\n  mother: \"Martha Kent\",\n  son: \"Clark Kent\",\n}\n````\n在上个版本的 javascript 中，我们可以使用如下方式获取 Object 中的值：\n````javascript\nObject.keys(family);\n// [\"father\", \"mother\", \"son\"]\nfamily.father;\n\"Jonathan Kent\"\n````\n`Object.keys()` 仅会返回对象中所有的键名。\n\n现在又多了两种可以访问对象的方法：\n\n````javascript\nObject.values(family);\n// [\"Jonathan Kent\", \"Martha Kent\", \"Clark Kent\"]\n\nObject.entries(family);\n// [\"father\", \"Jonathan Kent\"]\n// [\"mother\", \"Martha Kent\"]\n// [\"son\", \"Clark Kent\"]\n````\n`Object.values()` 以数组形式返回对象所有值。\n`Object.entries()` 同样以数组形式返回对象中的键值对。\n\n#### Object.getOwnPropertyDescriptors()\n这个方法会返回对象所有自身属性的描述。描述性的字段有：`value`，`writable`, `get`, `set`, `configurable` 和 `enumerable`。\n````javascript\nconst myObj = {\n  name: \"Alberto\",\n  age: 25,\n  greet() {\n    console.log(\"hello\");\n  },\n}\nObject.getOwnPropertyDescriptors(myObj);\n// age: {value: 25, writable: true, enumerable: true, configurable: true}\n\n// greet: {value: ƒ, writable: true, enumerable: true, configurable: true}\n\n// name: {value: \"Alberto\", writable: true, enumerable: true, configurable: true}\n````\n\n#### 尾行逗号\n这仅仅是语法上的一个小改变。现在在写 Object 属性值时，我们可以在每个值后边加上一个逗号，不论它是否是最后一个。\n````javascript\n// from this\nconst object = {\n  prop1: \"prop\",\n  prop2: \"propop\"\n}\n\n// to this\nconst object = {\n  prop1: \"prop\",\n  prop2: \"propop\",\n}\n````\n注意上述第二个例子中的最后一个逗号，即使你不写它也不会报错，只是写上会更方便的开发者们协作。\n\n#### 共享内存和原子性操作\n下述引自 [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics):\n> 多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。\n\n这些原子操作属于 Atomics 模块。与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math  对象一样）。\n\n方法示例：\n* add / sub\n* and / or / xor\n* load / store\n\n`Atomics` 通常和 `SharedArrayBuffer` 对象（通用的固定长度二进制数据缓冲区）一起使用。\n来看一下几个 `Atomics`方法的使用示例：\n\n##### Atomics.add(), Atomics.sub(), Atomics.load(), and Atomics.store()\n`Atomics.add()` 共接受三个参数：array、index、value。并返回该索引在执行操作前的值。\n\n````javascript\n// create a `SharedArrayBuffer`\nconst buffer = new SharedArrayBuffer(16);\nconst uint8 = new Uint8Array(buffer);\n\n// add a value at the first position\nuint8[0] = 10;\n\nconsole.log(Atomics.add(uint8, 0, 5));\n// 10\n\n// 10 + 5 = 15\nconsole.log(uint8[0])\n// 15\nconsole.log(Atomics.load(uint8, 0));\n// 15\n````\n\n要从数组中检索特定的值，可以使用 `Atomics.load()` 并传递两个参数，一个数组和一个索引。\n`Atomics.sub()` 的使用方式与 `Atomics.add()` 类似，只不过它是减去某个值。\n\n````javascript\n// create a `SharedArrayBuffer`\nconst buffer = new SharedArrayBuffer(16);\nconst uint8 = new Uint8Array(buffer);\n\n// add a value at the first position\nuint8[0] = 10;\n\nconsole.log(Atomics.sub(uint8, 0, 5));\n// 10\n\n// 10 - 5 = 5\nconsole.log(uint8[0])\n// 5\nconsole.log(Atomics.store(uint8, 0, 3));\n// 3\nconsole.log(Atomics.load(uint8, 0));\n// 3\n````\n上述示例调用 `Atomics.sub()` 方法，实现 unit8[0] - 5 ，相当于 10 - 5。如同 `Atomics.add()` 一样，该方法也会返回数组中该索引在执行操作前的值。\n\n使用 `Atomics.store()` 来存储一个值，使用 `Atomics.load()` 来加载一个值。\n\n##### Atomics.and(), Atomics.or(), Atomics.xor()\n这三个方法都在数组的给定位置执行按位的 AND、OR 和 XOR 操作。不再赘述。\n\n#### Async 和 Await\nES2017 提供了两个操作 Promise 的新方法：\"async/await\"。\n\n##### 回顾一下 Promise\n在介绍新语法之前，让我们快速浏览下之前我们是怎么使用 Promise 的：\n````javascript\n// fetch a user from github\nfetch('api.github.com/user/AlbertoMontalesi').then( res => {\n  // return the data in json format\n  return res.json();\n}).then(res => {\n  // if everything went well, print the data\n  console.log(res);\n}).catch( err => {\n  // or print the error\n  console.log(err);\n})\n````\n上述是一个非常简单的例子：请求一个 Github 用户的数据，并打印。下面来看个复杂点的：\n\n````javascript\nfunction walk(amount) {\n  return new Promise((resolve, reject) => {\n    if (amount < 500) {\n      reject (\"the value is too small\");\n    }\n    setTimeout(() => resolve(`you walked for ${amount}ms`),amount);\n  });\n}\n\nwalk(1000).then(res => {\n  console.log(res);\n  return walk(500);\n}).then(res => {\n  console.log(res);\n  return walk(700);\n}).then(res => {\n  console.log(res);\n  return walk(800);\n}).then(res => {\n  console.log(res);\n  return walk(100);\n}).then(res => {\n  console.log(res);\n  return walk(400);\n}).then(res => {\n  console.log(res);\n  return walk(600);\n});\n\n// you walked for 1000ms\n// you walked for 500ms\n// you walked for 700ms\n// you walked for 800ms\n// uncaught exception: the value is too small\n````\n来看下，如何用新语法 async / await 来重写 `Promise`。\n\n##### Async 和 Await\n````javascript\nfunction walk(amount) {\n  return new Promise((resolve, reject) => {\n    if (amount < 500) {\n      reject (\"the value is too small\");\n    }\n    setTimeout(() => resolve(`you walked for ${amount}ms`),amount);\n  });\n}\n\n// create an async function\nasync function go() {\n  // use the keyword `await` to wait for the response\n  const res = await walk(500);\n  console.log(res);\n  const res2 = await walk(900);\n  console.log(res2);\n  const res3 = await walk(600);\n  console.log(res3);\n  const res4 = await walk(700);\n  console.log(res4);\n  const res5 = await walk(400);\n  console.log(res5);\n  console.log(\"finished\");\n}\n\ngo();\n\n// you walked for 500ms \n// you walked for 900ms \n// you walked for 600ms \n// you walked for 700ms \n// uncaught exception: the value is too small\n````\n让我们来分解一下上述代码都做了什么：\n* 创建一个异步函数需要在 function 前面添加 async 关键词\n* 这个关键词会告诉 Javascript 返回一个 Promise\n* 如果指定 async 函数返回一个非 Promise 的值，那么这个值将会被包含在 Promise 中然后被返回\n* 顾名思义， await 会告诉 Javascript 等待 promise 返回结果\n\n##### 错误处理\n通常在 promise 中，我们使用 `.catch()` 捕获最终的错误。现在有一点不同了：\n````javascript\nasync function asyncFunc() {\n\n  try {\n    let response = await fetch('http:your-url');\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nasyncFunc();\n// TypeError: failed to fetch\n````\n\n### ES2018 新特性\n\n#### 对象扩展运算符\n还记得 ES6 中我们可以使用扩展运算符来做什么吗：\n````javascript\nconst veggie = [\"tomato\", \"cucumber\", \"beans\"];\nconst meat = [\"pork\", \"beef\", \"chicken\"];\n\nconst menu = [...veggie, \"pasta\", ...meat];\nconsole.log(menu);\n// Array [ \"tomato\", \"cucumber\", \"beans\", \"pasta\", \"pork\", \"beef\", \"chicken\" ]\n````\n现在，扩展运算符同样适用于对象：\n````javascript\nlet myObj = {\n  a: 1,\n  b: 3,\n  c: 5,\n  d: 8,\n}\n\n// we use the rest operator to grab everything else left in the object.\nlet { a, b, ...z } = myObj;\nconsole.log(a);     // 1\nconsole.log(b);     // 3\nconsole.log(z);     // {c: 5, d: 8}\n\n// using the spread syntax we cloned our Object\nlet clone = { ...myObj };\nconsole.log(clone);\n// {a: 1, b: 3, c: 5, d: 8}\nmyObj.e = 15;\nconsole.log(clone)\n// {a: 1, b: 3, c: 5, d: 8}\nconsole.log(myObj)\n// {a: 1, b: 3, c: 5, d: 8, e: 15}\n````\n使用扩展运算符，我们可以轻松的复制对象（浅复制）。\n\n#### 异步的迭代\n使用异步的迭代，我们可以异步的遍历数据。\n[引自文档](https://github.com/tc39/proposal-async-iteration)\n> 异步迭代器很像迭代器，只不过迭代器的 next 方法返回一对 { value, done }\n\n为此，我们将使用一个 `for-await-of` 循环，它将迭代转换成 Promise。\n````javascript\nconst iterables = [1, 2, 3];\n\nasync function test() {\n  for await (const value of iterables) {\n    console.log(value);\n  }\n}\n\ntest();\n// 1\n// 2\n// 3\n````\n在执行过程中，`[Symbol.asyncIterator]()` 方法将会创造一个异步的迭代器，每次访问序列中的下一个值时，我们都会隐式地等待迭代器方法返回 Promise。\n\n#### Promise.prototype.finally()\n引自 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally):\n> \n> finally() 方法返回一个 Promise。在 Promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。这为在 Promise 是否成功完成后都需要执行的代码提供了一种方式。避免了同样的语句需要在 then() 和 catch() 中各写一次的情况。\n````javascript\nconst myPromise = new Promise((resolve, reject) => {\n  resolve();\n})；\n\nmyPromise\n  .then(() => {\n    console.log('still working');\n  })\n  .catch(() => {\n    console.log('there was an error');\n  })\n  .finally(()=> {\n    console.log('Done!');\n  })\n````\n`.finally()` 同样会返回一个 promise，所以我们可以继续链式调用 `then` 和 `catch` 方法，但是它们是基于之前的 promise 进行调用的。\n````javascript\nconst myPromise = new Promise((resolve, reject) => {\n  resolve();\n})；\n\nmyPromise\n  .then(() => {\n    console.log('still working');\n    return 'still working';\n  })\n  .finally(()=> {\n    console.log('Done!');\n    return 'Done!';\n  })\n  .then(res => {\n    console.log(res);\n  })\n// still working\n// Done!\n// still working\n````\n从上边代码可以看到 `finally` 后边的 `then` 返回的值是由第一个 `then` 创建的，而不是 `finally`。\n\n#### 正则表达式的新特性\n在新版的 ECMA 中，共更新了 4 个关于正则的特性。\n\n* 正则表达式的 s (doAll) 标志\n* 正则表达式捕获组命名\n* 正则表达式反向断言 (Lookbehind Assertions)\n* unicode 字符转义 (Unicode property escapes) \n\n##### s (doAll) 标志\n> 引自[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll)\n\n`dotAll` 属性表明是否在正则表达式中一起使用 \"`s`\" 修饰符（引入 /s 修饰符，使得`.`可以匹配任意单个字符，包括换行符和回车符）\n````javascript\n/foo.bar/s.test('foo\\nbar');\n// true\n````\n\n##### 捕获组命名\n> 想要引用正则匹配到的某一部分字符串可以为捕获组编号。每个捕获组的数字都是唯一的，可以对应的数字引用它们，但是这使正则表达式难以阅读和维护。例如 `/(\\d{4})-(\\d{2})-(\\d{2})/` 匹配一个日期，但如果不看上下文的代码，就无法确定哪一组对应于月份，哪一组是一天。当然，如果哪一天需要交换日期和月份的顺序，那么对应的组引用也需要更新。现在，可以使用 `(?<name>...)` 来为捕获组命名，以表示任何标识符名称。重写上述例子：`/(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u` 每一个命名都是唯一且遵循 ECMA 命名规范的。命名的组可以通过匹配结果的 `result` 属性来访问。对组的数字引用也会被建立，就像未命名的组一样。看下边几个例子：\n\n````javascript\nlet re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\nlet result = re.exec('2015-01-02');\n// result.groups.year === '2015';\n// result.groups.month === '01';\n// result.groups.day === '02';\n\n// result[0] === '2015-01-02';\n// result[1] === '2015';\n// result[2] === '01';\n// result[3] === '02';\n\nlet { groups: { one, two } } = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');\nconsole.log(`one: ${one}, two: ${two}`); \n// one: foo, two: bar\n````\n\n##### 反向断言\n> 使用反向断言可以确保匹配之前或者之后没有其他匹配。反向断言的语法表示为 `(?<=...)` 。\n> 例如：匹配一个美元数值且不包含美元符号可以这样写 `/(?<=$)\\d+(\\.\\d*)?/`，这个表达式会匹配 `$10.53` 并返回 `10.53`，而并不会匹配 `€10.53`。而 `(?<!...)` 匹配的规则正相反，它会匹配不存在表达式中的匹配项，例如 `/(?<!$)\\d+(?:\\.\\d*)/` 不会匹配 `$10.53`，但是会匹配 `€10.53`。\n\n##### Unicode 字符转义\n> Unicode 字符转义是一种新的转义序列，`u` 作为字符转义的标志， `\\p{...}` 和 `\\P{...}` 用来添加转义符。有了这个特性，匹配 Unicode 字符可以这样写：\n````javascript\nconst regexGreekSymbol = /\\p{Script=Greek}/u;\nregexGreekSymbol.test('π');\n// true\n````\n\n#### 解除模板字符限制\n当使用 Tagged 模板字符串时，转义字符的限制被移除了（[阅读更多](https://tc39.github.io/proposal-template-literal-revision/#sec-template-literals)）\n\n### ES2019 新特性\n\n#### Array.prototype.flat() / Array.prototype.flatMap()\n`Array.prototype.flat()` 会递归地展平一个数组并作为新值返回，它接受一个表示递归深度的值，未传值则默认深度为1。可以用 `Infinity` 去展平所有嵌套的数组。\n\n````javascript\nconst letters = ['a', 'b', ['c', 'd', ['e', 'f']]];\n// default depth of 1\nletters.flat();\n// ['a', 'b', 'c', 'd', ['e', 'f']]\n\n// depth of 2\nletters.flat(2);\n// ['a', 'b', 'c', 'd', 'e', 'f']\n\n// which is the same as executing flat with depth of 1 twice\nletters.flat().flat();\n// ['a', 'b', 'c', 'd', 'e', 'f']\n\n// Flattens recursively until the array contains no nested arrays\nletters.flat(Infinity)\n// ['a', 'b', 'c', 'd', 'e', 'f']\n````\n\n`Array.prototype.flatMap()` 与深度值为1的 flat 几乎相同，但它并非仅仅展平数组。 flatMap 接收一个处理函数，使用 `flatMap()` 可以在展平的同时更改对应的值并返回一个新的数组。\n````javascript\nlet greeting = [\"Greetings from\", \" \", \"Vietnam\"];\ngreeting.flatMap(x => x.split(\" \"))\n// [\"Greetings\", \"from\", \"\", \"\", \"Vietnam\"]\n````\n这有点类似于 `map()` 方法，只不过多了一次展平操作。\n\n#### Object.fromEntries()\nObject.fromEntries() 将一组键值对转换成对象。\n\n````javascript\nconst keyValueArray = [\n  ['key1', 'value1'],\n  ['key2', 'value2']\n]\n\nconst obj = Object.fromEntries(keyValueArray)\n// {key1: \"value1\", key2: \"value2\"}\n````\n我们可以将任何可迭代的值作为 `Object.entries()` 方法的参数，不论它是一个 `Array` 还是 `Map`，或是其他实现了迭代协议的值。\n\n注：可迭代协议( Iteration Protocols )是 ES2015 提出的，通常通过常量 `Symbol.iterator` 访问该对象的可迭代属性。\n````javascript\nvar someString = \"hi\";\ntypeof someString[Symbol.iterator]; // \"function\"\nvar iterator = someString[Symbol.iterator]();\n\niterator + \"\";  // \"[object String Iterator]\"\niterator.next()    // { value: \"h\", done: false }\niterator.next();   // { value: \"i\", done: false }\niterator.next();   // { value: undefined, done: true }\n````\n[阅读更多关于迭代协议的内容](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)\n\n#### String.prototype.trimStart() / .trimEnd()\n`String.prototype.trimStart()` 移除字符串前面的空白符，`String.prototype.trimEnd()` 移除字符串后面的空白符。\n````javascript\nlet str = \"    this string has a lot of whitespace   \";\n\nstr.length;\n// 42\n\nstr = str.trimStart();\n// \"this string has a lot of whitespace   \"\nstr.length;\n// 38\n\nstr = str.trimEnd();\n// \"this string has a lot of whitespace\"\nstr.length;\n// 35\n````\n也可以使用 `.trimStart()` 和 `trimEnd()` 的别名： `.trimLeft()` 和 `.trimRight()` 。\n\n#### 可选的 catch 捕获参数\n在 ES2019 之前，你必须为 catch 捕获传递一个表示异常的变量，现在这个变量不是必要的了。\n````javascript\n// Before\ntry {\n   ...\n} catch(error) {\n   ...\n}\n\n// ES2019\ntry {\n   ...\n} catch {\n   ...\n}\n````\n这在你想忽略错误参数的时候很有用。\n\n#### Function.ptototype.toString()\n`.toString()` 方法返回一个代表函数源码的字符串。\n````javascript\nfunction sum(a, b) {\n  return a + b;\n}\n\nconsole.log(sum.toString());\n// function sum(a, b) {\n//    return a + b;\n//  }\n````\n\n注释也会被包含其中：\n````javascript\nfunction sum(a, b) {\n  // perform a sum\n  return a + b;\n}\n\nconsole.log(sum.toString());\n// function sum(a, b) {\n//   // perform a sum\n//   return a + b;\n// }\n````\n\n#### Symbol.prototype.description\n`.description` 返回 `Symbol` 对象可选描述的字符串。\n````javascript\nconst me = Symbol(\"Alberto\");\nme.description;\n// \"Alberto\"\n\nme.toString()\n//  \"Symbol(Alberto)\"\n````\n\n### ES2020 特性\n#### BigInt 类型\nBigInt 是 JavaScript 第七个原始类型，它允许开发者操作非常大的整型。\n数字类型可以处理 `2 ** 53 - 1` 即 `9007199254740991` 以内的数。可以通过常量 `MAX_SAFE_INTEGER` 来访问这个值。\n````javascript\nNumber.MAX_SAFE_INTEGER; // 9007199254740991\n````\n顾名思义，若操作的 number 值超过最大值时,运行结果就会变的奇怪。使用 `BigInt` 类型则没有明确的界限，因为它的界限取决于运行设备的内存。\n定义 `BigInt` 类型，你即可以通过给 `BigInt()` 构造函数传递一个字符串值来创建，也可以像平常一样使用字面量语法来创建，但是要在尾部加上一个字符 `n`。\n````javascript\nconst myBigInt = BigInt(\"999999999999999999999999999999\");\nconst mySecondBigInt = 999999999999999999999999999999n;\n\ntypeof myBigInt; // \"bigint\"\n````\n注意，`BigInt` 类型与常规类型的数字并不是完全兼容的，这意味这你确定最好仅在操作比较大的数据时使用它。\n\n````javascript\nconst bigInt = 1n; // small number, but still of BigInt type\nconst num = 1;\n\nnum === bigInt; // false -> they aren't strictly equal\nnum == bigInt; // true\nnum >= bigInt; // true -> they can be compared\nnum + bigInt; // error -> they can't operate with one another\n````\n总之，使用 JS 做比较复杂的数学运算时 `BigInt` 是个不错的选择。它在替换专门用于处理大量数字的库方面表现良好。现在至少在整型方向有所进展，而目前我们对 `BigDecimal` 的提案了解的还很少。\n\n#### 动态导入（Dynamic imports）\n动态导入，允许在浏览器端动态地加载代码模块。使用 `import()` 语法来导入你的代码块。\n````javascript\nimport(\"module.js\").then((module) => {\n  // ...\n});\n\n// or\nasync () => {\n  const module = await import(\"module.js\");\n};\n````\n`import()` 返回一个 promise，resolve 中会返回代码模块加载后的内容。可以使用 ES6 的 `.then()` 方法或者 `async/await` 来处理加载结果。\n\n#### 空值合并操作符（??）\n空值合并操作符（??）是一个新的 JS 运算符，当所访问的值是 null 或者 undefined 时，它会提供一个默认值。\n````javascript\nconst basicValue = \"test\";\nconst nullishValue = null;\n\nconst firstExample = basicValue ?? \"example\"; // \"test\"\nconst secondExample = nullishValue ?? \"example\"; // \"example\"\n````\n但是这跟 逻辑或（||）有什么区别呢？当第一个数是虚值 (在 Boolean 上下文中认定为 false 的值)，如 `false`, `0`, 或者`\"\"`，以及空值 `null` 和 `undefined`，那么 逻辑或 将会使用第二个操作数。而空值合并操作符仅仅是在第一个值为空值而不是虚值的时候才会使用第二个操作数。如果你的代码可以接受除了 `null` 和 `undefined` 以外的任何值，那么空值合并操作符就是最佳选择。\n\n````javascript\nconst falseValue = false;\nconst zeroValue = 0;\nconst emptyValue = \"\";\nconst nullishValue = null;\n\nconst firstExampleOR = falseValue || \"example\"; // \"example\"\nconst secondExampleOR = zeroValue || \"example\"; // \"example\"\nconst thirdExampleOR = emptyValue || \"example\"; // \"example\"\nconst forthExampleOR = nullish || \"example\"; // \"example\"\n\nconst firstExample = falseValue ?? \"example\"; // false\nconst secondExample = zeroValue ?? \"example\"; // 0\nconst thirdExample = emptyValue ?? \"example\"; // \"\"\nconst forthExample = nullish ?? \"example\"; // \"example\"\n````\n#### 可选链（?.）\n与空值合并操作符类似，只不过可选链是处理 Object 中 `null` 和 `undefined` 的。鉴于直接从空值中国获取属性值会报错，现在可选链会直接将空值返回。\n````javascript\nconst obj = {\n  prop: {\n    subProp: {\n      value: 1,\n    },\n  },\n};\n\nobj.prop.subProp.value; // 1\nobj.prop.secondSubProp.value; // error\n\nobj?.prop?.subProp?.value; // 1\nobj?.prop?.secondSubProp?.value; // undefined\n````\n当然，这只是一个语法糖，但也是一个很受欢迎的补充。记住不要在代码里到处使用这些操作符，他们虽然用起来方便，但从性能角度来说，它比普通的 `.` 开销要大。而且，若是代码是经过 Babel 和 TypeScript 转义的，则更要谨慎使用。\n\n#### GlobalThis\n由于 JavaScript 的代码可以运行在多个不同的环境，例如 浏览器、Node.js、Web Worker 等，要实现这种交叉兼容性绝非易事，globalThis 的出现方便了这些操作。\n`globalThis` 是一个新的全局属性，通常它引用的是当前环境下的全局对象。就像是 `self` 对于 Web Workers，`window` 对于浏览器，`global` 对于 Node.js，以及其他实现了ES2020标准的运行环境。\n\n````javascript\n// Hacky globalThis polyfill you had to use pre-ES2020\nconst getGlobal = () => {\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"Couldn't detect global\");\n};\n\ngetGlobal() === globalThis; // true (for browser, Web Worker and Node.js)\nglobalThis === window; // true (if you're in browser)\n````\n\n#### Promise.allSettled()\n这个新增的方法看起来有点像 `Promise.all()`。\n`Promise.all()` 的参数中的 promise 若有一个失败，则此实例回调失败。而 `Promise.allSettled()`不论成功或者失败，都会返回处理结束后的对象数组。\n\n#### String.matchAll()\n如果你之前使用正则，那么相比于在 `while` 循环中使用 `RegExp.exec()` 并开启标志 `g` 来匹配，`String.matchAll()` 会是更好的选择。它会返回一个包含了所有匹配结果的数组，包括捕获组的匹配结果。\n\n````javascript\nconst regexp = /t(e)(st(\\d?))/g;\nconst str = \"test1test2\";\nconst resultsArr = [...str.matchAll(regexp)]; // convert iterator to an array\n\nresultsArr[0]; // [\"test1\", \"e\", \"st1\", \"1\"]\nresultsArr[1]; // [\"test2\", \"e\", \"st2\", \"2\"]\n````\n\n### 原文链接\n* [everything-from-es-2016-to-es-2019](https://inspiredwebdev.com/everything-from-es-2016-to-es-2019)\n* [ecmascript-2020-biggest-new-features](https://areknawo.com/ecmascript-2020-biggest-new-features/)","slug":"【译】从-ES2016-到-ES2020-的所有特性","published":1,"updated":"2020-11-04T08:29:30.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0y000z7vvu2hjw3g0g","content":"<p>自 ECMA2015 (6th) 大幅更新之后, ECMA 标准变更成每年6月发布一个版本进行小幅度更新。为方便温习和查找，汇总一下近五年的所有版本特性。本文共涵盖了 ES2016、ES2017、ES2018、ES2019、ES2020 五个版本的更新内容。翻译有删改，仅供快速查找使用。<br><a id=\"more\"></a></p>\n<h3 id=\"前言：关于ECMA\"><a href=\"#前言：关于ECMA\" class=\"headerlink\" title=\"前言：关于ECMA\"></a>前言：关于ECMA</h3><p>ECMA 相关stage-x 处于某个阶段，描述的是 ECMA 标准相关的内容。根据提案划分界限，stage-x 大致分为以下阶段:</p>\n<ul>\n<li>stage-0：还是一个设想，只能由 TC39 成员或 TC39 贡献者提出。</li>\n<li>stage-1：提案阶段，比较正式的提议，只能由 TC39 成员发起，这个提案要解决的问题必须有正式的书面描述。</li>\n<li>stage-2：草案，有了初始规范，必须对功能语法和语义进行正式描述，包括一些实验性的实现。</li>\n<li>stage-3：候选，该提议基本已经实现，需要等待实验验证，用户反馈及验收测试通过。</li>\n<li>stage-4：已完成，必须通过 Test262 验收测试，下一步就纳入 ECMA 标准。</li>\n</ul>\n<p>总结起来就是数字越大，越成熟。</p>\n<h3 id=\"ES2016-新特性\"><a href=\"#ES2016-新特性\" class=\"headerlink\" title=\"ES2016 新特性\"></a>ES2016 新特性</h3><p>ES2016 只更新了两个特性：</p>\n<ul>\n<li>Array.prototype.includes()</li>\n<li>指数运算符</li>\n</ul>\n<h4 id=\"Array-prototype-includes\"><a href=\"#Array-prototype-includes\" class=\"headerlink\" title=\"Array.prototype.includes()\"></a>Array.prototype.includes()</h4><p>该方法用于检测数组中是否包含某个值，包含则返回 true，否则返回 false。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">array.includes(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\">array.includes(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>结合 fromIndex 使用：</p>\n</blockquote>\n<p>可以为 <code>.includes()</code> 提供一个起始索引，默认是 0，接受负数值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array = [ <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span> ];</span><br><span class=\"line\"></span><br><span class=\"line\">array.includes(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// find the number 3 starting from array index 1</span></span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\">array.includes(<span class=\"number\">5</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">//false</span></span><br><span class=\"line\">array.includes(<span class=\"number\">1</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"comment\">// find the number 1 starting from the ending of the array going backwards</span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br><span class=\"line\">array.includes(<span class=\"number\">11</span>, <span class=\"number\">-3</span>);</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"指数操作符\"><a href=\"#指数操作符\" class=\"headerlink\" title=\"指数操作符 (**)\"></a>指数操作符 (**)</h4><p>在 ES2016 前我们会这样写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure></p>\n<p>现在，有了指数运算符之后，可以这样写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure></p>\n<p>这在多次操作指数运算的时候很有用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">2</span> ** <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">// 16</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">2</span>), <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 16</span></span><br></pre></td></tr></table></figure></p>\n<p><code>Math.pow()</code> 需要连续调用，这会使代码看起来很长不宜阅读。使用指数运算符的方式更快更简洁。</p>\n<h3 id=\"ES2017-新特性\"><a href=\"#ES2017-新特性\" class=\"headerlink\" title=\"ES2017 新特性\"></a>ES2017 新特性</h3><p>ES2017 介绍了更多新特性，如 String padding，Object.entries(), Object.values(), 原子性操作， 以及 Async、Await 等。</p>\n<h4 id=\"字符串填充-String-padStart-和-String-padEnd\"><a href=\"#字符串填充-String-padStart-和-String-padEnd\" class=\"headerlink\" title=\"字符串填充 ( String.padStart() 和 String.padEnd() )\"></a>字符串填充 ( String.padStart() 和 String.padEnd() )</h4><p><code>.padStart()</code> 对字符串头部进行填充， <code>.padEnd()</code> 对字符串尾部进行填充：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"hello\"</span>.padStart(<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"comment\">// \" hello\"</span></span><br><span class=\"line\"><span class=\"string\">\"hello\"</span>.padEnd(<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"comment\">// \"hello \"</span></span><br></pre></td></tr></table></figure></p>\n<p>为什么只填充1个空格而不是6个？是因为 “hello” 一共是五个字符，而 <code>.padStart</code> 和 <code>.padEnd</code> 的入参是填充后的字符串长度，所以之只会填充一个空格。 </p>\n<blockquote>\n<p>使用 padStart 实现文本右对齐<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> strings = [<span class=\"string\">\"short\"</span>, <span class=\"string\">\"medium length\"</span>, <span class=\"string\">\"very long string\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> longestString = strings.sort(<span class=\"function\">(<span class=\"params\">s1, s2</span>) =&gt;</span> s2.length - s1.length).map(<span class=\"function\"><span class=\"params\">str</span> =&gt;</span> str.length)[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">strings.forEach(<span class=\"function\"><span class=\"params\">str</span> =&gt;</span> <span class=\"built_in\">console</span>.log(str.padStart(longestString)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// very long string</span></span><br><span class=\"line\"><span class=\"comment\">//    medium length</span></span><br><span class=\"line\"><span class=\"comment\">//            short</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>第一步获取了数组中最长字符串的长度，接下来用该长度填充数组中的每个字符串，即打印出一组右对齐的字符串。</p>\n<blockquote>\n<p>自定义填充值</p>\n</blockquote>\n<p>除了默认的空格，还可以使用字符串和数字进行填充。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"hello\"</span>.padEnd(<span class=\"number\">13</span>,<span class=\"string\">\" Alberto\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// \"hello Alberto\"</span></span><br><span class=\"line\"><span class=\"string\">\"1\"</span>.padStart(<span class=\"number\">3</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// \"001\"</span></span><br><span class=\"line\"><span class=\"string\">\"99\"</span>.padStart(<span class=\"number\">3</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// \"099\"</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Object-entries-和-Object-values\"><a href=\"#Object-entries-和-Object-values\" class=\"headerlink\" title=\"Object.entries() 和 Object.values()\"></a>Object.entries() 和 Object.values()</h4><p>首先创建一个Object：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> family = &#123;</span><br><span class=\"line\">  father: <span class=\"string\">\"Jonathan Kent\"</span>,</span><br><span class=\"line\">  mother: <span class=\"string\">\"Martha Kent\"</span>,</span><br><span class=\"line\">  son: <span class=\"string\">\"Clark Kent\"</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上个版本的 javascript 中，我们可以使用如下方式获取 Object 中的值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.keys(family);</span><br><span class=\"line\"><span class=\"comment\">// [\"father\", \"mother\", \"son\"]</span></span><br><span class=\"line\">family.father;</span><br><span class=\"line\"><span class=\"string\">\"Jonathan Kent\"</span></span><br></pre></td></tr></table></figure></p>\n<p><code>Object.keys()</code> 仅会返回对象中所有的键名。</p>\n<p>现在又多了两种可以访问对象的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.values(family);</span><br><span class=\"line\"><span class=\"comment\">// [\"Jonathan Kent\", \"Martha Kent\", \"Clark Kent\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.entries(family);</span><br><span class=\"line\"><span class=\"comment\">// [\"father\", \"Jonathan Kent\"]</span></span><br><span class=\"line\"><span class=\"comment\">// [\"mother\", \"Martha Kent\"]</span></span><br><span class=\"line\"><span class=\"comment\">// [\"son\", \"Clark Kent\"]</span></span><br></pre></td></tr></table></figure>\n<p><code>Object.values()</code> 以数组形式返回对象所有值。<br><code>Object.entries()</code> 同样以数组形式返回对象中的键值对。</p>\n<h4 id=\"Object-getOwnPropertyDescriptors\"><a href=\"#Object-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"Object.getOwnPropertyDescriptors()\"></a>Object.getOwnPropertyDescriptors()</h4><p>这个方法会返回对象所有自身属性的描述。描述性的字段有：<code>value</code>，<code>writable</code>, <code>get</code>, <code>set</code>, <code>configurable</code> 和 <code>enumerable</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myObj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"Alberto\"</span>,</span><br><span class=\"line\">  age: <span class=\"number\">25</span>,</span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptors(myObj);</span><br><span class=\"line\"><span class=\"comment\">// age: &#123;value: 25, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// greet: &#123;value: ƒ, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// name: &#123;value: \"Alberto\", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"尾行逗号\"><a href=\"#尾行逗号\" class=\"headerlink\" title=\"尾行逗号\"></a>尾行逗号</h4><p>这仅仅是语法上的一个小改变。现在在写 Object 属性值时，我们可以在每个值后边加上一个逗号，不论它是否是最后一个。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// from this</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> object = &#123;</span><br><span class=\"line\">  prop1: <span class=\"string\">\"prop\"</span>,</span><br><span class=\"line\">  prop2: <span class=\"string\">\"propop\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// to this</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> object = &#123;</span><br><span class=\"line\">  prop1: <span class=\"string\">\"prop\"</span>,</span><br><span class=\"line\">  prop2: <span class=\"string\">\"propop\"</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意上述第二个例子中的最后一个逗号，即使你不写它也不会报错，只是写上会更方便的开发者们协作。</p>\n<h4 id=\"共享内存和原子性操作\"><a href=\"#共享内存和原子性操作\" class=\"headerlink\" title=\"共享内存和原子性操作\"></a>共享内存和原子性操作</h4><p>下述引自 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics\" target=\"_blank\" rel=\"noopener\">MDN</a>:</p>\n<blockquote>\n<p>多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。</p>\n</blockquote>\n<p>这些原子操作属于 Atomics 模块。与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math  对象一样）。</p>\n<p>方法示例：</p>\n<ul>\n<li>add / sub</li>\n<li>and / or / xor</li>\n<li>load / store</li>\n</ul>\n<p><code>Atomics</code> 通常和 <code>SharedArrayBuffer</code> 对象（通用的固定长度二进制数据缓冲区）一起使用。<br>来看一下几个 <code>Atomics</code>方法的使用示例：</p>\n<h5 id=\"Atomics-add-Atomics-sub-Atomics-load-and-Atomics-store\"><a href=\"#Atomics-add-Atomics-sub-Atomics-load-and-Atomics-store\" class=\"headerlink\" title=\"Atomics.add(), Atomics.sub(), Atomics.load(), and Atomics.store()\"></a>Atomics.add(), Atomics.sub(), Atomics.load(), and Atomics.store()</h5><p><code>Atomics.add()</code> 共接受三个参数：array、index、value。并返回该索引在执行操作前的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create a `SharedArrayBuffer`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buffer = <span class=\"keyword\">new</span> SharedArrayBuffer(<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> uint8 = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// add a value at the first position</span></span><br><span class=\"line\">uint8[<span class=\"number\">0</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Atomics.add(uint8, <span class=\"number\">0</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 10 + 5 = 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(uint8[<span class=\"number\">0</span>])</span><br><span class=\"line\"><span class=\"comment\">// 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Atomics.load(uint8, <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n<p>要从数组中检索特定的值，可以使用 <code>Atomics.load()</code> 并传递两个参数，一个数组和一个索引。<br><code>Atomics.sub()</code> 的使用方式与 <code>Atomics.add()</code> 类似，只不过它是减去某个值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create a `SharedArrayBuffer`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buffer = <span class=\"keyword\">new</span> SharedArrayBuffer(<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> uint8 = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// add a value at the first position</span></span><br><span class=\"line\">uint8[<span class=\"number\">0</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Atomics.sub(uint8, <span class=\"number\">0</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 10 - 5 = 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(uint8[<span class=\"number\">0</span>])</span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Atomics.store(uint8, <span class=\"number\">0</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Atomics.load(uint8, <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>上述示例调用 <code>Atomics.sub()</code> 方法，实现 unit8[0] - 5 ，相当于 10 - 5。如同 <code>Atomics.add()</code> 一样，该方法也会返回数组中该索引在执行操作前的值。</p>\n<p>使用 <code>Atomics.store()</code> 来存储一个值，使用 <code>Atomics.load()</code> 来加载一个值。</p>\n<h5 id=\"Atomics-and-Atomics-or-Atomics-xor\"><a href=\"#Atomics-and-Atomics-or-Atomics-xor\" class=\"headerlink\" title=\"Atomics.and(), Atomics.or(), Atomics.xor()\"></a>Atomics.and(), Atomics.or(), Atomics.xor()</h5><p>这三个方法都在数组的给定位置执行按位的 AND、OR 和 XOR 操作。不再赘述。</p>\n<h4 id=\"Async-和-Await\"><a href=\"#Async-和-Await\" class=\"headerlink\" title=\"Async 和 Await\"></a>Async 和 Await</h4><p>ES2017 提供了两个操作 Promise 的新方法：”async/await”。</p>\n<h5 id=\"回顾一下-Promise\"><a href=\"#回顾一下-Promise\" class=\"headerlink\" title=\"回顾一下 Promise\"></a>回顾一下 Promise</h5><p>在介绍新语法之前，让我们快速浏览下之前我们是怎么使用 Promise 的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fetch a user from github</span></span><br><span class=\"line\">fetch(<span class=\"string\">'api.github.com/user/AlbertoMontalesi'</span>).then( <span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// return the data in json format</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.json();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// if everything went well, print the data</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">&#125;).catch( <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// or print the error</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>上述是一个非常简单的例子：请求一个 Github 用户的数据，并打印。下面来看个复杂点的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">walk</span>(<span class=\"params\">amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (amount &lt; <span class=\"number\">500</span>) &#123;</span><br><span class=\"line\">      reject (<span class=\"string\">\"the value is too small\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(<span class=\"string\">`you walked for <span class=\"subst\">$&#123;amount&#125;</span>ms`</span>),amount);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">walk(<span class=\"number\">1000</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> walk(<span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> walk(<span class=\"number\">700</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> walk(<span class=\"number\">800</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> walk(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> walk(<span class=\"number\">400</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> walk(<span class=\"number\">600</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// you walked for 1000ms</span></span><br><span class=\"line\"><span class=\"comment\">// you walked for 500ms</span></span><br><span class=\"line\"><span class=\"comment\">// you walked for 700ms</span></span><br><span class=\"line\"><span class=\"comment\">// you walked for 800ms</span></span><br><span class=\"line\"><span class=\"comment\">// uncaught exception: the value is too small</span></span><br></pre></td></tr></table></figure>\n<p>来看下，如何用新语法 async / await 来重写 <code>Promise</code>。</p>\n<h5 id=\"Async-和-Await-1\"><a href=\"#Async-和-Await-1\" class=\"headerlink\" title=\"Async 和 Await\"></a>Async 和 Await</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">walk</span>(<span class=\"params\">amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (amount &lt; <span class=\"number\">500</span>) &#123;</span><br><span class=\"line\">      reject (<span class=\"string\">\"the value is too small\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(<span class=\"string\">`you walked for <span class=\"subst\">$&#123;amount&#125;</span>ms`</span>),amount);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// create an async function</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// use the keyword `await` to wait for the response</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> walk(<span class=\"number\">500</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res2 = <span class=\"keyword\">await</span> walk(<span class=\"number\">900</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res2);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res3 = <span class=\"keyword\">await</span> walk(<span class=\"number\">600</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res3);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res4 = <span class=\"keyword\">await</span> walk(<span class=\"number\">700</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res4);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res5 = <span class=\"keyword\">await</span> walk(<span class=\"number\">400</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res5);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"finished\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">go();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// you walked for 500ms </span></span><br><span class=\"line\"><span class=\"comment\">// you walked for 900ms </span></span><br><span class=\"line\"><span class=\"comment\">// you walked for 600ms </span></span><br><span class=\"line\"><span class=\"comment\">// you walked for 700ms </span></span><br><span class=\"line\"><span class=\"comment\">// uncaught exception: the value is too small</span></span><br></pre></td></tr></table></figure>\n<p>让我们来分解一下上述代码都做了什么：</p>\n<ul>\n<li>创建一个异步函数需要在 function 前面添加 async 关键词</li>\n<li>这个关键词会告诉 Javascript 返回一个 Promise</li>\n<li>如果指定 async 函数返回一个非 Promise 的值，那么这个值将会被包含在 Promise 中然后被返回</li>\n<li>顾名思义， await 会告诉 Javascript 等待 promise 返回结果</li>\n</ul>\n<h5 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h5><p>通常在 promise 中，我们使用 <code>.catch()</code> 捕获最终的错误。现在有一点不同了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncFunc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> response = <span class=\"keyword\">await</span> fetch(<span class=\"string\">'http:your-url'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncFunc();</span><br><span class=\"line\"><span class=\"comment\">// TypeError: failed to fetch</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ES2018-新特性\"><a href=\"#ES2018-新特性\" class=\"headerlink\" title=\"ES2018 新特性\"></a>ES2018 新特性</h3><h4 id=\"对象扩展运算符\"><a href=\"#对象扩展运算符\" class=\"headerlink\" title=\"对象扩展运算符\"></a>对象扩展运算符</h4><p>还记得 ES6 中我们可以使用扩展运算符来做什么吗：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> veggie = [<span class=\"string\">\"tomato\"</span>, <span class=\"string\">\"cucumber\"</span>, <span class=\"string\">\"beans\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> meat = [<span class=\"string\">\"pork\"</span>, <span class=\"string\">\"beef\"</span>, <span class=\"string\">\"chicken\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> menu = [...veggie, <span class=\"string\">\"pasta\"</span>, ...meat];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(menu);</span><br><span class=\"line\"><span class=\"comment\">// Array [ \"tomato\", \"cucumber\", \"beans\", \"pasta\", \"pork\", \"beef\", \"chicken\" ]</span></span><br></pre></td></tr></table></figure></p>\n<p>现在，扩展运算符同样适用于对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: <span class=\"number\">3</span>,</span><br><span class=\"line\">  c: <span class=\"number\">5</span>,</span><br><span class=\"line\">  d: <span class=\"number\">8</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// we use the rest operator to grab everything else left in the object.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b, ...z &#125; = myObj;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);     <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);     <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(z);     <span class=\"comment\">// &#123;c: 5, d: 8&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// using the spread syntax we cloned our Object</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> clone = &#123; ...myObj &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(clone);</span><br><span class=\"line\"><span class=\"comment\">// &#123;a: 1, b: 3, c: 5, d: 8&#125;</span></span><br><span class=\"line\">myObj.e = <span class=\"number\">15</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(clone)</span><br><span class=\"line\"><span class=\"comment\">// &#123;a: 1, b: 3, c: 5, d: 8&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myObj)</span><br><span class=\"line\"><span class=\"comment\">// &#123;a: 1, b: 3, c: 5, d: 8, e: 15&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>使用扩展运算符，我们可以轻松的复制对象（浅复制）。</p>\n<h4 id=\"异步的迭代\"><a href=\"#异步的迭代\" class=\"headerlink\" title=\"异步的迭代\"></a>异步的迭代</h4><p>使用异步的迭代，我们可以异步的遍历数据。<br><a href=\"https://github.com/tc39/proposal-async-iteration\" target=\"_blank\" rel=\"noopener\">引自文档</a></p>\n<blockquote>\n<p>异步迭代器很像迭代器，只不过迭代器的 next 方法返回一对 { value, done }</p>\n</blockquote>\n<p>为此，我们将使用一个 <code>for-await-of</code> 循环，它将迭代转换成 Promise。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> iterables = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> value <span class=\"keyword\">of</span> iterables) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>在执行过程中，<code>[Symbol.asyncIterator]()</code> 方法将会创造一个异步的迭代器，每次访问序列中的下一个值时，我们都会隐式地等待迭代器方法返回 Promise。</p>\n<h4 id=\"Promise-prototype-finally\"><a href=\"#Promise-prototype-finally\" class=\"headerlink\" title=\"Promise.prototype.finally()\"></a>Promise.prototype.finally()</h4><p>引自 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally\" target=\"_blank\" rel=\"noopener\">MDN</a>:</p>\n<blockquote>\n<p>finally() 方法返回一个 Promise。在 Promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。这为在 Promise 是否成功完成后都需要执行的代码提供了一种方式。避免了同样的语句需要在 then() 和 catch() 中各写一次的情况。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;)；</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'still working'</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'there was an error'</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .finally(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Done!'</span>);</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p><code>.finally()</code> 同样会返回一个 promise，所以我们可以继续链式调用 <code>then</code> 和 <code>catch</code> 方法，但是它们是基于之前的 promise 进行调用的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;)；</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'still working'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'still working'</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .finally(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Done!'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Done!'</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"><span class=\"comment\">// still working</span></span><br><span class=\"line\"><span class=\"comment\">// Done!</span></span><br><span class=\"line\"><span class=\"comment\">// still working</span></span><br></pre></td></tr></table></figure></p>\n<p>从上边代码可以看到 <code>finally</code> 后边的 <code>then</code> 返回的值是由第一个 <code>then</code> 创建的，而不是 <code>finally</code>。</p>\n<h4 id=\"正则表达式的新特性\"><a href=\"#正则表达式的新特性\" class=\"headerlink\" title=\"正则表达式的新特性\"></a>正则表达式的新特性</h4><p>在新版的 ECMA 中，共更新了 4 个关于正则的特性。</p>\n<ul>\n<li>正则表达式的 s (doAll) 标志</li>\n<li>正则表达式捕获组命名</li>\n<li>正则表达式反向断言 (Lookbehind Assertions)</li>\n<li>unicode 字符转义 (Unicode property escapes) </li>\n</ul>\n<h5 id=\"s-doAll-标志\"><a href=\"#s-doAll-标志\" class=\"headerlink\" title=\"s (doAll) 标志\"></a>s (doAll) 标志</h5><blockquote>\n<p>引自<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n</blockquote>\n<p><code>dotAll</code> 属性表明是否在正则表达式中一起使用 “<code>s</code>“ 修饰符（引入 /s 修饰符，使得<code>.</code>可以匹配任意单个字符，包括换行符和回车符）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/foo.bar/s.test(<span class=\"string\">'foo\\nbar'</span>);</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"捕获组命名\"><a href=\"#捕获组命名\" class=\"headerlink\" title=\"捕获组命名\"></a>捕获组命名</h5><blockquote>\n<p>想要引用正则匹配到的某一部分字符串可以为捕获组编号。每个捕获组的数字都是唯一的，可以对应的数字引用它们，但是这使正则表达式难以阅读和维护。例如 <code>/(\\d{4})-(\\d{2})-(\\d{2})/</code> 匹配一个日期，但如果不看上下文的代码，就无法确定哪一组对应于月份，哪一组是一天。当然，如果哪一天需要交换日期和月份的顺序，那么对应的组引用也需要更新。现在，可以使用 <code>(?&lt;name&gt;...)</code> 来为捕获组命名，以表示任何标识符名称。重写上述例子：<code>/(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})/u</code> 每一个命名都是唯一且遵循 ECMA 命名规范的。命名的组可以通过匹配结果的 <code>result</code> 属性来访问。对组的数字引用也会被建立，就像未命名的组一样。看下边几个例子：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> re = <span class=\"regexp\">/(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = re.exec(<span class=\"string\">'2015-01-02'</span>);</span><br><span class=\"line\"><span class=\"comment\">// result.groups.year === '2015';</span></span><br><span class=\"line\"><span class=\"comment\">// result.groups.month === '01';</span></span><br><span class=\"line\"><span class=\"comment\">// result.groups.day === '02';</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// result[0] === '2015-01-02';</span></span><br><span class=\"line\"><span class=\"comment\">// result[1] === '2015';</span></span><br><span class=\"line\"><span class=\"comment\">// result[2] === '01';</span></span><br><span class=\"line\"><span class=\"comment\">// result[3] === '02';</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">groups</span>: &#123; one, two &#125; &#125; = <span class=\"regexp\">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class=\"string\">'foo:bar'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`one: <span class=\"subst\">$&#123;one&#125;</span>, two: <span class=\"subst\">$&#123;two&#125;</span>`</span>); </span><br><span class=\"line\"><span class=\"comment\">// one: foo, two: bar</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"反向断言\"><a href=\"#反向断言\" class=\"headerlink\" title=\"反向断言\"></a>反向断言</h5><blockquote>\n<p>使用反向断言可以确保匹配之前或者之后没有其他匹配。反向断言的语法表示为 <code>(?&lt;=...)</code> 。<br>例如：匹配一个美元数值且不包含美元符号可以这样写 <code>/(?&lt;=$)\\d+(\\.\\d*)?/</code>，这个表达式会匹配 <code>$10.53</code> 并返回 <code>10.53</code>，而并不会匹配 <code>€10.53</code>。而 <code>(?&lt;!...)</code> 匹配的规则正相反，它会匹配不存在表达式中的匹配项，例如 <code>/(?&lt;!$)\\d+(?:\\.\\d*)/</code> 不会匹配 <code>$10.53</code>，但是会匹配 <code>€10.53</code>。</p>\n</blockquote>\n<h5 id=\"Unicode-字符转义\"><a href=\"#Unicode-字符转义\" class=\"headerlink\" title=\"Unicode 字符转义\"></a>Unicode 字符转义</h5><blockquote>\n<p>Unicode 字符转义是一种新的转义序列，<code>u</code> 作为字符转义的标志， <code>\\p{...}</code> 和 <code>\\P{...}</code> 用来添加转义符。有了这个特性，匹配 Unicode 字符可以这样写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> regexGreekSymbol = <span class=\"regexp\">/\\p&#123;Script=Greek&#125;/u</span>;</span><br><span class=\"line\">regexGreekSymbol.test(<span class=\"string\">'π'</span>);</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"解除模板字符限制\"><a href=\"#解除模板字符限制\" class=\"headerlink\" title=\"解除模板字符限制\"></a>解除模板字符限制</h4><p>当使用 Tagged 模板字符串时，转义字符的限制被移除了（<a href=\"https://tc39.github.io/proposal-template-literal-revision/#sec-template-literals\" target=\"_blank\" rel=\"noopener\">阅读更多</a>）</p>\n<h3 id=\"ES2019-新特性\"><a href=\"#ES2019-新特性\" class=\"headerlink\" title=\"ES2019 新特性\"></a>ES2019 新特性</h3><h4 id=\"Array-prototype-flat-Array-prototype-flatMap\"><a href=\"#Array-prototype-flat-Array-prototype-flatMap\" class=\"headerlink\" title=\"Array.prototype.flat() / Array.prototype.flatMap()\"></a>Array.prototype.flat() / Array.prototype.flatMap()</h4><p><code>Array.prototype.flat()</code> 会递归地展平一个数组并作为新值返回，它接受一个表示递归深度的值，未传值则默认深度为1。可以用 <code>Infinity</code> 去展平所有嵌套的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> letters = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, [<span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, [<span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>]]];</span><br><span class=\"line\"><span class=\"comment\">// default depth of 1</span></span><br><span class=\"line\">letters.flat();</span><br><span class=\"line\"><span class=\"comment\">// ['a', 'b', 'c', 'd', ['e', 'f']]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// depth of 2</span></span><br><span class=\"line\">letters.flat(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// which is the same as executing flat with depth of 1 twice</span></span><br><span class=\"line\">letters.flat().flat();</span><br><span class=\"line\"><span class=\"comment\">// ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Flattens recursively until the array contains no nested arrays</span></span><br><span class=\"line\">letters.flat(<span class=\"literal\">Infinity</span>)</span><br><span class=\"line\"><span class=\"comment\">// ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br></pre></td></tr></table></figure>\n<p><code>Array.prototype.flatMap()</code> 与深度值为1的 flat 几乎相同，但它并非仅仅展平数组。 flatMap 接收一个处理函数，使用 <code>flatMap()</code> 可以在展平的同时更改对应的值并返回一个新的数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> greeting = [<span class=\"string\">\"Greetings from\"</span>, <span class=\"string\">\" \"</span>, <span class=\"string\">\"Vietnam\"</span>];</span><br><span class=\"line\">greeting.flatMap(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x.split(<span class=\"string\">\" \"</span>))</span><br><span class=\"line\"><span class=\"comment\">// [\"Greetings\", \"from\", \"\", \"\", \"Vietnam\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>这有点类似于 <code>map()</code> 方法，只不过多了一次展平操作。</p>\n<h4 id=\"Object-fromEntries\"><a href=\"#Object-fromEntries\" class=\"headerlink\" title=\"Object.fromEntries()\"></a>Object.fromEntries()</h4><p>Object.fromEntries() 将一组键值对转换成对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> keyValueArray = [</span><br><span class=\"line\">  [<span class=\"string\">'key1'</span>, <span class=\"string\">'value1'</span>],</span><br><span class=\"line\">  [<span class=\"string\">'key2'</span>, <span class=\"string\">'value2'</span>]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.fromEntries(keyValueArray)</span><br><span class=\"line\"><span class=\"comment\">// &#123;key1: \"value1\", key2: \"value2\"&#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们可以将任何可迭代的值作为 <code>Object.entries()</code> 方法的参数，不论它是一个 <code>Array</code> 还是 <code>Map</code>，或是其他实现了迭代协议的值。</p>\n<p>注：可迭代协议( Iteration Protocols )是 ES2015 提出的，通常通过常量 <code>Symbol.iterator</code> 访问该对象的可迭代属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someString = <span class=\"string\">\"hi\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> someString[<span class=\"built_in\">Symbol</span>.iterator]; <span class=\"comment\">// \"function\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> iterator = someString[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"></span><br><span class=\"line\">iterator + <span class=\"string\">\"\"</span>;  <span class=\"comment\">// \"[object String Iterator]\"</span></span><br><span class=\"line\">iterator.next()    <span class=\"comment\">// &#123; value: \"h\", done: false &#125;</span></span><br><span class=\"line\">iterator.next();   <span class=\"comment\">// &#123; value: \"i\", done: false &#125;</span></span><br><span class=\"line\">iterator.next();   <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols\" target=\"_blank\" rel=\"noopener\">阅读更多关于迭代协议的内容</a></p>\n<h4 id=\"String-prototype-trimStart-trimEnd\"><a href=\"#String-prototype-trimStart-trimEnd\" class=\"headerlink\" title=\"String.prototype.trimStart() / .trimEnd()\"></a>String.prototype.trimStart() / .trimEnd()</h4><p><code>String.prototype.trimStart()</code> 移除字符串前面的空白符，<code>String.prototype.trimEnd()</code> 移除字符串后面的空白符。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"    this string has a lot of whitespace   \"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">str.length;</span><br><span class=\"line\"><span class=\"comment\">// 42</span></span><br><span class=\"line\"></span><br><span class=\"line\">str = str.trimStart();</span><br><span class=\"line\"><span class=\"comment\">// \"this string has a lot of whitespace   \"</span></span><br><span class=\"line\">str.length;</span><br><span class=\"line\"><span class=\"comment\">// 38</span></span><br><span class=\"line\"></span><br><span class=\"line\">str = str.trimEnd();</span><br><span class=\"line\"><span class=\"comment\">// \"this string has a lot of whitespace\"</span></span><br><span class=\"line\">str.length;</span><br><span class=\"line\"><span class=\"comment\">// 35</span></span><br></pre></td></tr></table></figure></p>\n<p>也可以使用 <code>.trimStart()</code> 和 <code>trimEnd()</code> 的别名： <code>.trimLeft()</code> 和 <code>.trimRight()</code> 。</p>\n<h4 id=\"可选的-catch-捕获参数\"><a href=\"#可选的-catch-捕获参数\" class=\"headerlink\" title=\"可选的 catch 捕获参数\"></a>可选的 catch 捕获参数</h4><p>在 ES2019 之前，你必须为 catch 捕获传递一个表示异常的变量，现在这个变量不是必要的了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Before</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(error) &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES2019</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这在你想忽略错误参数的时候很有用。</p>\n<h4 id=\"Function-ptototype-toString\"><a href=\"#Function-ptototype-toString\" class=\"headerlink\" title=\"Function.ptototype.toString()\"></a>Function.ptototype.toString()</h4><p><code>.toString()</code> 方法返回一个代表函数源码的字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum.toString());</span><br><span class=\"line\"><span class=\"comment\">// function sum(a, b) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    return a + b;</span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>注释也会被包含其中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// perform a sum</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum.toString());</span><br><span class=\"line\"><span class=\"comment\">// function sum(a, b) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   // perform a sum</span></span><br><span class=\"line\"><span class=\"comment\">//   return a + b;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Symbol-prototype-description\"><a href=\"#Symbol-prototype-description\" class=\"headerlink\" title=\"Symbol.prototype.description\"></a>Symbol.prototype.description</h4><p><code>.description</code> 返回 <code>Symbol</code> 对象可选描述的字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> me = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"Alberto\"</span>);</span><br><span class=\"line\">me.description;</span><br><span class=\"line\"><span class=\"comment\">// \"Alberto\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">me.toString()</span><br><span class=\"line\"><span class=\"comment\">//  \"Symbol(Alberto)\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ES2020-特性\"><a href=\"#ES2020-特性\" class=\"headerlink\" title=\"ES2020 特性\"></a>ES2020 特性</h3><h4 id=\"BigInt-类型\"><a href=\"#BigInt-类型\" class=\"headerlink\" title=\"BigInt 类型\"></a>BigInt 类型</h4><p>BigInt 是 JavaScript 第七个原始类型，它允许开发者操作非常大的整型。<br>数字类型可以处理 <code>2 ** 53 - 1</code> 即 <code>9007199254740991</code> 以内的数。可以通过常量 <code>MAX_SAFE_INTEGER</code> 来访问这个值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER; <span class=\"comment\">// 9007199254740991</span></span><br></pre></td></tr></table></figure></p>\n<p>顾名思义，若操作的 number 值超过最大值时,运行结果就会变的奇怪。使用 <code>BigInt</code> 类型则没有明确的界限，因为它的界限取决于运行设备的内存。<br>定义 <code>BigInt</code> 类型，你即可以通过给 <code>BigInt()</code> 构造函数传递一个字符串值来创建，也可以像平常一样使用字面量语法来创建，但是要在尾部加上一个字符 <code>n</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myBigInt = BigInt(<span class=\"string\">\"999999999999999999999999999999\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> mySecondBigInt = <span class=\"number\">999999999999999999999999999999</span>n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> myBigInt; <span class=\"comment\">// \"bigint\"</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>BigInt</code> 类型与常规类型的数字并不是完全兼容的，这意味这你确定最好仅在操作比较大的数据时使用它。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bigInt = <span class=\"number\">1</span>n; <span class=\"comment\">// small number, but still of BigInt type</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> num = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">num === bigInt; <span class=\"comment\">// false -&gt; they aren't strictly equal</span></span><br><span class=\"line\">num == bigInt; <span class=\"comment\">// true</span></span><br><span class=\"line\">num &gt;= bigInt; <span class=\"comment\">// true -&gt; they can be compared</span></span><br><span class=\"line\">num + bigInt; <span class=\"comment\">// error -&gt; they can't operate with one another</span></span><br></pre></td></tr></table></figure>\n<p>总之，使用 JS 做比较复杂的数学运算时 <code>BigInt</code> 是个不错的选择。它在替换专门用于处理大量数字的库方面表现良好。现在至少在整型方向有所进展，而目前我们对 <code>BigDecimal</code> 的提案了解的还很少。</p>\n<h4 id=\"动态导入（Dynamic-imports）\"><a href=\"#动态导入（Dynamic-imports）\" class=\"headerlink\" title=\"动态导入（Dynamic imports）\"></a>动态导入（Dynamic imports）</h4><p>动态导入，允许在浏览器端动态地加载代码模块。使用 <code>import()</code> 语法来导入你的代码块。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"string\">\"module.js\"</span>).then(<span class=\"function\">(<span class=\"params\"><span class=\"built_in\">module</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">module</span> = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">\"module.js\"</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>import()</code> 返回一个 promise，resolve 中会返回代码模块加载后的内容。可以使用 ES6 的 <code>.then()</code> 方法或者 <code>async/await</code> 来处理加载结果。</p>\n<h4 id=\"空值合并操作符（-）\"><a href=\"#空值合并操作符（-）\" class=\"headerlink\" title=\"空值合并操作符（??）\"></a>空值合并操作符（??）</h4><p>空值合并操作符（??）是一个新的 JS 运算符，当所访问的值是 null 或者 undefined 时，它会提供一个默认值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> basicValue = <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> nullishValue = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> firstExample = basicValue ?? <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"test\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> secondExample = nullishValue ?? <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"example\"</span></span><br></pre></td></tr></table></figure></p>\n<p>但是这跟 逻辑或（||）有什么区别呢？当第一个数是虚值 (在 Boolean 上下文中认定为 false 的值)，如 <code>false</code>, <code>0</code>, 或者<code>&quot;&quot;</code>，以及空值 <code>null</code> 和 <code>undefined</code>，那么 逻辑或 将会使用第二个操作数。而空值合并操作符仅仅是在第一个值为空值而不是虚值的时候才会使用第二个操作数。如果你的代码可以接受除了 <code>null</code> 和 <code>undefined</code> 以外的任何值，那么空值合并操作符就是最佳选择。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> falseValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> zeroValue = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> emptyValue = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> nullishValue = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> firstExampleOR = falseValue || <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"example\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> secondExampleOR = zeroValue || <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"example\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> thirdExampleOR = emptyValue || <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"example\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> forthExampleOR = nullish || <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"example\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> firstExample = falseValue ?? <span class=\"string\">\"example\"</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> secondExample = zeroValue ?? <span class=\"string\">\"example\"</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> thirdExample = emptyValue ?? <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> forthExample = nullish ?? <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"example\"</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"可选链（-）\"><a href=\"#可选链（-）\" class=\"headerlink\" title=\"可选链（?.）\"></a>可选链（?.）</h4><p>与空值合并操作符类似，只不过可选链是处理 Object 中 <code>null</code> 和 <code>undefined</code> 的。鉴于直接从空值中国获取属性值会报错，现在可选链会直接将空值返回。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  prop: &#123;</span><br><span class=\"line\">    subProp: &#123;</span><br><span class=\"line\">      value: <span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.prop.subProp.value; <span class=\"comment\">// 1</span></span><br><span class=\"line\">obj.prop.secondSubProp.value; <span class=\"comment\">// error</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj?.prop?.subProp?.value; <span class=\"comment\">// 1</span></span><br><span class=\"line\">obj?.prop?.secondSubProp?.value; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>当然，这只是一个语法糖，但也是一个很受欢迎的补充。记住不要在代码里到处使用这些操作符，他们虽然用起来方便，但从性能角度来说，它比普通的 <code>.</code> 开销要大。而且，若是代码是经过 Babel 和 TypeScript 转义的，则更要谨慎使用。</p>\n<h4 id=\"GlobalThis\"><a href=\"#GlobalThis\" class=\"headerlink\" title=\"GlobalThis\"></a>GlobalThis</h4><p>由于 JavaScript 的代码可以运行在多个不同的环境，例如 浏览器、Node.js、Web Worker 等，要实现这种交叉兼容性绝非易事，globalThis 的出现方便了这些操作。<br><code>globalThis</code> 是一个新的全局属性，通常它引用的是当前环境下的全局对象。就像是 <code>self</code> 对于 Web Workers，<code>window</code> 对于浏览器，<code>global</code> 对于 Node.js，以及其他实现了ES2020标准的运行环境。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Hacky globalThis polyfill you had to use pre-ES2020</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> getGlobal = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> self !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> global !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> global;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Couldn't detect global\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">getGlobal() === globalThis; <span class=\"comment\">// true (for browser, Web Worker and Node.js)</span></span><br><span class=\"line\">globalThis === <span class=\"built_in\">window</span>; <span class=\"comment\">// true (if you're in browser)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Promise-allSettled\"><a href=\"#Promise-allSettled\" class=\"headerlink\" title=\"Promise.allSettled()\"></a>Promise.allSettled()</h4><p>这个新增的方法看起来有点像 <code>Promise.all()</code>。<br><code>Promise.all()</code> 的参数中的 promise 若有一个失败，则此实例回调失败。而 <code>Promise.allSettled()</code>不论成功或者失败，都会返回处理结束后的对象数组。</p>\n<h4 id=\"String-matchAll\"><a href=\"#String-matchAll\" class=\"headerlink\" title=\"String.matchAll()\"></a>String.matchAll()</h4><p>如果你之前使用正则，那么相比于在 <code>while</code> 循环中使用 <code>RegExp.exec()</code> 并开启标志 <code>g</code> 来匹配，<code>String.matchAll()</code> 会是更好的选择。它会返回一个包含了所有匹配结果的数组，包括捕获组的匹配结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> regexp = <span class=\"regexp\">/t(e)(st(\\d?))/g</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">\"test1test2\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> resultsArr = [...str.matchAll(regexp)]; <span class=\"comment\">// convert iterator to an array</span></span><br><span class=\"line\"></span><br><span class=\"line\">resultsArr[<span class=\"number\">0</span>]; <span class=\"comment\">// [\"test1\", \"e\", \"st1\", \"1\"]</span></span><br><span class=\"line\">resultsArr[<span class=\"number\">1</span>]; <span class=\"comment\">// [\"test2\", \"e\", \"st2\", \"2\"]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h3><ul>\n<li><a href=\"https://inspiredwebdev.com/everything-from-es-2016-to-es-2019\" target=\"_blank\" rel=\"noopener\">everything-from-es-2016-to-es-2019</a></li>\n<li><a href=\"https://areknawo.com/ecmascript-2020-biggest-new-features/\" target=\"_blank\" rel=\"noopener\">ecmascript-2020-biggest-new-features</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>自 ECMA2015 (6th) 大幅更新之后, ECMA 标准变更成每年6月发布一个版本进行小幅度更新。为方便温习和查找，汇总一下近五年的所有版本特性。本文共涵盖了 ES2016、ES2017、ES2018、ES2019、ES2020 五个版本的更新内容。翻译有删改，仅供快速查找使用。<br></p>","more":"<p></p>\n<h3 id=\"前言：关于ECMA\"><a href=\"#前言：关于ECMA\" class=\"headerlink\" title=\"前言：关于ECMA\"></a>前言：关于ECMA</h3><p>ECMA 相关stage-x 处于某个阶段，描述的是 ECMA 标准相关的内容。根据提案划分界限，stage-x 大致分为以下阶段:</p>\n<ul>\n<li>stage-0：还是一个设想，只能由 TC39 成员或 TC39 贡献者提出。</li>\n<li>stage-1：提案阶段，比较正式的提议，只能由 TC39 成员发起，这个提案要解决的问题必须有正式的书面描述。</li>\n<li>stage-2：草案，有了初始规范，必须对功能语法和语义进行正式描述，包括一些实验性的实现。</li>\n<li>stage-3：候选，该提议基本已经实现，需要等待实验验证，用户反馈及验收测试通过。</li>\n<li>stage-4：已完成，必须通过 Test262 验收测试，下一步就纳入 ECMA 标准。</li>\n</ul>\n<p>总结起来就是数字越大，越成熟。</p>\n<h3 id=\"ES2016-新特性\"><a href=\"#ES2016-新特性\" class=\"headerlink\" title=\"ES2016 新特性\"></a>ES2016 新特性</h3><p>ES2016 只更新了两个特性：</p>\n<ul>\n<li>Array.prototype.includes()</li>\n<li>指数运算符</li>\n</ul>\n<h4 id=\"Array-prototype-includes\"><a href=\"#Array-prototype-includes\" class=\"headerlink\" title=\"Array.prototype.includes()\"></a>Array.prototype.includes()</h4><p>该方法用于检测数组中是否包含某个值，包含则返回 true，否则返回 false。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">array.includes(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\">array.includes(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>结合 fromIndex 使用：</p>\n</blockquote>\n<p>可以为 <code>.includes()</code> 提供一个起始索引，默认是 0，接受负数值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array = [ <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span> ];</span><br><span class=\"line\"></span><br><span class=\"line\">array.includes(<span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// find the number 3 starting from array index 1</span></span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\">array.includes(<span class=\"number\">5</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">//false</span></span><br><span class=\"line\">array.includes(<span class=\"number\">1</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"comment\">// find the number 1 starting from the ending of the array going backwards</span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br><span class=\"line\">array.includes(<span class=\"number\">11</span>, <span class=\"number\">-3</span>);</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"指数操作符\"><a href=\"#指数操作符\" class=\"headerlink\" title=\"指数操作符 (**)\"></a>指数操作符 (**)</h4><p>在 ES2016 前我们会这样写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure></p>\n<p>现在，有了指数运算符之后，可以这样写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure></p>\n<p>这在多次操作指数运算的时候很有用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">2</span> ** <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">// 16</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">2</span>), <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 16</span></span><br></pre></td></tr></table></figure></p>\n<p><code>Math.pow()</code> 需要连续调用，这会使代码看起来很长不宜阅读。使用指数运算符的方式更快更简洁。</p>\n<h3 id=\"ES2017-新特性\"><a href=\"#ES2017-新特性\" class=\"headerlink\" title=\"ES2017 新特性\"></a>ES2017 新特性</h3><p>ES2017 介绍了更多新特性，如 String padding，Object.entries(), Object.values(), 原子性操作， 以及 Async、Await 等。</p>\n<h4 id=\"字符串填充-String-padStart-和-String-padEnd\"><a href=\"#字符串填充-String-padStart-和-String-padEnd\" class=\"headerlink\" title=\"字符串填充 ( String.padStart() 和 String.padEnd() )\"></a>字符串填充 ( String.padStart() 和 String.padEnd() )</h4><p><code>.padStart()</code> 对字符串头部进行填充， <code>.padEnd()</code> 对字符串尾部进行填充：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"hello\"</span>.padStart(<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"comment\">// \" hello\"</span></span><br><span class=\"line\"><span class=\"string\">\"hello\"</span>.padEnd(<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"comment\">// \"hello \"</span></span><br></pre></td></tr></table></figure></p>\n<p>为什么只填充1个空格而不是6个？是因为 “hello” 一共是五个字符，而 <code>.padStart</code> 和 <code>.padEnd</code> 的入参是填充后的字符串长度，所以之只会填充一个空格。 </p>\n<blockquote>\n<p>使用 padStart 实现文本右对齐<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> strings = [<span class=\"string\">\"short\"</span>, <span class=\"string\">\"medium length\"</span>, <span class=\"string\">\"very long string\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> longestString = strings.sort(<span class=\"function\">(<span class=\"params\">s1, s2</span>) =&gt;</span> s2.length - s1.length).map(<span class=\"function\"><span class=\"params\">str</span> =&gt;</span> str.length)[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">strings.forEach(<span class=\"function\"><span class=\"params\">str</span> =&gt;</span> <span class=\"built_in\">console</span>.log(str.padStart(longestString)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// very long string</span></span><br><span class=\"line\"><span class=\"comment\">//    medium length</span></span><br><span class=\"line\"><span class=\"comment\">//            short</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>第一步获取了数组中最长字符串的长度，接下来用该长度填充数组中的每个字符串，即打印出一组右对齐的字符串。</p>\n<blockquote>\n<p>自定义填充值</p>\n</blockquote>\n<p>除了默认的空格，还可以使用字符串和数字进行填充。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"hello\"</span>.padEnd(<span class=\"number\">13</span>,<span class=\"string\">\" Alberto\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// \"hello Alberto\"</span></span><br><span class=\"line\"><span class=\"string\">\"1\"</span>.padStart(<span class=\"number\">3</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// \"001\"</span></span><br><span class=\"line\"><span class=\"string\">\"99\"</span>.padStart(<span class=\"number\">3</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// \"099\"</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Object-entries-和-Object-values\"><a href=\"#Object-entries-和-Object-values\" class=\"headerlink\" title=\"Object.entries() 和 Object.values()\"></a>Object.entries() 和 Object.values()</h4><p>首先创建一个Object：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> family = &#123;</span><br><span class=\"line\">  father: <span class=\"string\">\"Jonathan Kent\"</span>,</span><br><span class=\"line\">  mother: <span class=\"string\">\"Martha Kent\"</span>,</span><br><span class=\"line\">  son: <span class=\"string\">\"Clark Kent\"</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上个版本的 javascript 中，我们可以使用如下方式获取 Object 中的值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.keys(family);</span><br><span class=\"line\"><span class=\"comment\">// [\"father\", \"mother\", \"son\"]</span></span><br><span class=\"line\">family.father;</span><br><span class=\"line\"><span class=\"string\">\"Jonathan Kent\"</span></span><br></pre></td></tr></table></figure></p>\n<p><code>Object.keys()</code> 仅会返回对象中所有的键名。</p>\n<p>现在又多了两种可以访问对象的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.values(family);</span><br><span class=\"line\"><span class=\"comment\">// [\"Jonathan Kent\", \"Martha Kent\", \"Clark Kent\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.entries(family);</span><br><span class=\"line\"><span class=\"comment\">// [\"father\", \"Jonathan Kent\"]</span></span><br><span class=\"line\"><span class=\"comment\">// [\"mother\", \"Martha Kent\"]</span></span><br><span class=\"line\"><span class=\"comment\">// [\"son\", \"Clark Kent\"]</span></span><br></pre></td></tr></table></figure>\n<p><code>Object.values()</code> 以数组形式返回对象所有值。<br><code>Object.entries()</code> 同样以数组形式返回对象中的键值对。</p>\n<h4 id=\"Object-getOwnPropertyDescriptors\"><a href=\"#Object-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"Object.getOwnPropertyDescriptors()\"></a>Object.getOwnPropertyDescriptors()</h4><p>这个方法会返回对象所有自身属性的描述。描述性的字段有：<code>value</code>，<code>writable</code>, <code>get</code>, <code>set</code>, <code>configurable</code> 和 <code>enumerable</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myObj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"Alberto\"</span>,</span><br><span class=\"line\">  age: <span class=\"number\">25</span>,</span><br><span class=\"line\">  greet() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyDescriptors(myObj);</span><br><span class=\"line\"><span class=\"comment\">// age: &#123;value: 25, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// greet: &#123;value: ƒ, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// name: &#123;value: \"Alberto\", writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"尾行逗号\"><a href=\"#尾行逗号\" class=\"headerlink\" title=\"尾行逗号\"></a>尾行逗号</h4><p>这仅仅是语法上的一个小改变。现在在写 Object 属性值时，我们可以在每个值后边加上一个逗号，不论它是否是最后一个。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// from this</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> object = &#123;</span><br><span class=\"line\">  prop1: <span class=\"string\">\"prop\"</span>,</span><br><span class=\"line\">  prop2: <span class=\"string\">\"propop\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// to this</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> object = &#123;</span><br><span class=\"line\">  prop1: <span class=\"string\">\"prop\"</span>,</span><br><span class=\"line\">  prop2: <span class=\"string\">\"propop\"</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意上述第二个例子中的最后一个逗号，即使你不写它也不会报错，只是写上会更方便的开发者们协作。</p>\n<h4 id=\"共享内存和原子性操作\"><a href=\"#共享内存和原子性操作\" class=\"headerlink\" title=\"共享内存和原子性操作\"></a>共享内存和原子性操作</h4><p>下述引自 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics\" target=\"_blank\" rel=\"noopener\">MDN</a>:</p>\n<blockquote>\n<p>多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。</p>\n</blockquote>\n<p>这些原子操作属于 Atomics 模块。与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math  对象一样）。</p>\n<p>方法示例：</p>\n<ul>\n<li>add / sub</li>\n<li>and / or / xor</li>\n<li>load / store</li>\n</ul>\n<p><code>Atomics</code> 通常和 <code>SharedArrayBuffer</code> 对象（通用的固定长度二进制数据缓冲区）一起使用。<br>来看一下几个 <code>Atomics</code>方法的使用示例：</p>\n<h5 id=\"Atomics-add-Atomics-sub-Atomics-load-and-Atomics-store\"><a href=\"#Atomics-add-Atomics-sub-Atomics-load-and-Atomics-store\" class=\"headerlink\" title=\"Atomics.add(), Atomics.sub(), Atomics.load(), and Atomics.store()\"></a>Atomics.add(), Atomics.sub(), Atomics.load(), and Atomics.store()</h5><p><code>Atomics.add()</code> 共接受三个参数：array、index、value。并返回该索引在执行操作前的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create a `SharedArrayBuffer`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buffer = <span class=\"keyword\">new</span> SharedArrayBuffer(<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> uint8 = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// add a value at the first position</span></span><br><span class=\"line\">uint8[<span class=\"number\">0</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Atomics.add(uint8, <span class=\"number\">0</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 10 + 5 = 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(uint8[<span class=\"number\">0</span>])</span><br><span class=\"line\"><span class=\"comment\">// 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Atomics.load(uint8, <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n<p>要从数组中检索特定的值，可以使用 <code>Atomics.load()</code> 并传递两个参数，一个数组和一个索引。<br><code>Atomics.sub()</code> 的使用方式与 <code>Atomics.add()</code> 类似，只不过它是减去某个值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create a `SharedArrayBuffer`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> buffer = <span class=\"keyword\">new</span> SharedArrayBuffer(<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> uint8 = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// add a value at the first position</span></span><br><span class=\"line\">uint8[<span class=\"number\">0</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Atomics.sub(uint8, <span class=\"number\">0</span>, <span class=\"number\">5</span>));</span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 10 - 5 = 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(uint8[<span class=\"number\">0</span>])</span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Atomics.store(uint8, <span class=\"number\">0</span>, <span class=\"number\">3</span>));</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Atomics.load(uint8, <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>上述示例调用 <code>Atomics.sub()</code> 方法，实现 unit8[0] - 5 ，相当于 10 - 5。如同 <code>Atomics.add()</code> 一样，该方法也会返回数组中该索引在执行操作前的值。</p>\n<p>使用 <code>Atomics.store()</code> 来存储一个值，使用 <code>Atomics.load()</code> 来加载一个值。</p>\n<h5 id=\"Atomics-and-Atomics-or-Atomics-xor\"><a href=\"#Atomics-and-Atomics-or-Atomics-xor\" class=\"headerlink\" title=\"Atomics.and(), Atomics.or(), Atomics.xor()\"></a>Atomics.and(), Atomics.or(), Atomics.xor()</h5><p>这三个方法都在数组的给定位置执行按位的 AND、OR 和 XOR 操作。不再赘述。</p>\n<h4 id=\"Async-和-Await\"><a href=\"#Async-和-Await\" class=\"headerlink\" title=\"Async 和 Await\"></a>Async 和 Await</h4><p>ES2017 提供了两个操作 Promise 的新方法：”async/await”。</p>\n<h5 id=\"回顾一下-Promise\"><a href=\"#回顾一下-Promise\" class=\"headerlink\" title=\"回顾一下 Promise\"></a>回顾一下 Promise</h5><p>在介绍新语法之前，让我们快速浏览下之前我们是怎么使用 Promise 的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fetch a user from github</span></span><br><span class=\"line\">fetch(<span class=\"string\">'api.github.com/user/AlbertoMontalesi'</span>).then( <span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// return the data in json format</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res.json();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// if everything went well, print the data</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">&#125;).catch( <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// or print the error</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>上述是一个非常简单的例子：请求一个 Github 用户的数据，并打印。下面来看个复杂点的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">walk</span>(<span class=\"params\">amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (amount &lt; <span class=\"number\">500</span>) &#123;</span><br><span class=\"line\">      reject (<span class=\"string\">\"the value is too small\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(<span class=\"string\">`you walked for <span class=\"subst\">$&#123;amount&#125;</span>ms`</span>),amount);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">walk(<span class=\"number\">1000</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> walk(<span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> walk(<span class=\"number\">700</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> walk(<span class=\"number\">800</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> walk(<span class=\"number\">100</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> walk(<span class=\"number\">400</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> walk(<span class=\"number\">600</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// you walked for 1000ms</span></span><br><span class=\"line\"><span class=\"comment\">// you walked for 500ms</span></span><br><span class=\"line\"><span class=\"comment\">// you walked for 700ms</span></span><br><span class=\"line\"><span class=\"comment\">// you walked for 800ms</span></span><br><span class=\"line\"><span class=\"comment\">// uncaught exception: the value is too small</span></span><br></pre></td></tr></table></figure>\n<p>来看下，如何用新语法 async / await 来重写 <code>Promise</code>。</p>\n<h5 id=\"Async-和-Await-1\"><a href=\"#Async-和-Await-1\" class=\"headerlink\" title=\"Async 和 Await\"></a>Async 和 Await</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">walk</span>(<span class=\"params\">amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (amount &lt; <span class=\"number\">500</span>) &#123;</span><br><span class=\"line\">      reject (<span class=\"string\">\"the value is too small\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(<span class=\"string\">`you walked for <span class=\"subst\">$&#123;amount&#125;</span>ms`</span>),amount);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// create an async function</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// use the keyword `await` to wait for the response</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> walk(<span class=\"number\">500</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res2 = <span class=\"keyword\">await</span> walk(<span class=\"number\">900</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res2);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res3 = <span class=\"keyword\">await</span> walk(<span class=\"number\">600</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res3);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res4 = <span class=\"keyword\">await</span> walk(<span class=\"number\">700</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res4);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res5 = <span class=\"keyword\">await</span> walk(<span class=\"number\">400</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res5);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"finished\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">go();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// you walked for 500ms </span></span><br><span class=\"line\"><span class=\"comment\">// you walked for 900ms </span></span><br><span class=\"line\"><span class=\"comment\">// you walked for 600ms </span></span><br><span class=\"line\"><span class=\"comment\">// you walked for 700ms </span></span><br><span class=\"line\"><span class=\"comment\">// uncaught exception: the value is too small</span></span><br></pre></td></tr></table></figure>\n<p>让我们来分解一下上述代码都做了什么：</p>\n<ul>\n<li>创建一个异步函数需要在 function 前面添加 async 关键词</li>\n<li>这个关键词会告诉 Javascript 返回一个 Promise</li>\n<li>如果指定 async 函数返回一个非 Promise 的值，那么这个值将会被包含在 Promise 中然后被返回</li>\n<li>顾名思义， await 会告诉 Javascript 等待 promise 返回结果</li>\n</ul>\n<h5 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h5><p>通常在 promise 中，我们使用 <code>.catch()</code> 捕获最终的错误。现在有一点不同了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncFunc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> response = <span class=\"keyword\">await</span> fetch(<span class=\"string\">'http:your-url'</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncFunc();</span><br><span class=\"line\"><span class=\"comment\">// TypeError: failed to fetch</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ES2018-新特性\"><a href=\"#ES2018-新特性\" class=\"headerlink\" title=\"ES2018 新特性\"></a>ES2018 新特性</h3><h4 id=\"对象扩展运算符\"><a href=\"#对象扩展运算符\" class=\"headerlink\" title=\"对象扩展运算符\"></a>对象扩展运算符</h4><p>还记得 ES6 中我们可以使用扩展运算符来做什么吗：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> veggie = [<span class=\"string\">\"tomato\"</span>, <span class=\"string\">\"cucumber\"</span>, <span class=\"string\">\"beans\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> meat = [<span class=\"string\">\"pork\"</span>, <span class=\"string\">\"beef\"</span>, <span class=\"string\">\"chicken\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> menu = [...veggie, <span class=\"string\">\"pasta\"</span>, ...meat];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(menu);</span><br><span class=\"line\"><span class=\"comment\">// Array [ \"tomato\", \"cucumber\", \"beans\", \"pasta\", \"pork\", \"beef\", \"chicken\" ]</span></span><br></pre></td></tr></table></figure></p>\n<p>现在，扩展运算符同样适用于对象：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: <span class=\"number\">3</span>,</span><br><span class=\"line\">  c: <span class=\"number\">5</span>,</span><br><span class=\"line\">  d: <span class=\"number\">8</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// we use the rest operator to grab everything else left in the object.</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b, ...z &#125; = myObj;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);     <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);     <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(z);     <span class=\"comment\">// &#123;c: 5, d: 8&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// using the spread syntax we cloned our Object</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> clone = &#123; ...myObj &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(clone);</span><br><span class=\"line\"><span class=\"comment\">// &#123;a: 1, b: 3, c: 5, d: 8&#125;</span></span><br><span class=\"line\">myObj.e = <span class=\"number\">15</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(clone)</span><br><span class=\"line\"><span class=\"comment\">// &#123;a: 1, b: 3, c: 5, d: 8&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myObj)</span><br><span class=\"line\"><span class=\"comment\">// &#123;a: 1, b: 3, c: 5, d: 8, e: 15&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>使用扩展运算符，我们可以轻松的复制对象（浅复制）。</p>\n<h4 id=\"异步的迭代\"><a href=\"#异步的迭代\" class=\"headerlink\" title=\"异步的迭代\"></a>异步的迭代</h4><p>使用异步的迭代，我们可以异步的遍历数据。<br><a href=\"https://github.com/tc39/proposal-async-iteration\" target=\"_blank\" rel=\"noopener\">引自文档</a></p>\n<blockquote>\n<p>异步迭代器很像迭代器，只不过迭代器的 next 方法返回一对 { value, done }</p>\n</blockquote>\n<p>为此，我们将使用一个 <code>for-await-of</code> 循环，它将迭代转换成 Promise。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> iterables = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> value <span class=\"keyword\">of</span> iterables) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test();</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></p>\n<p>在执行过程中，<code>[Symbol.asyncIterator]()</code> 方法将会创造一个异步的迭代器，每次访问序列中的下一个值时，我们都会隐式地等待迭代器方法返回 Promise。</p>\n<h4 id=\"Promise-prototype-finally\"><a href=\"#Promise-prototype-finally\" class=\"headerlink\" title=\"Promise.prototype.finally()\"></a>Promise.prototype.finally()</h4><p>引自 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally\" target=\"_blank\" rel=\"noopener\">MDN</a>:</p>\n<blockquote>\n<p>finally() 方法返回一个 Promise。在 Promise 结束时，无论结果是 fulfilled 或者是 rejected，都会执行指定的回调函数。这为在 Promise 是否成功完成后都需要执行的代码提供了一种方式。避免了同样的语句需要在 then() 和 catch() 中各写一次的情况。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;)；</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'still working'</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'there was an error'</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .finally(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Done!'</span>);</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p><code>.finally()</code> 同样会返回一个 promise，所以我们可以继续链式调用 <code>then</code> 和 <code>catch</code> 方法，但是它们是基于之前的 promise 进行调用的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myPromise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;)；</span><br><span class=\"line\"></span><br><span class=\"line\">myPromise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'still working'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'still working'</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .finally(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Done!'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Done!'</span>;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"><span class=\"comment\">// still working</span></span><br><span class=\"line\"><span class=\"comment\">// Done!</span></span><br><span class=\"line\"><span class=\"comment\">// still working</span></span><br></pre></td></tr></table></figure></p>\n<p>从上边代码可以看到 <code>finally</code> 后边的 <code>then</code> 返回的值是由第一个 <code>then</code> 创建的，而不是 <code>finally</code>。</p>\n<h4 id=\"正则表达式的新特性\"><a href=\"#正则表达式的新特性\" class=\"headerlink\" title=\"正则表达式的新特性\"></a>正则表达式的新特性</h4><p>在新版的 ECMA 中，共更新了 4 个关于正则的特性。</p>\n<ul>\n<li>正则表达式的 s (doAll) 标志</li>\n<li>正则表达式捕获组命名</li>\n<li>正则表达式反向断言 (Lookbehind Assertions)</li>\n<li>unicode 字符转义 (Unicode property escapes) </li>\n</ul>\n<h5 id=\"s-doAll-标志\"><a href=\"#s-doAll-标志\" class=\"headerlink\" title=\"s (doAll) 标志\"></a>s (doAll) 标志</h5><blockquote>\n<p>引自<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n</blockquote>\n<p><code>dotAll</code> 属性表明是否在正则表达式中一起使用 “<code>s</code>“ 修饰符（引入 /s 修饰符，使得<code>.</code>可以匹配任意单个字符，包括换行符和回车符）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/foo.bar/s.test(<span class=\"string\">'foo\\nbar'</span>);</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"捕获组命名\"><a href=\"#捕获组命名\" class=\"headerlink\" title=\"捕获组命名\"></a>捕获组命名</h5><blockquote>\n<p>想要引用正则匹配到的某一部分字符串可以为捕获组编号。每个捕获组的数字都是唯一的，可以对应的数字引用它们，但是这使正则表达式难以阅读和维护。例如 <code>/(\\d{4})-(\\d{2})-(\\d{2})/</code> 匹配一个日期，但如果不看上下文的代码，就无法确定哪一组对应于月份，哪一组是一天。当然，如果哪一天需要交换日期和月份的顺序，那么对应的组引用也需要更新。现在，可以使用 <code>(?&lt;name&gt;...)</code> 来为捕获组命名，以表示任何标识符名称。重写上述例子：<code>/(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})/u</code> 每一个命名都是唯一且遵循 ECMA 命名规范的。命名的组可以通过匹配结果的 <code>result</code> 属性来访问。对组的数字引用也会被建立，就像未命名的组一样。看下边几个例子：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> re = <span class=\"regexp\">/(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = re.exec(<span class=\"string\">'2015-01-02'</span>);</span><br><span class=\"line\"><span class=\"comment\">// result.groups.year === '2015';</span></span><br><span class=\"line\"><span class=\"comment\">// result.groups.month === '01';</span></span><br><span class=\"line\"><span class=\"comment\">// result.groups.day === '02';</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// result[0] === '2015-01-02';</span></span><br><span class=\"line\"><span class=\"comment\">// result[1] === '2015';</span></span><br><span class=\"line\"><span class=\"comment\">// result[2] === '01';</span></span><br><span class=\"line\"><span class=\"comment\">// result[3] === '02';</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">groups</span>: &#123; one, two &#125; &#125; = <span class=\"regexp\">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class=\"string\">'foo:bar'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`one: <span class=\"subst\">$&#123;one&#125;</span>, two: <span class=\"subst\">$&#123;two&#125;</span>`</span>); </span><br><span class=\"line\"><span class=\"comment\">// one: foo, two: bar</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"反向断言\"><a href=\"#反向断言\" class=\"headerlink\" title=\"反向断言\"></a>反向断言</h5><blockquote>\n<p>使用反向断言可以确保匹配之前或者之后没有其他匹配。反向断言的语法表示为 <code>(?&lt;=...)</code> 。<br>例如：匹配一个美元数值且不包含美元符号可以这样写 <code>/(?&lt;=$)\\d+(\\.\\d*)?/</code>，这个表达式会匹配 <code>$10.53</code> 并返回 <code>10.53</code>，而并不会匹配 <code>€10.53</code>。而 <code>(?&lt;!...)</code> 匹配的规则正相反，它会匹配不存在表达式中的匹配项，例如 <code>/(?&lt;!$)\\d+(?:\\.\\d*)/</code> 不会匹配 <code>$10.53</code>，但是会匹配 <code>€10.53</code>。</p>\n</blockquote>\n<h5 id=\"Unicode-字符转义\"><a href=\"#Unicode-字符转义\" class=\"headerlink\" title=\"Unicode 字符转义\"></a>Unicode 字符转义</h5><blockquote>\n<p>Unicode 字符转义是一种新的转义序列，<code>u</code> 作为字符转义的标志， <code>\\p{...}</code> 和 <code>\\P{...}</code> 用来添加转义符。有了这个特性，匹配 Unicode 字符可以这样写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> regexGreekSymbol = <span class=\"regexp\">/\\p&#123;Script=Greek&#125;/u</span>;</span><br><span class=\"line\">regexGreekSymbol.test(<span class=\"string\">'π'</span>);</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"解除模板字符限制\"><a href=\"#解除模板字符限制\" class=\"headerlink\" title=\"解除模板字符限制\"></a>解除模板字符限制</h4><p>当使用 Tagged 模板字符串时，转义字符的限制被移除了（<a href=\"https://tc39.github.io/proposal-template-literal-revision/#sec-template-literals\" target=\"_blank\" rel=\"noopener\">阅读更多</a>）</p>\n<h3 id=\"ES2019-新特性\"><a href=\"#ES2019-新特性\" class=\"headerlink\" title=\"ES2019 新特性\"></a>ES2019 新特性</h3><h4 id=\"Array-prototype-flat-Array-prototype-flatMap\"><a href=\"#Array-prototype-flat-Array-prototype-flatMap\" class=\"headerlink\" title=\"Array.prototype.flat() / Array.prototype.flatMap()\"></a>Array.prototype.flat() / Array.prototype.flatMap()</h4><p><code>Array.prototype.flat()</code> 会递归地展平一个数组并作为新值返回，它接受一个表示递归深度的值，未传值则默认深度为1。可以用 <code>Infinity</code> 去展平所有嵌套的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> letters = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, [<span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, [<span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>]]];</span><br><span class=\"line\"><span class=\"comment\">// default depth of 1</span></span><br><span class=\"line\">letters.flat();</span><br><span class=\"line\"><span class=\"comment\">// ['a', 'b', 'c', 'd', ['e', 'f']]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// depth of 2</span></span><br><span class=\"line\">letters.flat(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// which is the same as executing flat with depth of 1 twice</span></span><br><span class=\"line\">letters.flat().flat();</span><br><span class=\"line\"><span class=\"comment\">// ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Flattens recursively until the array contains no nested arrays</span></span><br><span class=\"line\">letters.flat(<span class=\"literal\">Infinity</span>)</span><br><span class=\"line\"><span class=\"comment\">// ['a', 'b', 'c', 'd', 'e', 'f']</span></span><br></pre></td></tr></table></figure>\n<p><code>Array.prototype.flatMap()</code> 与深度值为1的 flat 几乎相同，但它并非仅仅展平数组。 flatMap 接收一个处理函数，使用 <code>flatMap()</code> 可以在展平的同时更改对应的值并返回一个新的数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> greeting = [<span class=\"string\">\"Greetings from\"</span>, <span class=\"string\">\" \"</span>, <span class=\"string\">\"Vietnam\"</span>];</span><br><span class=\"line\">greeting.flatMap(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x.split(<span class=\"string\">\" \"</span>))</span><br><span class=\"line\"><span class=\"comment\">// [\"Greetings\", \"from\", \"\", \"\", \"Vietnam\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>这有点类似于 <code>map()</code> 方法，只不过多了一次展平操作。</p>\n<h4 id=\"Object-fromEntries\"><a href=\"#Object-fromEntries\" class=\"headerlink\" title=\"Object.fromEntries()\"></a>Object.fromEntries()</h4><p>Object.fromEntries() 将一组键值对转换成对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> keyValueArray = [</span><br><span class=\"line\">  [<span class=\"string\">'key1'</span>, <span class=\"string\">'value1'</span>],</span><br><span class=\"line\">  [<span class=\"string\">'key2'</span>, <span class=\"string\">'value2'</span>]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.fromEntries(keyValueArray)</span><br><span class=\"line\"><span class=\"comment\">// &#123;key1: \"value1\", key2: \"value2\"&#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们可以将任何可迭代的值作为 <code>Object.entries()</code> 方法的参数，不论它是一个 <code>Array</code> 还是 <code>Map</code>，或是其他实现了迭代协议的值。</p>\n<p>注：可迭代协议( Iteration Protocols )是 ES2015 提出的，通常通过常量 <code>Symbol.iterator</code> 访问该对象的可迭代属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someString = <span class=\"string\">\"hi\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> someString[<span class=\"built_in\">Symbol</span>.iterator]; <span class=\"comment\">// \"function\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> iterator = someString[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\"></span><br><span class=\"line\">iterator + <span class=\"string\">\"\"</span>;  <span class=\"comment\">// \"[object String Iterator]\"</span></span><br><span class=\"line\">iterator.next()    <span class=\"comment\">// &#123; value: \"h\", done: false &#125;</span></span><br><span class=\"line\">iterator.next();   <span class=\"comment\">// &#123; value: \"i\", done: false &#125;</span></span><br><span class=\"line\">iterator.next();   <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols\" target=\"_blank\" rel=\"noopener\">阅读更多关于迭代协议的内容</a></p>\n<h4 id=\"String-prototype-trimStart-trimEnd\"><a href=\"#String-prototype-trimStart-trimEnd\" class=\"headerlink\" title=\"String.prototype.trimStart() / .trimEnd()\"></a>String.prototype.trimStart() / .trimEnd()</h4><p><code>String.prototype.trimStart()</code> 移除字符串前面的空白符，<code>String.prototype.trimEnd()</code> 移除字符串后面的空白符。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"    this string has a lot of whitespace   \"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">str.length;</span><br><span class=\"line\"><span class=\"comment\">// 42</span></span><br><span class=\"line\"></span><br><span class=\"line\">str = str.trimStart();</span><br><span class=\"line\"><span class=\"comment\">// \"this string has a lot of whitespace   \"</span></span><br><span class=\"line\">str.length;</span><br><span class=\"line\"><span class=\"comment\">// 38</span></span><br><span class=\"line\"></span><br><span class=\"line\">str = str.trimEnd();</span><br><span class=\"line\"><span class=\"comment\">// \"this string has a lot of whitespace\"</span></span><br><span class=\"line\">str.length;</span><br><span class=\"line\"><span class=\"comment\">// 35</span></span><br></pre></td></tr></table></figure></p>\n<p>也可以使用 <code>.trimStart()</code> 和 <code>trimEnd()</code> 的别名： <code>.trimLeft()</code> 和 <code>.trimRight()</code> 。</p>\n<h4 id=\"可选的-catch-捕获参数\"><a href=\"#可选的-catch-捕获参数\" class=\"headerlink\" title=\"可选的 catch 捕获参数\"></a>可选的 catch 捕获参数</h4><p>在 ES2019 之前，你必须为 catch 捕获传递一个表示异常的变量，现在这个变量不是必要的了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Before</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(error) &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES2019</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这在你想忽略错误参数的时候很有用。</p>\n<h4 id=\"Function-ptototype-toString\"><a href=\"#Function-ptototype-toString\" class=\"headerlink\" title=\"Function.ptototype.toString()\"></a>Function.ptototype.toString()</h4><p><code>.toString()</code> 方法返回一个代表函数源码的字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum.toString());</span><br><span class=\"line\"><span class=\"comment\">// function sum(a, b) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    return a + b;</span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>注释也会被包含其中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// perform a sum</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum.toString());</span><br><span class=\"line\"><span class=\"comment\">// function sum(a, b) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   // perform a sum</span></span><br><span class=\"line\"><span class=\"comment\">//   return a + b;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Symbol-prototype-description\"><a href=\"#Symbol-prototype-description\" class=\"headerlink\" title=\"Symbol.prototype.description\"></a>Symbol.prototype.description</h4><p><code>.description</code> 返回 <code>Symbol</code> 对象可选描述的字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> me = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"Alberto\"</span>);</span><br><span class=\"line\">me.description;</span><br><span class=\"line\"><span class=\"comment\">// \"Alberto\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">me.toString()</span><br><span class=\"line\"><span class=\"comment\">//  \"Symbol(Alberto)\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ES2020-特性\"><a href=\"#ES2020-特性\" class=\"headerlink\" title=\"ES2020 特性\"></a>ES2020 特性</h3><h4 id=\"BigInt-类型\"><a href=\"#BigInt-类型\" class=\"headerlink\" title=\"BigInt 类型\"></a>BigInt 类型</h4><p>BigInt 是 JavaScript 第七个原始类型，它允许开发者操作非常大的整型。<br>数字类型可以处理 <code>2 ** 53 - 1</code> 即 <code>9007199254740991</code> 以内的数。可以通过常量 <code>MAX_SAFE_INTEGER</code> 来访问这个值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>.MAX_SAFE_INTEGER; <span class=\"comment\">// 9007199254740991</span></span><br></pre></td></tr></table></figure></p>\n<p>顾名思义，若操作的 number 值超过最大值时,运行结果就会变的奇怪。使用 <code>BigInt</code> 类型则没有明确的界限，因为它的界限取决于运行设备的内存。<br>定义 <code>BigInt</code> 类型，你即可以通过给 <code>BigInt()</code> 构造函数传递一个字符串值来创建，也可以像平常一样使用字面量语法来创建，但是要在尾部加上一个字符 <code>n</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myBigInt = BigInt(<span class=\"string\">\"999999999999999999999999999999\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> mySecondBigInt = <span class=\"number\">999999999999999999999999999999</span>n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> myBigInt; <span class=\"comment\">// \"bigint\"</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>BigInt</code> 类型与常规类型的数字并不是完全兼容的，这意味这你确定最好仅在操作比较大的数据时使用它。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bigInt = <span class=\"number\">1</span>n; <span class=\"comment\">// small number, but still of BigInt type</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> num = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">num === bigInt; <span class=\"comment\">// false -&gt; they aren't strictly equal</span></span><br><span class=\"line\">num == bigInt; <span class=\"comment\">// true</span></span><br><span class=\"line\">num &gt;= bigInt; <span class=\"comment\">// true -&gt; they can be compared</span></span><br><span class=\"line\">num + bigInt; <span class=\"comment\">// error -&gt; they can't operate with one another</span></span><br></pre></td></tr></table></figure>\n<p>总之，使用 JS 做比较复杂的数学运算时 <code>BigInt</code> 是个不错的选择。它在替换专门用于处理大量数字的库方面表现良好。现在至少在整型方向有所进展，而目前我们对 <code>BigDecimal</code> 的提案了解的还很少。</p>\n<h4 id=\"动态导入（Dynamic-imports）\"><a href=\"#动态导入（Dynamic-imports）\" class=\"headerlink\" title=\"动态导入（Dynamic imports）\"></a>动态导入（Dynamic imports）</h4><p>动态导入，允许在浏览器端动态地加载代码模块。使用 <code>import()</code> 语法来导入你的代码块。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"string\">\"module.js\"</span>).then(<span class=\"function\">(<span class=\"params\"><span class=\"built_in\">module</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">module</span> = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">\"module.js\"</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>import()</code> 返回一个 promise，resolve 中会返回代码模块加载后的内容。可以使用 ES6 的 <code>.then()</code> 方法或者 <code>async/await</code> 来处理加载结果。</p>\n<h4 id=\"空值合并操作符（-）\"><a href=\"#空值合并操作符（-）\" class=\"headerlink\" title=\"空值合并操作符（??）\"></a>空值合并操作符（??）</h4><p>空值合并操作符（??）是一个新的 JS 运算符，当所访问的值是 null 或者 undefined 时，它会提供一个默认值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> basicValue = <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> nullishValue = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> firstExample = basicValue ?? <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"test\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> secondExample = nullishValue ?? <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"example\"</span></span><br></pre></td></tr></table></figure></p>\n<p>但是这跟 逻辑或（||）有什么区别呢？当第一个数是虚值 (在 Boolean 上下文中认定为 false 的值)，如 <code>false</code>, <code>0</code>, 或者<code>&quot;&quot;</code>，以及空值 <code>null</code> 和 <code>undefined</code>，那么 逻辑或 将会使用第二个操作数。而空值合并操作符仅仅是在第一个值为空值而不是虚值的时候才会使用第二个操作数。如果你的代码可以接受除了 <code>null</code> 和 <code>undefined</code> 以外的任何值，那么空值合并操作符就是最佳选择。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> falseValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> zeroValue = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> emptyValue = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> nullishValue = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> firstExampleOR = falseValue || <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"example\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> secondExampleOR = zeroValue || <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"example\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> thirdExampleOR = emptyValue || <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"example\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> forthExampleOR = nullish || <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"example\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> firstExample = falseValue ?? <span class=\"string\">\"example\"</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> secondExample = zeroValue ?? <span class=\"string\">\"example\"</span>; <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> thirdExample = emptyValue ?? <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> forthExample = nullish ?? <span class=\"string\">\"example\"</span>; <span class=\"comment\">// \"example\"</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"可选链（-）\"><a href=\"#可选链（-）\" class=\"headerlink\" title=\"可选链（?.）\"></a>可选链（?.）</h4><p>与空值合并操作符类似，只不过可选链是处理 Object 中 <code>null</code> 和 <code>undefined</code> 的。鉴于直接从空值中国获取属性值会报错，现在可选链会直接将空值返回。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  prop: &#123;</span><br><span class=\"line\">    subProp: &#123;</span><br><span class=\"line\">      value: <span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.prop.subProp.value; <span class=\"comment\">// 1</span></span><br><span class=\"line\">obj.prop.secondSubProp.value; <span class=\"comment\">// error</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj?.prop?.subProp?.value; <span class=\"comment\">// 1</span></span><br><span class=\"line\">obj?.prop?.secondSubProp?.value; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>当然，这只是一个语法糖，但也是一个很受欢迎的补充。记住不要在代码里到处使用这些操作符，他们虽然用起来方便，但从性能角度来说，它比普通的 <code>.</code> 开销要大。而且，若是代码是经过 Babel 和 TypeScript 转义的，则更要谨慎使用。</p>\n<h4 id=\"GlobalThis\"><a href=\"#GlobalThis\" class=\"headerlink\" title=\"GlobalThis\"></a>GlobalThis</h4><p>由于 JavaScript 的代码可以运行在多个不同的环境，例如 浏览器、Node.js、Web Worker 等，要实现这种交叉兼容性绝非易事，globalThis 的出现方便了这些操作。<br><code>globalThis</code> 是一个新的全局属性，通常它引用的是当前环境下的全局对象。就像是 <code>self</code> 对于 Web Workers，<code>window</code> 对于浏览器，<code>global</code> 对于 Node.js，以及其他实现了ES2020标准的运行环境。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Hacky globalThis polyfill you had to use pre-ES2020</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> getGlobal = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> self !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> global !== <span class=\"string\">\"undefined\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> global;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"Couldn't detect global\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">getGlobal() === globalThis; <span class=\"comment\">// true (for browser, Web Worker and Node.js)</span></span><br><span class=\"line\">globalThis === <span class=\"built_in\">window</span>; <span class=\"comment\">// true (if you're in browser)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Promise-allSettled\"><a href=\"#Promise-allSettled\" class=\"headerlink\" title=\"Promise.allSettled()\"></a>Promise.allSettled()</h4><p>这个新增的方法看起来有点像 <code>Promise.all()</code>。<br><code>Promise.all()</code> 的参数中的 promise 若有一个失败，则此实例回调失败。而 <code>Promise.allSettled()</code>不论成功或者失败，都会返回处理结束后的对象数组。</p>\n<h4 id=\"String-matchAll\"><a href=\"#String-matchAll\" class=\"headerlink\" title=\"String.matchAll()\"></a>String.matchAll()</h4><p>如果你之前使用正则，那么相比于在 <code>while</code> 循环中使用 <code>RegExp.exec()</code> 并开启标志 <code>g</code> 来匹配，<code>String.matchAll()</code> 会是更好的选择。它会返回一个包含了所有匹配结果的数组，包括捕获组的匹配结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> regexp = <span class=\"regexp\">/t(e)(st(\\d?))/g</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"string\">\"test1test2\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> resultsArr = [...str.matchAll(regexp)]; <span class=\"comment\">// convert iterator to an array</span></span><br><span class=\"line\"></span><br><span class=\"line\">resultsArr[<span class=\"number\">0</span>]; <span class=\"comment\">// [\"test1\", \"e\", \"st1\", \"1\"]</span></span><br><span class=\"line\">resultsArr[<span class=\"number\">1</span>]; <span class=\"comment\">// [\"test2\", \"e\", \"st2\", \"2\"]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"原文链接\"><a href=\"#原文链接\" class=\"headerlink\" title=\"原文链接\"></a>原文链接</h3><ul>\n<li><a href=\"https://inspiredwebdev.com/everything-from-es-2016-to-es-2019\" target=\"_blank\" rel=\"noopener\">everything-from-es-2016-to-es-2019</a></li>\n<li><a href=\"https://areknawo.com/ecmascript-2020-biggest-new-features/\" target=\"_blank\" rel=\"noopener\">ecmascript-2020-biggest-new-features</a></li>\n</ul>"},{"title":"使用 Performance APi 进行前端性能监控","date":"2019-07-11T10:55:59.000Z","_content":"&emsp;&emsp;平常只在测试环境测过前端页面性能，到了真实环境用户的手机上，页面性能的具体表现却未曾了解。H5新增的 Performance API 可以精确的测量网页性能。使开发者可以通过数据上报的方式收集线上H5页面的性能表现，以合理优化页面性能短板，提升用户体验。\n<!--more-->\n\n### 前端性能监控指标\n* __白屏时间__: 从打开网站到有内容渲染出来的时间节点\n* __首屏时间__: 首屏内容渲染完毕的时间节点\n* __domReady 时间__: 用户可操作的时间节点\n* __onload 时间__: 总下载时间\n\n### Performance API 简介\n&emsp;&emsp;[Performace](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance)是 html5的新特性之一，该接口会返回当前页面性能相关的信息。Performance 对象一共提供了4个属性：\n\n* __navigation__: 包含页面加载、刷新、重定向情况\n* __timing__: 包含了各种与浏览器性能有关的时间数据\n* __memory__: 返回JavaScript对内存的占用\n* __timeOrigin__: 返回性能测量开始时的时间的高精度时间戳\n\n本文主要讨论 Performance 的 timing 对象以及其他几种统计指标。\n#### performance.timing\ntiming 对象提供了各种与浏览器处理相关的时间数据([详细](https://segmentfault.com/a/1190000014479800))，各时间节点可参照下图: \n![](/performance.png)\n\n其中常用的几项计算指标如下：\n````javascript\n    var timing = performance.timing;\n    var times = {};\n\n     // 请求耗时\n    times.request = timing.responseEnd - timing.requestStart || 0;\n\n    // 页面白屏时间\n    times.ttfb = timing.responseStart - timing.navigationStart || 0;\n\n    // 页面可操作时间\n    times.domReady = timing.domComplete - timing.responseEnd || 0;\n\n    //dom渲染时间\n    times.domRender = timing.domContentLoadedEventEnd - timing.navigationStart || 0,\n\n    // 总下载时间\n    times.onload = timing.loadEventEnd - timing.navigationStart || 0;\n\n    // DNS解析时间\n    times.lookupDomain = timing.domainLookupEnd - timing.domainLookupStart || 0;\n\n    // TCP建立时间\n    times.tcp = timing.connectEnd - timing.connectStart || 0,\n\n    // 首屏时间\n    times.now = performance.now();\n````\n### performance.now()\n&emsp;&emsp;返回当前网页从performance.timing.navigationStart到当前时间之间的微秒数\n\n### performance.getEntries()\n&emsp;&emsp;浏览器获取网页时，会对网页中每一个对象（脚本文件、样式表、图片文件等等）发出一个HTTP请求。performance.getEntries方法以数组形式，返回这些请求的时间统计信息，有多少个请求，返回数组就会有多少个成员。\n\n### 数据埋点及上报方式\n\n#### 利用<script\\>标签的 src 属性上报\n&emsp;&emsp;工作中采用的埋点方式是脚本引入。该脚本负责收集浏览器性能指标信息，并生成一个 <script\\> 节点，将指标信息拼接成 url param 的形式，通过 <script\\> 标签的 src 属性发起请求，将数据上报到服务器。\n\n#### 利用<img\\>标签的 src 属性上报\n&emsp;&emsp;谷歌和百度的都是用的1x1 像素的透明 gif 图片，其优点如下：\n* 跨域友好\n* 执行过程无阻塞\n* 使用image时，部分浏览器内页面关闭不会影响数据上报\n* gif 的最低合法体积最小（最小的 bmp 文件需要74个字节，png 需要67个字节，而合法的 gif，只需要43个字节）\n  \n#### 利用 HTML5 Beacon API 进行数据上报\nBeacon API 允许开发者发送少量错误分析和上报的信息，它的特点很明显：\n* 在空闲的时候异步发送统计，不影响页面诸如 JS、CSS Animation 等执行\n* 即使页面在 unload 状态下，也会异步发送统计，不影响页面过渡/跳转到下跳页\n* 能够被客户端优化发送，尤其在 Mobile 环境下，可以将 Beacon 请求合并到其他请求上，一同处理\n\n### 前端性能监控系统\n&emsp;&emsp;在github上发现的比较好的参考工具：\n* 数据上报插件: [web-report-sdk](https://github.com/wangweianger/web-report-sdk)\n* 前端性能监控UI: [web-monitoring](http://hubing.online:8083/#/sys/5cb68708838abf131c718ed1/index)\n\n### 参考资料\n[前端性能监控-window.performance](https://blog.csdn.net/weixin_42284354/article/details/80416157)\n[Performance API-ruanyifeng](http://javascript.ruanyifeng.com/bom/performance.html)\n[初探Performance API](https://segmentfault.com/a/1190000014479800)\n[前端全（无）埋点之页面停留时长统计](https://juejin.im/entry/5a179332f265da431b6ce39c)","source":"_posts/使用 Performance APi 进行前端性能监控.md","raw":"---\ntitle: 使用 Performance APi 进行前端性能监控\ndate: 2019-07-11 18:55:59\ntags: [性能监控]\ncategories: [前端]\n---\n&emsp;&emsp;平常只在测试环境测过前端页面性能，到了真实环境用户的手机上，页面性能的具体表现却未曾了解。H5新增的 Performance API 可以精确的测量网页性能。使开发者可以通过数据上报的方式收集线上H5页面的性能表现，以合理优化页面性能短板，提升用户体验。\n<!--more-->\n\n### 前端性能监控指标\n* __白屏时间__: 从打开网站到有内容渲染出来的时间节点\n* __首屏时间__: 首屏内容渲染完毕的时间节点\n* __domReady 时间__: 用户可操作的时间节点\n* __onload 时间__: 总下载时间\n\n### Performance API 简介\n&emsp;&emsp;[Performace](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance)是 html5的新特性之一，该接口会返回当前页面性能相关的信息。Performance 对象一共提供了4个属性：\n\n* __navigation__: 包含页面加载、刷新、重定向情况\n* __timing__: 包含了各种与浏览器性能有关的时间数据\n* __memory__: 返回JavaScript对内存的占用\n* __timeOrigin__: 返回性能测量开始时的时间的高精度时间戳\n\n本文主要讨论 Performance 的 timing 对象以及其他几种统计指标。\n#### performance.timing\ntiming 对象提供了各种与浏览器处理相关的时间数据([详细](https://segmentfault.com/a/1190000014479800))，各时间节点可参照下图: \n![](/performance.png)\n\n其中常用的几项计算指标如下：\n````javascript\n    var timing = performance.timing;\n    var times = {};\n\n     // 请求耗时\n    times.request = timing.responseEnd - timing.requestStart || 0;\n\n    // 页面白屏时间\n    times.ttfb = timing.responseStart - timing.navigationStart || 0;\n\n    // 页面可操作时间\n    times.domReady = timing.domComplete - timing.responseEnd || 0;\n\n    //dom渲染时间\n    times.domRender = timing.domContentLoadedEventEnd - timing.navigationStart || 0,\n\n    // 总下载时间\n    times.onload = timing.loadEventEnd - timing.navigationStart || 0;\n\n    // DNS解析时间\n    times.lookupDomain = timing.domainLookupEnd - timing.domainLookupStart || 0;\n\n    // TCP建立时间\n    times.tcp = timing.connectEnd - timing.connectStart || 0,\n\n    // 首屏时间\n    times.now = performance.now();\n````\n### performance.now()\n&emsp;&emsp;返回当前网页从performance.timing.navigationStart到当前时间之间的微秒数\n\n### performance.getEntries()\n&emsp;&emsp;浏览器获取网页时，会对网页中每一个对象（脚本文件、样式表、图片文件等等）发出一个HTTP请求。performance.getEntries方法以数组形式，返回这些请求的时间统计信息，有多少个请求，返回数组就会有多少个成员。\n\n### 数据埋点及上报方式\n\n#### 利用<script\\>标签的 src 属性上报\n&emsp;&emsp;工作中采用的埋点方式是脚本引入。该脚本负责收集浏览器性能指标信息，并生成一个 <script\\> 节点，将指标信息拼接成 url param 的形式，通过 <script\\> 标签的 src 属性发起请求，将数据上报到服务器。\n\n#### 利用<img\\>标签的 src 属性上报\n&emsp;&emsp;谷歌和百度的都是用的1x1 像素的透明 gif 图片，其优点如下：\n* 跨域友好\n* 执行过程无阻塞\n* 使用image时，部分浏览器内页面关闭不会影响数据上报\n* gif 的最低合法体积最小（最小的 bmp 文件需要74个字节，png 需要67个字节，而合法的 gif，只需要43个字节）\n  \n#### 利用 HTML5 Beacon API 进行数据上报\nBeacon API 允许开发者发送少量错误分析和上报的信息，它的特点很明显：\n* 在空闲的时候异步发送统计，不影响页面诸如 JS、CSS Animation 等执行\n* 即使页面在 unload 状态下，也会异步发送统计，不影响页面过渡/跳转到下跳页\n* 能够被客户端优化发送，尤其在 Mobile 环境下，可以将 Beacon 请求合并到其他请求上，一同处理\n\n### 前端性能监控系统\n&emsp;&emsp;在github上发现的比较好的参考工具：\n* 数据上报插件: [web-report-sdk](https://github.com/wangweianger/web-report-sdk)\n* 前端性能监控UI: [web-monitoring](http://hubing.online:8083/#/sys/5cb68708838abf131c718ed1/index)\n\n### 参考资料\n[前端性能监控-window.performance](https://blog.csdn.net/weixin_42284354/article/details/80416157)\n[Performance API-ruanyifeng](http://javascript.ruanyifeng.com/bom/performance.html)\n[初探Performance API](https://segmentfault.com/a/1190000014479800)\n[前端全（无）埋点之页面停留时长统计](https://juejin.im/entry/5a179332f265da431b6ce39c)","slug":"使用 Performance APi 进行前端性能监控","published":1,"updated":"2020-11-04T08:29:30.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0z00137vvukrfw569c","content":"<p>&emsp;&emsp;平常只在测试环境测过前端页面性能，到了真实环境用户的手机上，页面性能的具体表现却未曾了解。H5新增的 Performance API 可以精确的测量网页性能。使开发者可以通过数据上报的方式收集线上H5页面的性能表现，以合理优化页面性能短板，提升用户体验。<br><a id=\"more\"></a></p>\n<h3 id=\"前端性能监控指标\"><a href=\"#前端性能监控指标\" class=\"headerlink\" title=\"前端性能监控指标\"></a>前端性能监控指标</h3><ul>\n<li><strong>白屏时间</strong>: 从打开网站到有内容渲染出来的时间节点</li>\n<li><strong>首屏时间</strong>: 首屏内容渲染完毕的时间节点</li>\n<li><strong>domReady 时间</strong>: 用户可操作的时间节点</li>\n<li><strong>onload 时间</strong>: 总下载时间</li>\n</ul>\n<h3 id=\"Performance-API-简介\"><a href=\"#Performance-API-简介\" class=\"headerlink\" title=\"Performance API 简介\"></a>Performance API 简介</h3><p>&emsp;&emsp;<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Performance\" target=\"_blank\" rel=\"noopener\">Performace</a>是 html5的新特性之一，该接口会返回当前页面性能相关的信息。Performance 对象一共提供了4个属性：</p>\n<ul>\n<li><strong>navigation</strong>: 包含页面加载、刷新、重定向情况</li>\n<li><strong>timing</strong>: 包含了各种与浏览器性能有关的时间数据</li>\n<li><strong>memory</strong>: 返回JavaScript对内存的占用</li>\n<li><strong>timeOrigin</strong>: 返回性能测量开始时的时间的高精度时间戳</li>\n</ul>\n<p>本文主要讨论 Performance 的 timing 对象以及其他几种统计指标。</p>\n<h4 id=\"performance-timing\"><a href=\"#performance-timing\" class=\"headerlink\" title=\"performance.timing\"></a>performance.timing</h4><p>timing 对象提供了各种与浏览器处理相关的时间数据(<a href=\"https://segmentfault.com/a/1190000014479800\" target=\"_blank\" rel=\"noopener\">详细</a>)，各时间节点可参照下图:<br><img src=\"/2019/07/11/使用 Performance APi 进行前端性能监控/performance.png\" alt=\"\"></p>\n<p>其中常用的几项计算指标如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> timing = performance.timing;</span><br><span class=\"line\"><span class=\"keyword\">var</span> times = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 请求耗时</span></span><br><span class=\"line\">times.request = timing.responseEnd - timing.requestStart || <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 页面白屏时间</span></span><br><span class=\"line\">times.ttfb = timing.responseStart - timing.navigationStart || <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 页面可操作时间</span></span><br><span class=\"line\">times.domReady = timing.domComplete - timing.responseEnd || <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//dom渲染时间</span></span><br><span class=\"line\">times.domRender = timing.domContentLoadedEventEnd - timing.navigationStart || <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 总下载时间</span></span><br><span class=\"line\">times.onload = timing.loadEventEnd - timing.navigationStart || <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DNS解析时间</span></span><br><span class=\"line\">times.lookupDomain = timing.domainLookupEnd - timing.domainLookupStart || <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TCP建立时间</span></span><br><span class=\"line\">times.tcp = timing.connectEnd - timing.connectStart || <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首屏时间</span></span><br><span class=\"line\">times.now = performance.now();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"performance-now\"><a href=\"#performance-now\" class=\"headerlink\" title=\"performance.now()\"></a>performance.now()</h3><p>&emsp;&emsp;返回当前网页从performance.timing.navigationStart到当前时间之间的微秒数</p>\n<h3 id=\"performance-getEntries\"><a href=\"#performance-getEntries\" class=\"headerlink\" title=\"performance.getEntries()\"></a>performance.getEntries()</h3><p>&emsp;&emsp;浏览器获取网页时，会对网页中每一个对象（脚本文件、样式表、图片文件等等）发出一个HTTP请求。performance.getEntries方法以数组形式，返回这些请求的时间统计信息，有多少个请求，返回数组就会有多少个成员。</p>\n<h3 id=\"数据埋点及上报方式\"><a href=\"#数据埋点及上报方式\" class=\"headerlink\" title=\"数据埋点及上报方式\"></a>数据埋点及上报方式</h3><h4 id=\"利用-lt-script-标签的-src-属性上报\"><a href=\"#利用-lt-script-标签的-src-属性上报\" class=\"headerlink\" title=\"利用&lt;script>标签的 src 属性上报\"></a>利用&lt;script>标签的 src 属性上报</h4><p>&emsp;&emsp;工作中采用的埋点方式是脚本引入。该脚本负责收集浏览器性能指标信息，并生成一个 &lt;script> 节点，将指标信息拼接成 url param 的形式，通过 &lt;script> 标签的 src 属性发起请求，将数据上报到服务器。</p>\n<h4 id=\"利用-lt-img-标签的-src-属性上报\"><a href=\"#利用-lt-img-标签的-src-属性上报\" class=\"headerlink\" title=\"利用&lt;img>标签的 src 属性上报\"></a>利用&lt;img>标签的 src 属性上报</h4><p>&emsp;&emsp;谷歌和百度的都是用的1x1 像素的透明 gif 图片，其优点如下：</p>\n<ul>\n<li>跨域友好</li>\n<li>执行过程无阻塞</li>\n<li>使用image时，部分浏览器内页面关闭不会影响数据上报</li>\n<li>gif 的最低合法体积最小（最小的 bmp 文件需要74个字节，png 需要67个字节，而合法的 gif，只需要43个字节）</li>\n</ul>\n<h4 id=\"利用-HTML5-Beacon-API-进行数据上报\"><a href=\"#利用-HTML5-Beacon-API-进行数据上报\" class=\"headerlink\" title=\"利用 HTML5 Beacon API 进行数据上报\"></a>利用 HTML5 Beacon API 进行数据上报</h4><p>Beacon API 允许开发者发送少量错误分析和上报的信息，它的特点很明显：</p>\n<ul>\n<li>在空闲的时候异步发送统计，不影响页面诸如 JS、CSS Animation 等执行</li>\n<li>即使页面在 unload 状态下，也会异步发送统计，不影响页面过渡/跳转到下跳页</li>\n<li>能够被客户端优化发送，尤其在 Mobile 环境下，可以将 Beacon 请求合并到其他请求上，一同处理</li>\n</ul>\n<h3 id=\"前端性能监控系统\"><a href=\"#前端性能监控系统\" class=\"headerlink\" title=\"前端性能监控系统\"></a>前端性能监控系统</h3><p>&emsp;&emsp;在github上发现的比较好的参考工具：</p>\n<ul>\n<li>数据上报插件: <a href=\"https://github.com/wangweianger/web-report-sdk\" target=\"_blank\" rel=\"noopener\">web-report-sdk</a></li>\n<li>前端性能监控UI: <a href=\"http://hubing.online:8083/#/sys/5cb68708838abf131c718ed1/index\" target=\"_blank\" rel=\"noopener\">web-monitoring</a></li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://blog.csdn.net/weixin_42284354/article/details/80416157\" target=\"_blank\" rel=\"noopener\">前端性能监控-window.performance</a><br><a href=\"http://javascript.ruanyifeng.com/bom/performance.html\" target=\"_blank\" rel=\"noopener\">Performance API-ruanyifeng</a><br><a href=\"https://segmentfault.com/a/1190000014479800\" target=\"_blank\" rel=\"noopener\">初探Performance API</a><br><a href=\"https://juejin.im/entry/5a179332f265da431b6ce39c\" target=\"_blank\" rel=\"noopener\">前端全（无）埋点之页面停留时长统计</a></p>\n","site":{"data":{}},"excerpt":"<p>&emsp;&emsp;平常只在测试环境测过前端页面性能，到了真实环境用户的手机上，页面性能的具体表现却未曾了解。H5新增的 Performance API 可以精确的测量网页性能。使开发者可以通过数据上报的方式收集线上H5页面的性能表现，以合理优化页面性能短板，提升用户体验。<br></p>","more":"<p></p>\n<h3 id=\"前端性能监控指标\"><a href=\"#前端性能监控指标\" class=\"headerlink\" title=\"前端性能监控指标\"></a>前端性能监控指标</h3><ul>\n<li><strong>白屏时间</strong>: 从打开网站到有内容渲染出来的时间节点</li>\n<li><strong>首屏时间</strong>: 首屏内容渲染完毕的时间节点</li>\n<li><strong>domReady 时间</strong>: 用户可操作的时间节点</li>\n<li><strong>onload 时间</strong>: 总下载时间</li>\n</ul>\n<h3 id=\"Performance-API-简介\"><a href=\"#Performance-API-简介\" class=\"headerlink\" title=\"Performance API 简介\"></a>Performance API 简介</h3><p>&emsp;&emsp;<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Performance\" target=\"_blank\" rel=\"noopener\">Performace</a>是 html5的新特性之一，该接口会返回当前页面性能相关的信息。Performance 对象一共提供了4个属性：</p>\n<ul>\n<li><strong>navigation</strong>: 包含页面加载、刷新、重定向情况</li>\n<li><strong>timing</strong>: 包含了各种与浏览器性能有关的时间数据</li>\n<li><strong>memory</strong>: 返回JavaScript对内存的占用</li>\n<li><strong>timeOrigin</strong>: 返回性能测量开始时的时间的高精度时间戳</li>\n</ul>\n<p>本文主要讨论 Performance 的 timing 对象以及其他几种统计指标。</p>\n<h4 id=\"performance-timing\"><a href=\"#performance-timing\" class=\"headerlink\" title=\"performance.timing\"></a>performance.timing</h4><p>timing 对象提供了各种与浏览器处理相关的时间数据(<a href=\"https://segmentfault.com/a/1190000014479800\" target=\"_blank\" rel=\"noopener\">详细</a>)，各时间节点可参照下图:<br><img src=\"/2019/07/11/使用 Performance APi 进行前端性能监控/performance.png\" alt=\"\"></p>\n<p>其中常用的几项计算指标如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> timing = performance.timing;</span><br><span class=\"line\"><span class=\"keyword\">var</span> times = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 请求耗时</span></span><br><span class=\"line\">times.request = timing.responseEnd - timing.requestStart || <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 页面白屏时间</span></span><br><span class=\"line\">times.ttfb = timing.responseStart - timing.navigationStart || <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 页面可操作时间</span></span><br><span class=\"line\">times.domReady = timing.domComplete - timing.responseEnd || <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//dom渲染时间</span></span><br><span class=\"line\">times.domRender = timing.domContentLoadedEventEnd - timing.navigationStart || <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 总下载时间</span></span><br><span class=\"line\">times.onload = timing.loadEventEnd - timing.navigationStart || <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DNS解析时间</span></span><br><span class=\"line\">times.lookupDomain = timing.domainLookupEnd - timing.domainLookupStart || <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// TCP建立时间</span></span><br><span class=\"line\">times.tcp = timing.connectEnd - timing.connectStart || <span class=\"number\">0</span>,</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首屏时间</span></span><br><span class=\"line\">times.now = performance.now();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"performance-now\"><a href=\"#performance-now\" class=\"headerlink\" title=\"performance.now()\"></a>performance.now()</h3><p>&emsp;&emsp;返回当前网页从performance.timing.navigationStart到当前时间之间的微秒数</p>\n<h3 id=\"performance-getEntries\"><a href=\"#performance-getEntries\" class=\"headerlink\" title=\"performance.getEntries()\"></a>performance.getEntries()</h3><p>&emsp;&emsp;浏览器获取网页时，会对网页中每一个对象（脚本文件、样式表、图片文件等等）发出一个HTTP请求。performance.getEntries方法以数组形式，返回这些请求的时间统计信息，有多少个请求，返回数组就会有多少个成员。</p>\n<h3 id=\"数据埋点及上报方式\"><a href=\"#数据埋点及上报方式\" class=\"headerlink\" title=\"数据埋点及上报方式\"></a>数据埋点及上报方式</h3><h4 id=\"利用-lt-script-标签的-src-属性上报\"><a href=\"#利用-lt-script-标签的-src-属性上报\" class=\"headerlink\" title=\"利用&lt;script>标签的 src 属性上报\"></a>利用&lt;script>标签的 src 属性上报</h4><p>&emsp;&emsp;工作中采用的埋点方式是脚本引入。该脚本负责收集浏览器性能指标信息，并生成一个 &lt;script> 节点，将指标信息拼接成 url param 的形式，通过 &lt;script> 标签的 src 属性发起请求，将数据上报到服务器。</p>\n<h4 id=\"利用-lt-img-标签的-src-属性上报\"><a href=\"#利用-lt-img-标签的-src-属性上报\" class=\"headerlink\" title=\"利用&lt;img>标签的 src 属性上报\"></a>利用&lt;img>标签的 src 属性上报</h4><p>&emsp;&emsp;谷歌和百度的都是用的1x1 像素的透明 gif 图片，其优点如下：</p>\n<ul>\n<li>跨域友好</li>\n<li>执行过程无阻塞</li>\n<li>使用image时，部分浏览器内页面关闭不会影响数据上报</li>\n<li>gif 的最低合法体积最小（最小的 bmp 文件需要74个字节，png 需要67个字节，而合法的 gif，只需要43个字节）</li>\n</ul>\n<h4 id=\"利用-HTML5-Beacon-API-进行数据上报\"><a href=\"#利用-HTML5-Beacon-API-进行数据上报\" class=\"headerlink\" title=\"利用 HTML5 Beacon API 进行数据上报\"></a>利用 HTML5 Beacon API 进行数据上报</h4><p>Beacon API 允许开发者发送少量错误分析和上报的信息，它的特点很明显：</p>\n<ul>\n<li>在空闲的时候异步发送统计，不影响页面诸如 JS、CSS Animation 等执行</li>\n<li>即使页面在 unload 状态下，也会异步发送统计，不影响页面过渡/跳转到下跳页</li>\n<li>能够被客户端优化发送，尤其在 Mobile 环境下，可以将 Beacon 请求合并到其他请求上，一同处理</li>\n</ul>\n<h3 id=\"前端性能监控系统\"><a href=\"#前端性能监控系统\" class=\"headerlink\" title=\"前端性能监控系统\"></a>前端性能监控系统</h3><p>&emsp;&emsp;在github上发现的比较好的参考工具：</p>\n<ul>\n<li>数据上报插件: <a href=\"https://github.com/wangweianger/web-report-sdk\" target=\"_blank\" rel=\"noopener\">web-report-sdk</a></li>\n<li>前端性能监控UI: <a href=\"http://hubing.online:8083/#/sys/5cb68708838abf131c718ed1/index\" target=\"_blank\" rel=\"noopener\">web-monitoring</a></li>\n</ul>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://blog.csdn.net/weixin_42284354/article/details/80416157\" target=\"_blank\" rel=\"noopener\">前端性能监控-window.performance</a><br><a href=\"http://javascript.ruanyifeng.com/bom/performance.html\" target=\"_blank\" rel=\"noopener\">Performance API-ruanyifeng</a><br><a href=\"https://segmentfault.com/a/1190000014479800\" target=\"_blank\" rel=\"noopener\">初探Performance API</a><br><a href=\"https://juejin.im/entry/5a179332f265da431b6ce39c\" target=\"_blank\" rel=\"noopener\">前端全（无）埋点之页面停留时长统计</a></p>"},{"title":"前端模块化","date":"2019-01-03T03:19:05.000Z","_content":"目前JS模块化规范主要三种：浏览器端的 __AMD__、__CMD__ 规范和nodeJS端的 __CommonJS__ 规范。经常被 exports、modules.exports、export、require 绕懵，遂来探一探究竟。\n\n#### AMD规范 (requireJS) 浏览器端 异步加载模块 提前执行\nAMD (Asynchronous Module Definition): 在浏览器中使用，并用 `define` 函数定义模块，用`require`引入模块；\n它是 RequireJS 在推广过程中对模块定义的规范化产出，诣在帮开发者解决各个 js 文件的依赖问题，让开发者在页面引入多个 js 时，不必考虑各个 js 的依赖关系。\n\n#### CMD规范 (SeaJS) 浏览器端 异步加载模块 延迟执行\nCMD (Common Module Definition): 在浏览器端使用，使用 `define` 函数定义模块，用 `module.exports` 暴露模块；\n它 是SeaJS 在推广过程中对模块定义的规范化产出。与 AMD 也都是异步加载模块，只是依赖加载的时间点不一样。相比于 AMD 依赖前置，CDM 加载采用就近原则（个人理解：先依赖，先加载）。\n````javascript\ndefine(function(require, exports, module) {\n  let val = 'module4'\n  function getVal() {\n  \tconsole.log(val)\n  }\n\n  // 引入module2 同步\n  let module2 = require('./module2.js');\n  module2()\n\n  // 异步引入module3\n  require.async('./module3.js', function(module3) {\n  \tmodule3.module3.getData()\n  });\n\n  // 暴露模块\n  module.exports = {getVal}\n})\n````\n\n#### CommonJS 服务端 同步加载模块 \nNodeJS 的模块机制使用的就是 commonJS 的规范，因为服务端第三方库大多已存于本地，加载速度较快，使用同步加载比较理想。它使用 `module.exports` 或者是 `exports` 来导出，使用 `require` 引入。\n\n#### ES6 的 export 和 import 浏览器端\nESM (ES Modules) 是 JavaScript 从 ES6(ES2015) 开始支持的原生模块机制，使用`import`和`export`引入和导出模块。\n\n#### UMD 通用模块机制 \nUMD (Universal Module Definition) 是一个通用模块的机制，它使一个模块能运行在各种环境下，不论是 CommonJS、AMD，还是非模块化的环境。代码实现原理如下：\n````javascript\n    if (typeof define === 'function') { // 兼容 requireJS AMD、CMD规范   \n        define(function () {\n            return moduleName;\n        });\n    } else if (typeof exports !== 'undefined') { // 兼容 webpack 引入方式(commonJS) \n        module.exports = moduleName; \n    } else {\n        this.moduleName = moduleName; // 普通引入，注册到全局\n    }\n````\n\n常见于打包/编译工具中：\n````javascript\nfunction webpackConfig(BASE_PATH) {\n  return {\n    mode: 'development',\n    entry: {\n      index: path.join(__dirname, '../src/index'),\n      preview: path.join(__dirname, '../src/view')\n    },\n    output: {\n      libraryTarget: 'umd'\n    },\n    ...\n  }\n}\n````\n\n\n#### 参考资料\n[前端模块化详解(完整版)](https://github.com/ljianshu/Blog/issues/48)\n[关于commonjs，AMD，CMD之间的异同](https://www.cnblogs.com/omelette/p/6652472.html)","source":"_posts/前端模块化.md","raw":"---\ntitle: 前端模块化\ndate: 2019-01-03 11:19:05\ntags: [JavaScript]\ncategories: [前端, JavaScript]\n---\n目前JS模块化规范主要三种：浏览器端的 __AMD__、__CMD__ 规范和nodeJS端的 __CommonJS__ 规范。经常被 exports、modules.exports、export、require 绕懵，遂来探一探究竟。\n\n#### AMD规范 (requireJS) 浏览器端 异步加载模块 提前执行\nAMD (Asynchronous Module Definition): 在浏览器中使用，并用 `define` 函数定义模块，用`require`引入模块；\n它是 RequireJS 在推广过程中对模块定义的规范化产出，诣在帮开发者解决各个 js 文件的依赖问题，让开发者在页面引入多个 js 时，不必考虑各个 js 的依赖关系。\n\n#### CMD规范 (SeaJS) 浏览器端 异步加载模块 延迟执行\nCMD (Common Module Definition): 在浏览器端使用，使用 `define` 函数定义模块，用 `module.exports` 暴露模块；\n它 是SeaJS 在推广过程中对模块定义的规范化产出。与 AMD 也都是异步加载模块，只是依赖加载的时间点不一样。相比于 AMD 依赖前置，CDM 加载采用就近原则（个人理解：先依赖，先加载）。\n````javascript\ndefine(function(require, exports, module) {\n  let val = 'module4'\n  function getVal() {\n  \tconsole.log(val)\n  }\n\n  // 引入module2 同步\n  let module2 = require('./module2.js');\n  module2()\n\n  // 异步引入module3\n  require.async('./module3.js', function(module3) {\n  \tmodule3.module3.getData()\n  });\n\n  // 暴露模块\n  module.exports = {getVal}\n})\n````\n\n#### CommonJS 服务端 同步加载模块 \nNodeJS 的模块机制使用的就是 commonJS 的规范，因为服务端第三方库大多已存于本地，加载速度较快，使用同步加载比较理想。它使用 `module.exports` 或者是 `exports` 来导出，使用 `require` 引入。\n\n#### ES6 的 export 和 import 浏览器端\nESM (ES Modules) 是 JavaScript 从 ES6(ES2015) 开始支持的原生模块机制，使用`import`和`export`引入和导出模块。\n\n#### UMD 通用模块机制 \nUMD (Universal Module Definition) 是一个通用模块的机制，它使一个模块能运行在各种环境下，不论是 CommonJS、AMD，还是非模块化的环境。代码实现原理如下：\n````javascript\n    if (typeof define === 'function') { // 兼容 requireJS AMD、CMD规范   \n        define(function () {\n            return moduleName;\n        });\n    } else if (typeof exports !== 'undefined') { // 兼容 webpack 引入方式(commonJS) \n        module.exports = moduleName; \n    } else {\n        this.moduleName = moduleName; // 普通引入，注册到全局\n    }\n````\n\n常见于打包/编译工具中：\n````javascript\nfunction webpackConfig(BASE_PATH) {\n  return {\n    mode: 'development',\n    entry: {\n      index: path.join(__dirname, '../src/index'),\n      preview: path.join(__dirname, '../src/view')\n    },\n    output: {\n      libraryTarget: 'umd'\n    },\n    ...\n  }\n}\n````\n\n\n#### 参考资料\n[前端模块化详解(完整版)](https://github.com/ljianshu/Blog/issues/48)\n[关于commonjs，AMD，CMD之间的异同](https://www.cnblogs.com/omelette/p/6652472.html)","slug":"前端模块化","published":1,"updated":"2020-12-11T06:17:41.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo0z00157vvubfjuoi34","content":"<p>目前JS模块化规范主要三种：浏览器端的 <strong>AMD</strong>、<strong>CMD</strong> 规范和nodeJS端的 <strong>CommonJS</strong> 规范。经常被 exports、modules.exports、export、require 绕懵，遂来探一探究竟。</p>\n<h4 id=\"AMD规范-requireJS-浏览器端-异步加载模块-提前执行\"><a href=\"#AMD规范-requireJS-浏览器端-异步加载模块-提前执行\" class=\"headerlink\" title=\"AMD规范 (requireJS) 浏览器端 异步加载模块 提前执行\"></a>AMD规范 (requireJS) 浏览器端 异步加载模块 提前执行</h4><p>AMD (Asynchronous Module Definition): 在浏览器中使用，并用 <code>define</code> 函数定义模块，用<code>require</code>引入模块；<br>它是 RequireJS 在推广过程中对模块定义的规范化产出，诣在帮开发者解决各个 js 文件的依赖问题，让开发者在页面引入多个 js 时，不必考虑各个 js 的依赖关系。</p>\n<h4 id=\"CMD规范-SeaJS-浏览器端-异步加载模块-延迟执行\"><a href=\"#CMD规范-SeaJS-浏览器端-异步加载模块-延迟执行\" class=\"headerlink\" title=\"CMD规范 (SeaJS) 浏览器端 异步加载模块 延迟执行\"></a>CMD规范 (SeaJS) 浏览器端 异步加载模块 延迟执行</h4><p>CMD (Common Module Definition): 在浏览器端使用，使用 <code>define</code> 函数定义模块，用 <code>module.exports</code> 暴露模块；<br>它 是SeaJS 在推广过程中对模块定义的规范化产出。与 AMD 也都是异步加载模块，只是依赖加载的时间点不一样。相比于 AMD 依赖前置，CDM 加载采用就近原则（个人理解：先依赖，先加载）。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> val = <span class=\"string\">'module4'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getVal</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">console</span>.log(val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 引入module2 同步</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> module2 = <span class=\"built_in\">require</span>(<span class=\"string\">'./module2.js'</span>);</span><br><span class=\"line\">  module2()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 异步引入module3</span></span><br><span class=\"line\">  <span class=\"built_in\">require</span>.async(<span class=\"string\">'./module3.js'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module3</span>) </span>&#123;</span><br><span class=\"line\">  \tmodule3.module3.getData()</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 暴露模块</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = &#123;getVal&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"CommonJS-服务端-同步加载模块\"><a href=\"#CommonJS-服务端-同步加载模块\" class=\"headerlink\" title=\"CommonJS 服务端 同步加载模块\"></a>CommonJS 服务端 同步加载模块</h4><p>NodeJS 的模块机制使用的就是 commonJS 的规范，因为服务端第三方库大多已存于本地，加载速度较快，使用同步加载比较理想。它使用 <code>module.exports</code> 或者是 <code>exports</code> 来导出，使用 <code>require</code> 引入。</p>\n<h4 id=\"ES6-的-export-和-import-浏览器端\"><a href=\"#ES6-的-export-和-import-浏览器端\" class=\"headerlink\" title=\"ES6 的 export 和 import 浏览器端\"></a>ES6 的 export 和 import 浏览器端</h4><p>ESM (ES Modules) 是 JavaScript 从 ES6(ES2015) 开始支持的原生模块机制，使用<code>import</code>和<code>export</code>引入和导出模块。</p>\n<h4 id=\"UMD-通用模块机制\"><a href=\"#UMD-通用模块机制\" class=\"headerlink\" title=\"UMD 通用模块机制\"></a>UMD 通用模块机制</h4><p>UMD (Universal Module Definition) 是一个通用模块的机制，它使一个模块能运行在各种环境下，不论是 CommonJS、AMD，还是非模块化的环境。代码实现原理如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">'function'</span>) &#123; <span class=\"comment\">// 兼容 requireJS AMD、CMD规范   </span></span><br><span class=\"line\">    define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> moduleName;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> exports !== <span class=\"string\">'undefined'</span>) &#123; <span class=\"comment\">// 兼容 webpack 引入方式(commonJS) </span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = moduleName; </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.moduleName = moduleName; <span class=\"comment\">// 普通引入，注册到全局</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>常见于打包/编译工具中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">webpackConfig</span>(<span class=\"params\">BASE_PATH</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    mode: <span class=\"string\">'development'</span>,</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">      index: path.join(__dirname, <span class=\"string\">'../src/index'</span>),</span><br><span class=\"line\">      preview: path.join(__dirname, <span class=\"string\">'../src/view'</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">      libraryTarget: <span class=\"string\">'umd'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://github.com/ljianshu/Blog/issues/48\" target=\"_blank\" rel=\"noopener\">前端模块化详解(完整版)</a><br><a href=\"https://www.cnblogs.com/omelette/p/6652472.html\" target=\"_blank\" rel=\"noopener\">关于commonjs，AMD，CMD之间的异同</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>目前JS模块化规范主要三种：浏览器端的 <strong>AMD</strong>、<strong>CMD</strong> 规范和nodeJS端的 <strong>CommonJS</strong> 规范。经常被 exports、modules.exports、export、require 绕懵，遂来探一探究竟。</p>\n<h4 id=\"AMD规范-requireJS-浏览器端-异步加载模块-提前执行\"><a href=\"#AMD规范-requireJS-浏览器端-异步加载模块-提前执行\" class=\"headerlink\" title=\"AMD规范 (requireJS) 浏览器端 异步加载模块 提前执行\"></a>AMD规范 (requireJS) 浏览器端 异步加载模块 提前执行</h4><p>AMD (Asynchronous Module Definition): 在浏览器中使用，并用 <code>define</code> 函数定义模块，用<code>require</code>引入模块；<br>它是 RequireJS 在推广过程中对模块定义的规范化产出，诣在帮开发者解决各个 js 文件的依赖问题，让开发者在页面引入多个 js 时，不必考虑各个 js 的依赖关系。</p>\n<h4 id=\"CMD规范-SeaJS-浏览器端-异步加载模块-延迟执行\"><a href=\"#CMD规范-SeaJS-浏览器端-异步加载模块-延迟执行\" class=\"headerlink\" title=\"CMD规范 (SeaJS) 浏览器端 异步加载模块 延迟执行\"></a>CMD规范 (SeaJS) 浏览器端 异步加载模块 延迟执行</h4><p>CMD (Common Module Definition): 在浏览器端使用，使用 <code>define</code> 函数定义模块，用 <code>module.exports</code> 暴露模块；<br>它 是SeaJS 在推广过程中对模块定义的规范化产出。与 AMD 也都是异步加载模块，只是依赖加载的时间点不一样。相比于 AMD 依赖前置，CDM 加载采用就近原则（个人理解：先依赖，先加载）。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> val = <span class=\"string\">'module4'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getVal</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"built_in\">console</span>.log(val)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 引入module2 同步</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> module2 = <span class=\"built_in\">require</span>(<span class=\"string\">'./module2.js'</span>);</span><br><span class=\"line\">  module2()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 异步引入module3</span></span><br><span class=\"line\">  <span class=\"built_in\">require</span>.async(<span class=\"string\">'./module3.js'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module3</span>) </span>&#123;</span><br><span class=\"line\">  \tmodule3.module3.getData()</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 暴露模块</span></span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = &#123;getVal&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"CommonJS-服务端-同步加载模块\"><a href=\"#CommonJS-服务端-同步加载模块\" class=\"headerlink\" title=\"CommonJS 服务端 同步加载模块\"></a>CommonJS 服务端 同步加载模块</h4><p>NodeJS 的模块机制使用的就是 commonJS 的规范，因为服务端第三方库大多已存于本地，加载速度较快，使用同步加载比较理想。它使用 <code>module.exports</code> 或者是 <code>exports</code> 来导出，使用 <code>require</code> 引入。</p>\n<h4 id=\"ES6-的-export-和-import-浏览器端\"><a href=\"#ES6-的-export-和-import-浏览器端\" class=\"headerlink\" title=\"ES6 的 export 和 import 浏览器端\"></a>ES6 的 export 和 import 浏览器端</h4><p>ESM (ES Modules) 是 JavaScript 从 ES6(ES2015) 开始支持的原生模块机制，使用<code>import</code>和<code>export</code>引入和导出模块。</p>\n<h4 id=\"UMD-通用模块机制\"><a href=\"#UMD-通用模块机制\" class=\"headerlink\" title=\"UMD 通用模块机制\"></a>UMD 通用模块机制</h4><p>UMD (Universal Module Definition) 是一个通用模块的机制，它使一个模块能运行在各种环境下，不论是 CommonJS、AMD，还是非模块化的环境。代码实现原理如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">'function'</span>) &#123; <span class=\"comment\">// 兼容 requireJS AMD、CMD规范   </span></span><br><span class=\"line\">    define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> moduleName;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> exports !== <span class=\"string\">'undefined'</span>) &#123; <span class=\"comment\">// 兼容 webpack 引入方式(commonJS) </span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = moduleName; </span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.moduleName = moduleName; <span class=\"comment\">// 普通引入，注册到全局</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>常见于打包/编译工具中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">webpackConfig</span>(<span class=\"params\">BASE_PATH</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    mode: <span class=\"string\">'development'</span>,</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">      index: path.join(__dirname, <span class=\"string\">'../src/index'</span>),</span><br><span class=\"line\">      preview: path.join(__dirname, <span class=\"string\">'../src/view'</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">      libraryTarget: <span class=\"string\">'umd'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://github.com/ljianshu/Blog/issues/48\" target=\"_blank\" rel=\"noopener\">前端模块化详解(完整版)</a><br><a href=\"https://www.cnblogs.com/omelette/p/6652472.html\" target=\"_blank\" rel=\"noopener\">关于commonjs，AMD，CMD之间的异同</a></p>\n"},{"title":"同时使用两个账号分别操作Github和Gitlab","date":"2018-11-17T06:06:50.000Z","_content":"公司用 gitlab 存管代码，自己用 github 。懒得下班后用自己电脑提交到 github ，故学习一下如何在同一台电脑上使用两个 git 账号。在 SSH config 中为不同的域名指定不同的 SSH key，之后再将自己本地的 github 库的 git config -- local 设置成自己的 github 账号。\n<!--more-->\n### 一、生成SSH秘钥\n分别对githubn和gitlab生成对应的密钥\n* 用`ssh-keygen -t rsa -C \"公司邮箱地址\"`生成对应的gitlab密钥：id_rsa和id_rsa.pub\n* 将 gitlab 公钥(id_rsa.pub)中的内容配置到公司的gitlab上\n* 用`ssh-keygen -t rsa -C \"自己邮箱地址\" -f ~/.ssh/github_rsa`生成对应的github密钥：github_rsa 和 github_rsa.pub\n* 生成公私钥的过程中，会提示你输入`passphrase`，用作每次进行 ssh 连接时的确认密码。由于电脑和账号都是个人使用所以直接按回车设置为空就可以了\n![设置 passphrase](/enter-passphrase.png)\n* 将 github 公钥(github_rsa.pub)中的内容配置到自己的github上\n* 到目前为止本地 ~/.ssh 中已经存在 github_rsa、github_rsa.pub、id_rsa、id_rsa.pub 四个文件了，由于 github 和 gitlab 建立连接默认查找的都是~/.ssh/id_rsa，所以需要为 github 手动指明使用的私钥名称 github_rsa，否则会报错 <span style=\"color: #c7254e; background: #f2f2f2\"> Permission denied (publickey) </span>\n* 进入密钥生成的位置，创建一个 config 文件，添加配置：\n````\n    # githab\n    Host github.com\n        HostName github.com\n        User kuro-p\n        IdentityFile ~/.ssh/github_rsa\n````\n* 如果为 github 中配置了两个 ssh，那么在 config 中，谁在前谁生效\n### 二、测试连接\n运行`ssh -T git@hostName`命令测试 ssh key 对 gitlab 与 github的连接\n![测试连接是否正常](/test-ssh-connect.png)\n如果能看到一些 Welcome 信息，说明是 OK 的。\n### 三、配置 git 库账号\n为了使 github / gitlab 知道提交的用户是谁，需要对账户名进行配置。由于全局配置是公司的账号，所以只需要对自己想要进行操作的 github 库进行本地配置即可。\n````\n    git config --local user.name 'username' # github账号名称\n    git config --local user.email 'username@gmail.com' # github账号邮箱\n````\n或者直接 init 一个 git 库，配置后 github 的代码都在这个仓库下拉取。\n\n### 参考资料\n[如何在同一台电脑上使用github和gitlab](https://segmentfault.com/a/1190000014626841?utm_source=channel-hottest)\n[同时使用两个账号分别操作Github和Gitlab](https://blog.csdn.net/mycafe_/article/details/79231599)\n[由于SSH配置文件的不匹配，导致的Permission denied (publickey)及其解决方法](http://www.cnblogs.com/lpdi/p/6816380.html)","source":"_posts/同时使用两个账号分别操作Github和Gitlab.md","raw":"---\ntitle: 同时使用两个账号分别操作Github和Gitlab\ndate: 2018-11-17 14:06:50\ntags: [git]\ncategories: git\n---\n公司用 gitlab 存管代码，自己用 github 。懒得下班后用自己电脑提交到 github ，故学习一下如何在同一台电脑上使用两个 git 账号。在 SSH config 中为不同的域名指定不同的 SSH key，之后再将自己本地的 github 库的 git config -- local 设置成自己的 github 账号。\n<!--more-->\n### 一、生成SSH秘钥\n分别对githubn和gitlab生成对应的密钥\n* 用`ssh-keygen -t rsa -C \"公司邮箱地址\"`生成对应的gitlab密钥：id_rsa和id_rsa.pub\n* 将 gitlab 公钥(id_rsa.pub)中的内容配置到公司的gitlab上\n* 用`ssh-keygen -t rsa -C \"自己邮箱地址\" -f ~/.ssh/github_rsa`生成对应的github密钥：github_rsa 和 github_rsa.pub\n* 生成公私钥的过程中，会提示你输入`passphrase`，用作每次进行 ssh 连接时的确认密码。由于电脑和账号都是个人使用所以直接按回车设置为空就可以了\n![设置 passphrase](/enter-passphrase.png)\n* 将 github 公钥(github_rsa.pub)中的内容配置到自己的github上\n* 到目前为止本地 ~/.ssh 中已经存在 github_rsa、github_rsa.pub、id_rsa、id_rsa.pub 四个文件了，由于 github 和 gitlab 建立连接默认查找的都是~/.ssh/id_rsa，所以需要为 github 手动指明使用的私钥名称 github_rsa，否则会报错 <span style=\"color: #c7254e; background: #f2f2f2\"> Permission denied (publickey) </span>\n* 进入密钥生成的位置，创建一个 config 文件，添加配置：\n````\n    # githab\n    Host github.com\n        HostName github.com\n        User kuro-p\n        IdentityFile ~/.ssh/github_rsa\n````\n* 如果为 github 中配置了两个 ssh，那么在 config 中，谁在前谁生效\n### 二、测试连接\n运行`ssh -T git@hostName`命令测试 ssh key 对 gitlab 与 github的连接\n![测试连接是否正常](/test-ssh-connect.png)\n如果能看到一些 Welcome 信息，说明是 OK 的。\n### 三、配置 git 库账号\n为了使 github / gitlab 知道提交的用户是谁，需要对账户名进行配置。由于全局配置是公司的账号，所以只需要对自己想要进行操作的 github 库进行本地配置即可。\n````\n    git config --local user.name 'username' # github账号名称\n    git config --local user.email 'username@gmail.com' # github账号邮箱\n````\n或者直接 init 一个 git 库，配置后 github 的代码都在这个仓库下拉取。\n\n### 参考资料\n[如何在同一台电脑上使用github和gitlab](https://segmentfault.com/a/1190000014626841?utm_source=channel-hottest)\n[同时使用两个账号分别操作Github和Gitlab](https://blog.csdn.net/mycafe_/article/details/79231599)\n[由于SSH配置文件的不匹配，导致的Permission denied (publickey)及其解决方法](http://www.cnblogs.com/lpdi/p/6816380.html)","slug":"同时使用两个账号分别操作Github和Gitlab","published":1,"updated":"2020-11-04T08:29:30.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo10001a7vvuy0kowhyq","content":"<p>公司用 gitlab 存管代码，自己用 github 。懒得下班后用自己电脑提交到 github ，故学习一下如何在同一台电脑上使用两个 git 账号。在 SSH config 中为不同的域名指定不同的 SSH key，之后再将自己本地的 github 库的 git config – local 设置成自己的 github 账号。<br><a id=\"more\"></a></p>\n<h3 id=\"一、生成SSH秘钥\"><a href=\"#一、生成SSH秘钥\" class=\"headerlink\" title=\"一、生成SSH秘钥\"></a>一、生成SSH秘钥</h3><p>分别对githubn和gitlab生成对应的密钥</p>\n<ul>\n<li>用<code>ssh-keygen -t rsa -C &quot;公司邮箱地址&quot;</code>生成对应的gitlab密钥：id_rsa和id_rsa.pub</li>\n<li>将 gitlab 公钥(id_rsa.pub)中的内容配置到公司的gitlab上</li>\n<li>用<code>ssh-keygen -t rsa -C &quot;自己邮箱地址&quot; -f ~/.ssh/github_rsa</code>生成对应的github密钥：github_rsa 和 github_rsa.pub</li>\n<li>生成公私钥的过程中，会提示你输入<code>passphrase</code>，用作每次进行 ssh 连接时的确认密码。由于电脑和账号都是个人使用所以直接按回车设置为空就可以了<br><img src=\"/2018/11/17/同时使用两个账号分别操作Github和Gitlab/enter-passphrase.png\" alt=\"设置 passphrase\"></li>\n<li>将 github 公钥(github_rsa.pub)中的内容配置到自己的github上</li>\n<li>到目前为止本地 ~/.ssh 中已经存在 github_rsa、github_rsa.pub、id_rsa、id_rsa.pub 四个文件了，由于 github 和 gitlab 建立连接默认查找的都是~/.ssh/id_rsa，所以需要为 github 手动指明使用的私钥名称 github_rsa，否则会报错 <span style=\"color: #c7254e; background: #f2f2f2\"> Permission denied (publickey) </span></li>\n<li><p>进入密钥生成的位置，创建一个 config 文件，添加配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># githab</span><br><span class=\"line\">Host github.com</span><br><span class=\"line\">    HostName github.com</span><br><span class=\"line\">    User kuro-p</span><br><span class=\"line\">    IdentityFile ~/.ssh/github_rsa</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果为 github 中配置了两个 ssh，那么在 config 中，谁在前谁生效</p>\n<h3 id=\"二、测试连接\"><a href=\"#二、测试连接\" class=\"headerlink\" title=\"二、测试连接\"></a>二、测试连接</h3><p>运行<code>ssh -T git@hostName</code>命令测试 ssh key 对 gitlab 与 github的连接<br><img src=\"/2018/11/17/同时使用两个账号分别操作Github和Gitlab/test-ssh-connect.png\" alt=\"测试连接是否正常\"><br>如果能看到一些 Welcome 信息，说明是 OK 的。</p>\n<h3 id=\"三、配置-git-库账号\"><a href=\"#三、配置-git-库账号\" class=\"headerlink\" title=\"三、配置 git 库账号\"></a>三、配置 git 库账号</h3><p>为了使 github / gitlab 知道提交的用户是谁，需要对账户名进行配置。由于全局配置是公司的账号，所以只需要对自己想要进行操作的 github 库进行本地配置即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --local user.name &apos;username&apos; # github账号名称</span><br><span class=\"line\">git config --local user.email &apos;username@gmail.com&apos; # github账号邮箱</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>或者直接 init 一个 git 库，配置后 github 的代码都在这个仓库下拉取。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://segmentfault.com/a/1190000014626841?utm_source=channel-hottest\" target=\"_blank\" rel=\"noopener\">如何在同一台电脑上使用github和gitlab</a><br><a href=\"https://blog.csdn.net/mycafe_/article/details/79231599\" target=\"_blank\" rel=\"noopener\">同时使用两个账号分别操作Github和Gitlab</a><br><a href=\"http://www.cnblogs.com/lpdi/p/6816380.html\" target=\"_blank\" rel=\"noopener\">由于SSH配置文件的不匹配，导致的Permission denied (publickey)及其解决方法</a></p>\n","site":{"data":{}},"excerpt":"<p>公司用 gitlab 存管代码，自己用 github 。懒得下班后用自己电脑提交到 github ，故学习一下如何在同一台电脑上使用两个 git 账号。在 SSH config 中为不同的域名指定不同的 SSH key，之后再将自己本地的 github 库的 git config – local 设置成自己的 github 账号。<br></p>","more":"<p></p>\n<h3 id=\"一、生成SSH秘钥\"><a href=\"#一、生成SSH秘钥\" class=\"headerlink\" title=\"一、生成SSH秘钥\"></a>一、生成SSH秘钥</h3><p>分别对githubn和gitlab生成对应的密钥</p>\n<ul>\n<li>用<code>ssh-keygen -t rsa -C &quot;公司邮箱地址&quot;</code>生成对应的gitlab密钥：id_rsa和id_rsa.pub</li>\n<li>将 gitlab 公钥(id_rsa.pub)中的内容配置到公司的gitlab上</li>\n<li>用<code>ssh-keygen -t rsa -C &quot;自己邮箱地址&quot; -f ~/.ssh/github_rsa</code>生成对应的github密钥：github_rsa 和 github_rsa.pub</li>\n<li>生成公私钥的过程中，会提示你输入<code>passphrase</code>，用作每次进行 ssh 连接时的确认密码。由于电脑和账号都是个人使用所以直接按回车设置为空就可以了<br><img src=\"/2018/11/17/同时使用两个账号分别操作Github和Gitlab/enter-passphrase.png\" alt=\"设置 passphrase\"></li>\n<li>将 github 公钥(github_rsa.pub)中的内容配置到自己的github上</li>\n<li>到目前为止本地 ~/.ssh 中已经存在 github_rsa、github_rsa.pub、id_rsa、id_rsa.pub 四个文件了，由于 github 和 gitlab 建立连接默认查找的都是~/.ssh/id_rsa，所以需要为 github 手动指明使用的私钥名称 github_rsa，否则会报错 <span style=\"color: #c7254e; background: #f2f2f2\"> Permission denied (publickey) </span></li>\n<li><p>进入密钥生成的位置，创建一个 config 文件，添加配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># githab</span><br><span class=\"line\">Host github.com</span><br><span class=\"line\">    HostName github.com</span><br><span class=\"line\">    User kuro-p</span><br><span class=\"line\">    IdentityFile ~/.ssh/github_rsa</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果为 github 中配置了两个 ssh，那么在 config 中，谁在前谁生效</p>\n<h3 id=\"二、测试连接\"><a href=\"#二、测试连接\" class=\"headerlink\" title=\"二、测试连接\"></a>二、测试连接</h3><p>运行<code>ssh -T git@hostName</code>命令测试 ssh key 对 gitlab 与 github的连接<br><img src=\"/2018/11/17/同时使用两个账号分别操作Github和Gitlab/test-ssh-connect.png\" alt=\"测试连接是否正常\"><br>如果能看到一些 Welcome 信息，说明是 OK 的。</p>\n<h3 id=\"三、配置-git-库账号\"><a href=\"#三、配置-git-库账号\" class=\"headerlink\" title=\"三、配置 git 库账号\"></a>三、配置 git 库账号</h3><p>为了使 github / gitlab 知道提交的用户是谁，需要对账户名进行配置。由于全局配置是公司的账号，所以只需要对自己想要进行操作的 github 库进行本地配置即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --local user.name &apos;username&apos; # github账号名称</span><br><span class=\"line\">git config --local user.email &apos;username@gmail.com&apos; # github账号邮箱</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>或者直接 init 一个 git 库，配置后 github 的代码都在这个仓库下拉取。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://segmentfault.com/a/1190000014626841?utm_source=channel-hottest\" target=\"_blank\" rel=\"noopener\">如何在同一台电脑上使用github和gitlab</a><br><a href=\"https://blog.csdn.net/mycafe_/article/details/79231599\" target=\"_blank\" rel=\"noopener\">同时使用两个账号分别操作Github和Gitlab</a><br><a href=\"http://www.cnblogs.com/lpdi/p/6816380.html\" target=\"_blank\" rel=\"noopener\">由于SSH配置文件的不匹配，导致的Permission denied (publickey)及其解决方法</a></p>"},{"title":"微信小程序从 0 到 1","date":"2021-03-22T06:11:28.000Z","_content":"\n入职一年的时间，大部分都在与它打交道，在此记录一下相关知识。\n<!--more-->\n\n\n## 与H5相比，孰优孰劣\n### 对比\n* 运行环境\n  * ​网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应；\n  * 在小程序中，二者是分开的，分别运行在不同的线程中。\n* 开发差异\n  * 小程序原生写法很像前端框架中的 Vue，也是 MVVM 模式，但是写法上没有完全照抄，都可以用类似虚拟 DOM 的形式能保证你的数据变化自动响应到模板；\n  * 小程序里不能使用任何 window 下的属性和方法；\n  * 小程序不可以过虚拟 DOM 来操作 DOM，不能使用任何 DOM 和 BOM 相关API；\n    * 这是因为：小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 DOM API 和 BOM API；\n  * 小程序提供了很多 SDK 方法，几乎涵盖了 APP 能赋予 H5 的所有能力；\n  * 小程序类似于离线包，只要用户访问过，就会把主包代码下载到本地。\n* 维护成本\n  * ​__网页开发者需要面对各式的浏览器兼容__：如 PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对 Safari、Chrome以及 iOS、Android 系统中的各式 WebView，__开发时只需要常用的编辑器和浏览器即可__;\n  * __小程序开发过程中需要面对的是两大操作系统__ iOS 和 Android __的微信客户端__，以及用于辅助开发的小程序开发者工具；小程序的 __开发者需要经过申请小程序帐号、安装小程序开发者工具、配置项目__ 等等过程才可进行小程序开发。\n\n\n## 开发前准备\n* [申请小程序账号](https://mp.weixin.qq.com/wxopen/waregister?action=step1)\n* [安装开发者工具](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)\n* 将 AppId 填入开发者工具，新建/导入项目即可\n  （若无 AppId，可去注册新账号，或者使用[测试号](https://developers.weixin.qq.com/miniprogram/dev/devtools/sandbox.html)）\n\n### 账号相关权限\n开发者和测试相关的权限需要在微信后台添加；权限分为项目成员和体验成员，都有数量限制。\n一般将开发者添加为 __项目成员__，将测试人员或者 PM 添加为 __体验成员__。\n\n## 开发上手\n### 相关文档\n* [小程序开发文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)\n* [微信管理后台](https://mp.weixin.qq.com/?token=&lang=zh_CN)\n\n### 项目目录\n一个小程序主体部分由三个文件组成，必须放在项目的根目录：\n\n| 文件 | 必须 | 作用 |\n| - | - | - |\n| [app.js](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html) | 是 | 小程序逻辑：调用小程序实例、小程序生命周期 hook |\n| [app.json](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html) | 是 | 全局配置：决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等 |\n| app.wxss | 否 | 小程序公共样式表 |\n\n\n### 相关概念\n#### [基础库](https://developers.weixin.qq.com/miniprogram/dev/framework/client-lib/version.html)\n小程序的能力需要微信客户端来支撑，每一个基础库都只能在对应的客户端版本上运行，高版本的基础库无法兼容低版本的微信客户端。\n[基础库版本分布](https://developers.weixin.qq.com/miniprogram/dev/framework/client-lib/version.html)\n\n#### [分包](https://w.cnblogs.com/fsg6/p/13655175.html)\n某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。这样做可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作。\n在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。\n\n目前小程序分包大小有以下限制：\n* 整个小程序所有分包大小不超过 20M\n* 单个分包/主包大小不能超过 2M\n\n开发者通过在 app.json subpackages 字段声明项目分包结构：\n写成 subPackages 也支持：\n````javascript\n{\n  \"pages\":[\n    \"pages/index\",\n    \"pages/logs\"\n  ],\n  \"subpackages\": [\n    {\n      \"root\": \"packageA\",\n      \"pages\": [\n        \"pages/cat\",\n      ]\n    }, {\n      \"root\": \"packageB\",\n      \"name\": \"pack2\",\n      \"pages\": [\n        \"pages/apple\",\n      ]\n    }\n  ]\n}\n````\n__打包原则__\n* 声明 subpackages 后，将按 subpackages 配置路径进行打包，__subpackages 配置路径外的目录将被打包到 app（主包）中__；\n* app（主包）也可以有自己的 pages（即最外层的 pages 字段）；\n* subpackage 的根目录不能是另外一个 subpackage 内的子目录；\n* tabBar 页面必须在 app（主包）内。\n\n__引用原则__\n* packageA 无法 require packageB JS 文件，但可以 require app、自己 package 内的 JS 文件；\n* packageA 无法 import packageB 的 template，但可以 require app、自己 package 内的 template；\n* packageA 无法使用 packageB 的资源，但可以使用 app、自己 package 内的资源。\n\n例如：nodemodules 包中引用的代码会打包到主包中，因为该文件路径在 subPages 之外。\n\n### [常用 API 及能力](https://developers.weixin.qq.com/miniprogram/dev/api/)\n* 常用事件如 Tap、longPress 参照：[WXML的冒泡事件列表](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#%E4%BA%8B%E4%BB%B6%E5%88%86%E7%B1%BB)\n* getApp()：获取全局的应用实例，全局数据可以在 App 中设置\n  ````javascript\n  // app.js\n  App({\n    globalData: 1\n  })\n\n  // a.js\n  var app = getApp()\n  app.globalData++\n  ````\n* 授权相关信息\n  * 获取用户手机号\n    * 需要将 `<button>` 组件 open-type 的值设置为 getPhoneNumber，当用户点击同意之后，可以通过 bindgetphonenumber 事件回调获取到微信服务器返回的加密数据；\n    ````javascript\n    <button open-type=\"getPhoneNumber\" bindgetphonenumber=\"getPhoneNumber\"></button>\n    ````\n  * wx.getSetting() 获取用户当前权限配置，常可以用来在调用某项系统功能时，查看用户是否授权（例如保存存图片到相册）\n  * wx.authorize() 向用户发起授权请求，调用后会立即弹窗询问用户是否同意授权小程序使用某项功能（__如果用户之前已经同意授权，则不会出现弹窗__）\n  ````javascript\n  // 下边这段代码就是上两个 API 的应用\n  wx.getSetting({\n    success: (res?: any) => {\n      // 判断是否已经授权\n      if (!res['scope.writePhotosAlbum']) {\n        wx.authorize({\n          scope: 'scope.writePhotosAlbum',\n          success: () => {\n            // 存储图片\n            wx.saveImageToPhotosAlbum(...) \n          }\n        })\n      } else {\n        // 调起客户端小程序设置界面，返回用户设置的操作结果\n        wx.openSetting()\n      }\n    }\n  })\n  ````\n  * 若想取消当前用户授权，可【点击小程序右上角三个点】->【设置】->【用户信息】一项里取消授权\n\n* 生成小程序二维码\n  * wxacode.createQRCode：获取小程序二维码，适用于需要的码数量较少的业务场景。通过该接口生成的小程序码，永久有效，有数量限制；\n* 小程序运行版本的区分\n  * __wxConfig.envVersion：会返回当前小程序运行版本\n    * develop - 开发版\n    * trial - 体验版\n    * release - 正式版\n  * 注：此方法没有在官方文档上注明，只是挂在在全局 this 下，使用时注意该对象是否存在。\n\n\n* __与其他第三方应用进行交互__\n  * 跳转第三方小程序：需要将被调用的第三方小程序的 AppId 加入到小程序项目白名单中，正式版只能打开正式版；\n    * wx.navigateToMiniProgram\n    * wx.navigateBackMiniProgram\n  * 小程序内关注公众号：\n    * `<official-account>` 原生组件，只能关注与小程序主体相同的公众号（后台配置），且样式不允许自定义，使用场景受限（扫码）；\n  * 小程序唤起 app：\n    * 直接唤起：否；\n    * 由 app 直接调起小程序，然后小程序可以通过操作再调起 app；\n    * 从 app 分享出去的小程序，可以调起 app：需要将 `<button>` 组件 open-type 的值设置为 launchApp（[详情](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/launchApp.html)）\n  * 小程序内访问 H5：\n    * `<web-view>` 原生组件，个人类型的小程序暂不支持使用，需要在微信后台将域名加入白名单；\n  * 小程序内打开公众号文章：\n    * 使用 `<web-view>` 组件即可打开相关联的公众号文章，非关联的公众号则提示“无法打开图文消息”;\n    * 在微信管理后台：设置 -> 关联设置 中可以看到“关联的公众号”，（需要到公众号中关联小程序）。\n\n\n* __第三方应用与小程序的交互__\n  * APP 调起微信小程序（只能调用与当前APP相关联的小程序） [参考](https://www.jianshu.com/p/abe336ca2fed)\n    * 在微信管理后台：设置 -> 关联设置 中可以看到“关联的移动应用”；\n    * 可跳转到指定页面\n    * [限制](https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Launching_a_Mini_Program/Launching_a_Mini_Program.html)：  \n      * APP和小程序相同主体：如果在同一个主体下，不存在调用个数限制；\n      * APP和小程序不同主体：如果不在同一个主体下，一个app最多只能关联3个小程序。也就是说，非相同主体的小程序最多拉起3个；\n  * 外部 H5 调起微信小程序\n    * 直接调用：否；\n    * 可根原生同学协商，使用 APP 提供的 SDK 方法调用；\n  * 短信跳转小程序  \n    * 直接调用：否；\n    * 使用微信云开发能力，打开M页跳转小程序（待调研）；\n  * 公众号打开小程序（只能调用与当前公众号相关联的小程序）[参考](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html#22)\n\n\n### 常见的兼容问题\n* [微信小程序之 1rpx 的边框在部分机型上展示不全](https://blog.csdn.net/c5211314963/article/details/80323443)\n\n\n### 项目测试\n#### 可以从 H5 直接进入小程序体验版\n在移动端打开：\n\n`https://open.weixin.qq.com/sns/getexpappinfo?appid={AppId}&path={pagesPath}.html`\n\n即可访问小程序体验版，并跳转到对应路径（注意：此链接只能在移动端微信中打开）.\n\n也可以，通过判断微信版本，自己写一个测试/入口构造页面来作为测试入口。\n\n#### 缓存\n小程序的所有缓存数据上线为 10MB，像 storage 中的数据，除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。\n清除缓存：\n* 发现-小程序-在列表中删除掉测试的小程序；\n* 微信-我-设置-通用-存储空间；\n* 安卓在私信聊天页输入 [debugx5.qq.com](debugx5.qq.com) ，利用腾讯的工具清理 cookie；\n* 退出登录，重新登录。\n\n#### Android\n由于安卓9的安全限制，无法信任用户自行安装的证书，正常状态连代理打开小程序会报错“获取运行环境失败”；\n将手机 root 后，解决证书信任问题后才能访问。\n\n#### IOS\n直接连代理，访问小程序即可。\n\n### 框架对比\n业内知常见小程序框架：wepy、mpvue、uni-app、taro、chameleon。\n主流框架对比：[详情](https://juejin.cn/post/6844904118901817351)\n主流框架性能对比：[详情](https://dashen.zhuanspirit.com/pages/viewpage.action?pageId=44424143)\n\n### 个人偏见\n#### 关于功能开发\n从一个开发者的角度，我并不希听到产品说“这个功能和页面要和APP保持一致”。\n个人认为 APP 承载的功能是核心且重的，也是在用户体验上最优的一端，若将 H5 和小程序的功能完全与 APP 拉齐，不仅开发周期长，维护难度高，同时会让小程序和 H5 失去本身的轻量优势。\n小程序 和 H5 应该承载更多引流的功能，而不是一整套完备的 APP，当然了，这句话是针对公司有核心 APP 的情况；若是主要产品就是小程序方向，就看功能利弊的权衡了，只是个人认为“小程序”不应该变成一个庞然大物，就像是不要把AK当成加特林用...\n\n#### 关于设计还原\n由于小程序提供的通用的原生组件有的时候，是不允许开发者更改某些样式的，此时要跟设计同学及时反馈；若要自己开发某些组件，记得增加工期。\n用现有的框架也可以：[汇总9款优秀的开源小程序UI框架](https://zhuanlan.zhihu.com/p/204245080?utm_source=qq)\n\n#### 关于部署上线\n最后一点，不管是开发还是审核部署，小程序强烈依赖微信运行环境，被封禁和能否上线的话语权（例如小程序中有游戏广告之类的，通常就会被封禁）并非掌握在自己手里，需要做好被封禁时的准备，域名同理。\n\n### 参考链接\n* [小程序开发文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)\n* [小程序登录授权及获取用户信息API详解](https://zhuanlan.zhihu.com/p/106267803?isappinstalled=0)\n* [多途径唤起小程序/APP](https://www.jianshu.com/p/de0976045bdb)","source":"_posts/微信小程序从0到1.md","raw":"---\ntitle: 微信小程序从 0 到 1\ndate: 2021-03-22 14:11:28\ntags: [微信, 小程序]\ncategories: [前端]\n---\n\n入职一年的时间，大部分都在与它打交道，在此记录一下相关知识。\n<!--more-->\n\n\n## 与H5相比，孰优孰劣\n### 对比\n* 运行环境\n  * ​网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应；\n  * 在小程序中，二者是分开的，分别运行在不同的线程中。\n* 开发差异\n  * 小程序原生写法很像前端框架中的 Vue，也是 MVVM 模式，但是写法上没有完全照抄，都可以用类似虚拟 DOM 的形式能保证你的数据变化自动响应到模板；\n  * 小程序里不能使用任何 window 下的属性和方法；\n  * 小程序不可以过虚拟 DOM 来操作 DOM，不能使用任何 DOM 和 BOM 相关API；\n    * 这是因为：小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 DOM API 和 BOM API；\n  * 小程序提供了很多 SDK 方法，几乎涵盖了 APP 能赋予 H5 的所有能力；\n  * 小程序类似于离线包，只要用户访问过，就会把主包代码下载到本地。\n* 维护成本\n  * ​__网页开发者需要面对各式的浏览器兼容__：如 PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对 Safari、Chrome以及 iOS、Android 系统中的各式 WebView，__开发时只需要常用的编辑器和浏览器即可__;\n  * __小程序开发过程中需要面对的是两大操作系统__ iOS 和 Android __的微信客户端__，以及用于辅助开发的小程序开发者工具；小程序的 __开发者需要经过申请小程序帐号、安装小程序开发者工具、配置项目__ 等等过程才可进行小程序开发。\n\n\n## 开发前准备\n* [申请小程序账号](https://mp.weixin.qq.com/wxopen/waregister?action=step1)\n* [安装开发者工具](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)\n* 将 AppId 填入开发者工具，新建/导入项目即可\n  （若无 AppId，可去注册新账号，或者使用[测试号](https://developers.weixin.qq.com/miniprogram/dev/devtools/sandbox.html)）\n\n### 账号相关权限\n开发者和测试相关的权限需要在微信后台添加；权限分为项目成员和体验成员，都有数量限制。\n一般将开发者添加为 __项目成员__，将测试人员或者 PM 添加为 __体验成员__。\n\n## 开发上手\n### 相关文档\n* [小程序开发文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)\n* [微信管理后台](https://mp.weixin.qq.com/?token=&lang=zh_CN)\n\n### 项目目录\n一个小程序主体部分由三个文件组成，必须放在项目的根目录：\n\n| 文件 | 必须 | 作用 |\n| - | - | - |\n| [app.js](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html) | 是 | 小程序逻辑：调用小程序实例、小程序生命周期 hook |\n| [app.json](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html) | 是 | 全局配置：决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等 |\n| app.wxss | 否 | 小程序公共样式表 |\n\n\n### 相关概念\n#### [基础库](https://developers.weixin.qq.com/miniprogram/dev/framework/client-lib/version.html)\n小程序的能力需要微信客户端来支撑，每一个基础库都只能在对应的客户端版本上运行，高版本的基础库无法兼容低版本的微信客户端。\n[基础库版本分布](https://developers.weixin.qq.com/miniprogram/dev/framework/client-lib/version.html)\n\n#### [分包](https://w.cnblogs.com/fsg6/p/13655175.html)\n某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。这样做可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作。\n在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。\n\n目前小程序分包大小有以下限制：\n* 整个小程序所有分包大小不超过 20M\n* 单个分包/主包大小不能超过 2M\n\n开发者通过在 app.json subpackages 字段声明项目分包结构：\n写成 subPackages 也支持：\n````javascript\n{\n  \"pages\":[\n    \"pages/index\",\n    \"pages/logs\"\n  ],\n  \"subpackages\": [\n    {\n      \"root\": \"packageA\",\n      \"pages\": [\n        \"pages/cat\",\n      ]\n    }, {\n      \"root\": \"packageB\",\n      \"name\": \"pack2\",\n      \"pages\": [\n        \"pages/apple\",\n      ]\n    }\n  ]\n}\n````\n__打包原则__\n* 声明 subpackages 后，将按 subpackages 配置路径进行打包，__subpackages 配置路径外的目录将被打包到 app（主包）中__；\n* app（主包）也可以有自己的 pages（即最外层的 pages 字段）；\n* subpackage 的根目录不能是另外一个 subpackage 内的子目录；\n* tabBar 页面必须在 app（主包）内。\n\n__引用原则__\n* packageA 无法 require packageB JS 文件，但可以 require app、自己 package 内的 JS 文件；\n* packageA 无法 import packageB 的 template，但可以 require app、自己 package 内的 template；\n* packageA 无法使用 packageB 的资源，但可以使用 app、自己 package 内的资源。\n\n例如：nodemodules 包中引用的代码会打包到主包中，因为该文件路径在 subPages 之外。\n\n### [常用 API 及能力](https://developers.weixin.qq.com/miniprogram/dev/api/)\n* 常用事件如 Tap、longPress 参照：[WXML的冒泡事件列表](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#%E4%BA%8B%E4%BB%B6%E5%88%86%E7%B1%BB)\n* getApp()：获取全局的应用实例，全局数据可以在 App 中设置\n  ````javascript\n  // app.js\n  App({\n    globalData: 1\n  })\n\n  // a.js\n  var app = getApp()\n  app.globalData++\n  ````\n* 授权相关信息\n  * 获取用户手机号\n    * 需要将 `<button>` 组件 open-type 的值设置为 getPhoneNumber，当用户点击同意之后，可以通过 bindgetphonenumber 事件回调获取到微信服务器返回的加密数据；\n    ````javascript\n    <button open-type=\"getPhoneNumber\" bindgetphonenumber=\"getPhoneNumber\"></button>\n    ````\n  * wx.getSetting() 获取用户当前权限配置，常可以用来在调用某项系统功能时，查看用户是否授权（例如保存存图片到相册）\n  * wx.authorize() 向用户发起授权请求，调用后会立即弹窗询问用户是否同意授权小程序使用某项功能（__如果用户之前已经同意授权，则不会出现弹窗__）\n  ````javascript\n  // 下边这段代码就是上两个 API 的应用\n  wx.getSetting({\n    success: (res?: any) => {\n      // 判断是否已经授权\n      if (!res['scope.writePhotosAlbum']) {\n        wx.authorize({\n          scope: 'scope.writePhotosAlbum',\n          success: () => {\n            // 存储图片\n            wx.saveImageToPhotosAlbum(...) \n          }\n        })\n      } else {\n        // 调起客户端小程序设置界面，返回用户设置的操作结果\n        wx.openSetting()\n      }\n    }\n  })\n  ````\n  * 若想取消当前用户授权，可【点击小程序右上角三个点】->【设置】->【用户信息】一项里取消授权\n\n* 生成小程序二维码\n  * wxacode.createQRCode：获取小程序二维码，适用于需要的码数量较少的业务场景。通过该接口生成的小程序码，永久有效，有数量限制；\n* 小程序运行版本的区分\n  * __wxConfig.envVersion：会返回当前小程序运行版本\n    * develop - 开发版\n    * trial - 体验版\n    * release - 正式版\n  * 注：此方法没有在官方文档上注明，只是挂在在全局 this 下，使用时注意该对象是否存在。\n\n\n* __与其他第三方应用进行交互__\n  * 跳转第三方小程序：需要将被调用的第三方小程序的 AppId 加入到小程序项目白名单中，正式版只能打开正式版；\n    * wx.navigateToMiniProgram\n    * wx.navigateBackMiniProgram\n  * 小程序内关注公众号：\n    * `<official-account>` 原生组件，只能关注与小程序主体相同的公众号（后台配置），且样式不允许自定义，使用场景受限（扫码）；\n  * 小程序唤起 app：\n    * 直接唤起：否；\n    * 由 app 直接调起小程序，然后小程序可以通过操作再调起 app；\n    * 从 app 分享出去的小程序，可以调起 app：需要将 `<button>` 组件 open-type 的值设置为 launchApp（[详情](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/launchApp.html)）\n  * 小程序内访问 H5：\n    * `<web-view>` 原生组件，个人类型的小程序暂不支持使用，需要在微信后台将域名加入白名单；\n  * 小程序内打开公众号文章：\n    * 使用 `<web-view>` 组件即可打开相关联的公众号文章，非关联的公众号则提示“无法打开图文消息”;\n    * 在微信管理后台：设置 -> 关联设置 中可以看到“关联的公众号”，（需要到公众号中关联小程序）。\n\n\n* __第三方应用与小程序的交互__\n  * APP 调起微信小程序（只能调用与当前APP相关联的小程序） [参考](https://www.jianshu.com/p/abe336ca2fed)\n    * 在微信管理后台：设置 -> 关联设置 中可以看到“关联的移动应用”；\n    * 可跳转到指定页面\n    * [限制](https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Launching_a_Mini_Program/Launching_a_Mini_Program.html)：  \n      * APP和小程序相同主体：如果在同一个主体下，不存在调用个数限制；\n      * APP和小程序不同主体：如果不在同一个主体下，一个app最多只能关联3个小程序。也就是说，非相同主体的小程序最多拉起3个；\n  * 外部 H5 调起微信小程序\n    * 直接调用：否；\n    * 可根原生同学协商，使用 APP 提供的 SDK 方法调用；\n  * 短信跳转小程序  \n    * 直接调用：否；\n    * 使用微信云开发能力，打开M页跳转小程序（待调研）；\n  * 公众号打开小程序（只能调用与当前公众号相关联的小程序）[参考](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html#22)\n\n\n### 常见的兼容问题\n* [微信小程序之 1rpx 的边框在部分机型上展示不全](https://blog.csdn.net/c5211314963/article/details/80323443)\n\n\n### 项目测试\n#### 可以从 H5 直接进入小程序体验版\n在移动端打开：\n\n`https://open.weixin.qq.com/sns/getexpappinfo?appid={AppId}&path={pagesPath}.html`\n\n即可访问小程序体验版，并跳转到对应路径（注意：此链接只能在移动端微信中打开）.\n\n也可以，通过判断微信版本，自己写一个测试/入口构造页面来作为测试入口。\n\n#### 缓存\n小程序的所有缓存数据上线为 10MB，像 storage 中的数据，除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。\n清除缓存：\n* 发现-小程序-在列表中删除掉测试的小程序；\n* 微信-我-设置-通用-存储空间；\n* 安卓在私信聊天页输入 [debugx5.qq.com](debugx5.qq.com) ，利用腾讯的工具清理 cookie；\n* 退出登录，重新登录。\n\n#### Android\n由于安卓9的安全限制，无法信任用户自行安装的证书，正常状态连代理打开小程序会报错“获取运行环境失败”；\n将手机 root 后，解决证书信任问题后才能访问。\n\n#### IOS\n直接连代理，访问小程序即可。\n\n### 框架对比\n业内知常见小程序框架：wepy、mpvue、uni-app、taro、chameleon。\n主流框架对比：[详情](https://juejin.cn/post/6844904118901817351)\n主流框架性能对比：[详情](https://dashen.zhuanspirit.com/pages/viewpage.action?pageId=44424143)\n\n### 个人偏见\n#### 关于功能开发\n从一个开发者的角度，我并不希听到产品说“这个功能和页面要和APP保持一致”。\n个人认为 APP 承载的功能是核心且重的，也是在用户体验上最优的一端，若将 H5 和小程序的功能完全与 APP 拉齐，不仅开发周期长，维护难度高，同时会让小程序和 H5 失去本身的轻量优势。\n小程序 和 H5 应该承载更多引流的功能，而不是一整套完备的 APP，当然了，这句话是针对公司有核心 APP 的情况；若是主要产品就是小程序方向，就看功能利弊的权衡了，只是个人认为“小程序”不应该变成一个庞然大物，就像是不要把AK当成加特林用...\n\n#### 关于设计还原\n由于小程序提供的通用的原生组件有的时候，是不允许开发者更改某些样式的，此时要跟设计同学及时反馈；若要自己开发某些组件，记得增加工期。\n用现有的框架也可以：[汇总9款优秀的开源小程序UI框架](https://zhuanlan.zhihu.com/p/204245080?utm_source=qq)\n\n#### 关于部署上线\n最后一点，不管是开发还是审核部署，小程序强烈依赖微信运行环境，被封禁和能否上线的话语权（例如小程序中有游戏广告之类的，通常就会被封禁）并非掌握在自己手里，需要做好被封禁时的准备，域名同理。\n\n### 参考链接\n* [小程序开发文档](https://developers.weixin.qq.com/miniprogram/dev/framework/)\n* [小程序登录授权及获取用户信息API详解](https://zhuanlan.zhihu.com/p/106267803?isappinstalled=0)\n* [多途径唤起小程序/APP](https://www.jianshu.com/p/de0976045bdb)","slug":"微信小程序从0到1","published":1,"updated":"2021-03-22T07:50:52.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo11001b7vvuruzpiggr","content":"<p>入职一年的时间，大部分都在与它打交道，在此记录一下相关知识。<br><a id=\"more\"></a></p>\n<h2 id=\"与H5相比，孰优孰劣\"><a href=\"#与H5相比，孰优孰劣\" class=\"headerlink\" title=\"与H5相比，孰优孰劣\"></a>与H5相比，孰优孰劣</h2><h3 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h3><ul>\n<li>运行环境<ul>\n<li>​网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应；</li>\n<li>在小程序中，二者是分开的，分别运行在不同的线程中。</li>\n</ul>\n</li>\n<li>开发差异<ul>\n<li>小程序原生写法很像前端框架中的 Vue，也是 MVVM 模式，但是写法上没有完全照抄，都可以用类似虚拟 DOM 的形式能保证你的数据变化自动响应到模板；</li>\n<li>小程序里不能使用任何 window 下的属性和方法；</li>\n<li>小程序不可以过虚拟 DOM 来操作 DOM，不能使用任何 DOM 和 BOM 相关API；<ul>\n<li>这是因为：小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 DOM API 和 BOM API；</li>\n</ul>\n</li>\n<li>小程序提供了很多 SDK 方法，几乎涵盖了 APP 能赋予 H5 的所有能力；</li>\n<li>小程序类似于离线包，只要用户访问过，就会把主包代码下载到本地。</li>\n</ul>\n</li>\n<li>维护成本<ul>\n<li>​<strong>网页开发者需要面对各式的浏览器兼容</strong>：如 PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对 Safari、Chrome以及 iOS、Android 系统中的各式 WebView，<strong>开发时只需要常用的编辑器和浏览器即可</strong>;</li>\n<li><strong>小程序开发过程中需要面对的是两大操作系统</strong> iOS 和 Android <strong>的微信客户端</strong>，以及用于辅助开发的小程序开发者工具；小程序的 <strong>开发者需要经过申请小程序帐号、安装小程序开发者工具、配置项目</strong> 等等过程才可进行小程序开发。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"开发前准备\"><a href=\"#开发前准备\" class=\"headerlink\" title=\"开发前准备\"></a>开发前准备</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/wxopen/waregister?action=step1\" target=\"_blank\" rel=\"noopener\">申请小程序账号</a></li>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html\" target=\"_blank\" rel=\"noopener\">安装开发者工具</a></li>\n<li>将 AppId 填入开发者工具，新建/导入项目即可<br>（若无 AppId，可去注册新账号，或者使用<a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/sandbox.html\" target=\"_blank\" rel=\"noopener\">测试号</a>）</li>\n</ul>\n<h3 id=\"账号相关权限\"><a href=\"#账号相关权限\" class=\"headerlink\" title=\"账号相关权限\"></a>账号相关权限</h3><p>开发者和测试相关的权限需要在微信后台添加；权限分为项目成员和体验成员，都有数量限制。<br>一般将开发者添加为 <strong>项目成员</strong>，将测试人员或者 PM 添加为 <strong>体验成员</strong>。</p>\n<h2 id=\"开发上手\"><a href=\"#开发上手\" class=\"headerlink\" title=\"开发上手\"></a>开发上手</h2><h3 id=\"相关文档\"><a href=\"#相关文档\" class=\"headerlink\" title=\"相关文档\"></a>相关文档</h3><ul>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/\" target=\"_blank\" rel=\"noopener\">小程序开发文档</a></li>\n<li><a href=\"https://mp.weixin.qq.com/?token=&amp;lang=zh_CN\" target=\"_blank\" rel=\"noopener\">微信管理后台</a></li>\n</ul>\n<h3 id=\"项目目录\"><a href=\"#项目目录\" class=\"headerlink\" title=\"项目目录\"></a>项目目录</h3><p>一个小程序主体部分由三个文件组成，必须放在项目的根目录：</p>\n<table>\n<thead>\n<tr>\n<th>文件</th>\n<th>必须</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html\" target=\"_blank\" rel=\"noopener\">app.js</a></td>\n<td>是</td>\n<td>小程序逻辑：调用小程序实例、小程序生命周期 hook</td>\n</tr>\n<tr>\n<td><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/config.html\" target=\"_blank\" rel=\"noopener\">app.json</a></td>\n<td>是</td>\n<td>全局配置：决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等</td>\n</tr>\n<tr>\n<td>app.wxss</td>\n<td>否</td>\n<td>小程序公共样式表</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h3><h4 id=\"基础库\"><a href=\"#基础库\" class=\"headerlink\" title=\"基础库\"></a><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/client-lib/version.html\" target=\"_blank\" rel=\"noopener\">基础库</a></h4><p>小程序的能力需要微信客户端来支撑，每一个基础库都只能在对应的客户端版本上运行，高版本的基础库无法兼容低版本的微信客户端。<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/client-lib/version.html\" target=\"_blank\" rel=\"noopener\">基础库版本分布</a></p>\n<h4 id=\"分包\"><a href=\"#分包\" class=\"headerlink\" title=\"分包\"></a><a href=\"https://w.cnblogs.com/fsg6/p/13655175.html\" target=\"_blank\" rel=\"noopener\">分包</a></h4><p>某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。这样做可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作。<br>在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。</p>\n<p>目前小程序分包大小有以下限制：</p>\n<ul>\n<li>整个小程序所有分包大小不超过 20M</li>\n<li>单个分包/主包大小不能超过 2M</li>\n</ul>\n<p>开发者通过在 app.json subpackages 字段声明项目分包结构：<br>写成 subPackages 也支持：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"pages\"</span>:[</span><br><span class=\"line\">    <span class=\"string\">\"pages/index\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"pages/logs\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">\"subpackages\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"root\"</span>: <span class=\"string\">\"packageA\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"pages\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"pages/cat\"</span>,</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      <span class=\"string\">\"root\"</span>: <span class=\"string\">\"packageB\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"name\"</span>: <span class=\"string\">\"pack2\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"pages\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"pages/apple\"</span>,</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>打包原则</strong></p>\n<ul>\n<li>声明 subpackages 后，将按 subpackages 配置路径进行打包，<strong>subpackages 配置路径外的目录将被打包到 app（主包）中</strong>；</li>\n<li>app（主包）也可以有自己的 pages（即最外层的 pages 字段）；</li>\n<li>subpackage 的根目录不能是另外一个 subpackage 内的子目录；</li>\n<li>tabBar 页面必须在 app（主包）内。</li>\n</ul>\n<p><strong>引用原则</strong></p>\n<ul>\n<li>packageA 无法 require packageB JS 文件，但可以 require app、自己 package 内的 JS 文件；</li>\n<li>packageA 无法 import packageB 的 template，但可以 require app、自己 package 内的 template；</li>\n<li>packageA 无法使用 packageB 的资源，但可以使用 app、自己 package 内的资源。</li>\n</ul>\n<p>例如：nodemodules 包中引用的代码会打包到主包中，因为该文件路径在 subPages 之外。</p>\n<h3 id=\"常用-API-及能力\"><a href=\"#常用-API-及能力\" class=\"headerlink\" title=\"常用 API 及能力\"></a><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/\" target=\"_blank\" rel=\"noopener\">常用 API 及能力</a></h3><ul>\n<li>常用事件如 Tap、longPress 参照：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#%E4%BA%8B%E4%BB%B6%E5%88%86%E7%B1%BB\" target=\"_blank\" rel=\"noopener\">WXML的冒泡事件列表</a></li>\n<li><p>getApp()：获取全局的应用实例，全局数据可以在 App 中设置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\">App(&#123;</span><br><span class=\"line\">  globalData: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = getApp()</span><br><span class=\"line\">app.globalData++</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>授权相关信息</p>\n<ul>\n<li><p>获取用户手机号</p>\n<ul>\n<li>需要将 <code>&lt;button&gt;</code> 组件 open-type 的值设置为 getPhoneNumber，当用户点击同意之后，可以通过 bindgetphonenumber 事件回调获取到微信服务器返回的加密数据；<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button open-type=<span class=\"string\">\"getPhoneNumber\"</span> bindgetphonenumber=<span class=\"string\">\"getPhoneNumber\"</span>&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>wx.getSetting() 获取用户当前权限配置，常可以用来在调用某项系统功能时，查看用户是否授权（例如保存存图片到相册）</p>\n</li>\n<li><p>wx.authorize() 向用户发起授权请求，调用后会立即弹窗询问用户是否同意授权小程序使用某项功能（<strong>如果用户之前已经同意授权，则不会出现弹窗</strong>）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下边这段代码就是上两个 API 的应用</span></span><br><span class=\"line\">wx.getSetting(&#123;</span><br><span class=\"line\">  success: <span class=\"function\">(<span class=\"params\">res?: any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否已经授权</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!res[<span class=\"string\">'scope.writePhotosAlbum'</span>]) &#123;</span><br><span class=\"line\">      wx.authorize(&#123;</span><br><span class=\"line\">        scope: <span class=\"string\">'scope.writePhotosAlbum'</span>,</span><br><span class=\"line\">        success: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 存储图片</span></span><br><span class=\"line\">          wx.saveImageToPhotosAlbum(...) </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 调起客户端小程序设置界面，返回用户设置的操作结果</span></span><br><span class=\"line\">      wx.openSetting()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若想取消当前用户授权，可【点击小程序右上角三个点】-&gt;【设置】-&gt;【用户信息】一项里取消授权</p>\n</li>\n</ul>\n</li>\n<li><p>生成小程序二维码</p>\n<ul>\n<li>wxacode.createQRCode：获取小程序二维码，适用于需要的码数量较少的业务场景。通过该接口生成的小程序码，永久有效，有数量限制；</li>\n</ul>\n</li>\n<li>小程序运行版本的区分<ul>\n<li>__wxConfig.envVersion：会返回当前小程序运行版本<ul>\n<li>develop - 开发版</li>\n<li>trial - 体验版</li>\n<li>release - 正式版</li>\n</ul>\n</li>\n<li>注：此方法没有在官方文档上注明，只是挂在在全局 this 下，使用时注意该对象是否存在。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>与其他第三方应用进行交互</strong><ul>\n<li>跳转第三方小程序：需要将被调用的第三方小程序的 AppId 加入到小程序项目白名单中，正式版只能打开正式版；<ul>\n<li>wx.navigateToMiniProgram</li>\n<li>wx.navigateBackMiniProgram</li>\n</ul>\n</li>\n<li>小程序内关注公众号：<ul>\n<li><code>&lt;official-account&gt;</code> 原生组件，只能关注与小程序主体相同的公众号（后台配置），且样式不允许自定义，使用场景受限（扫码）；</li>\n</ul>\n</li>\n<li>小程序唤起 app：<ul>\n<li>直接唤起：否；</li>\n<li>由 app 直接调起小程序，然后小程序可以通过操作再调起 app；</li>\n<li>从 app 分享出去的小程序，可以调起 app：需要将 <code>&lt;button&gt;</code> 组件 open-type 的值设置为 launchApp（<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/launchApp.html\" target=\"_blank\" rel=\"noopener\">详情</a>）</li>\n</ul>\n</li>\n<li>小程序内访问 H5：<ul>\n<li><code>&lt;web-view&gt;</code> 原生组件，个人类型的小程序暂不支持使用，需要在微信后台将域名加入白名单；</li>\n</ul>\n</li>\n<li>小程序内打开公众号文章：<ul>\n<li>使用 <code>&lt;web-view&gt;</code> 组件即可打开相关联的公众号文章，非关联的公众号则提示“无法打开图文消息”;</li>\n<li>在微信管理后台：设置 -&gt; 关联设置 中可以看到“关联的公众号”，（需要到公众号中关联小程序）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>第三方应用与小程序的交互</strong><ul>\n<li>APP 调起微信小程序（只能调用与当前APP相关联的小程序） <a href=\"https://www.jianshu.com/p/abe336ca2fed\" target=\"_blank\" rel=\"noopener\">参考</a><ul>\n<li>在微信管理后台：设置 -&gt; 关联设置 中可以看到“关联的移动应用”；</li>\n<li>可跳转到指定页面</li>\n<li><a href=\"https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Launching_a_Mini_Program/Launching_a_Mini_Program.html\" target=\"_blank\" rel=\"noopener\">限制</a>：  <ul>\n<li>APP和小程序相同主体：如果在同一个主体下，不存在调用个数限制；</li>\n<li>APP和小程序不同主体：如果不在同一个主体下，一个app最多只能关联3个小程序。也就是说，非相同主体的小程序最多拉起3个；</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>外部 H5 调起微信小程序<ul>\n<li>直接调用：否；</li>\n<li>可根原生同学协商，使用 APP 提供的 SDK 方法调用；</li>\n</ul>\n</li>\n<li>短信跳转小程序  <ul>\n<li>直接调用：否；</li>\n<li>使用微信云开发能力，打开M页跳转小程序（待调研）；</li>\n</ul>\n</li>\n<li>公众号打开小程序（只能调用与当前公众号相关联的小程序）<a href=\"https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html#22\" target=\"_blank\" rel=\"noopener\">参考</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常见的兼容问题\"><a href=\"#常见的兼容问题\" class=\"headerlink\" title=\"常见的兼容问题\"></a>常见的兼容问题</h3><ul>\n<li><a href=\"https://blog.csdn.net/c5211314963/article/details/80323443\" target=\"_blank\" rel=\"noopener\">微信小程序之 1rpx 的边框在部分机型上展示不全</a></li>\n</ul>\n<h3 id=\"项目测试\"><a href=\"#项目测试\" class=\"headerlink\" title=\"项目测试\"></a>项目测试</h3><h4 id=\"可以从-H5-直接进入小程序体验版\"><a href=\"#可以从-H5-直接进入小程序体验版\" class=\"headerlink\" title=\"可以从 H5 直接进入小程序体验版\"></a>可以从 H5 直接进入小程序体验版</h4><p>在移动端打开：</p>\n<p><code>https://open.weixin.qq.com/sns/getexpappinfo?appid={AppId}&amp;path={pagesPath}.html</code></p>\n<p>即可访问小程序体验版，并跳转到对应路径（注意：此链接只能在移动端微信中打开）.</p>\n<p>也可以，通过判断微信版本，自己写一个测试/入口构造页面来作为测试入口。</p>\n<h4 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h4><p>小程序的所有缓存数据上线为 10MB，像 storage 中的数据，除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。<br>清除缓存：</p>\n<ul>\n<li>发现-小程序-在列表中删除掉测试的小程序；</li>\n<li>微信-我-设置-通用-存储空间；</li>\n<li>安卓在私信聊天页输入 <a href=\"debugx5.qq.com\">debugx5.qq.com</a> ，利用腾讯的工具清理 cookie；</li>\n<li>退出登录，重新登录。</li>\n</ul>\n<h4 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h4><p>由于安卓9的安全限制，无法信任用户自行安装的证书，正常状态连代理打开小程序会报错“获取运行环境失败”；<br>将手机 root 后，解决证书信任问题后才能访问。</p>\n<h4 id=\"IOS\"><a href=\"#IOS\" class=\"headerlink\" title=\"IOS\"></a>IOS</h4><p>直接连代理，访问小程序即可。</p>\n<h3 id=\"框架对比\"><a href=\"#框架对比\" class=\"headerlink\" title=\"框架对比\"></a>框架对比</h3><p>业内知常见小程序框架：wepy、mpvue、uni-app、taro、chameleon。<br>主流框架对比：<a href=\"https://juejin.cn/post/6844904118901817351\" target=\"_blank\" rel=\"noopener\">详情</a><br>主流框架性能对比：<a href=\"https://dashen.zhuanspirit.com/pages/viewpage.action?pageId=44424143\" target=\"_blank\" rel=\"noopener\">详情</a></p>\n<h3 id=\"个人偏见\"><a href=\"#个人偏见\" class=\"headerlink\" title=\"个人偏见\"></a>个人偏见</h3><h4 id=\"关于功能开发\"><a href=\"#关于功能开发\" class=\"headerlink\" title=\"关于功能开发\"></a>关于功能开发</h4><p>从一个开发者的角度，我并不希听到产品说“这个功能和页面要和APP保持一致”。<br>个人认为 APP 承载的功能是核心且重的，也是在用户体验上最优的一端，若将 H5 和小程序的功能完全与 APP 拉齐，不仅开发周期长，维护难度高，同时会让小程序和 H5 失去本身的轻量优势。<br>小程序 和 H5 应该承载更多引流的功能，而不是一整套完备的 APP，当然了，这句话是针对公司有核心 APP 的情况；若是主要产品就是小程序方向，就看功能利弊的权衡了，只是个人认为“小程序”不应该变成一个庞然大物，就像是不要把AK当成加特林用…</p>\n<h4 id=\"关于设计还原\"><a href=\"#关于设计还原\" class=\"headerlink\" title=\"关于设计还原\"></a>关于设计还原</h4><p>由于小程序提供的通用的原生组件有的时候，是不允许开发者更改某些样式的，此时要跟设计同学及时反馈；若要自己开发某些组件，记得增加工期。<br>用现有的框架也可以：<a href=\"https://zhuanlan.zhihu.com/p/204245080?utm_source=qq\" target=\"_blank\" rel=\"noopener\">汇总9款优秀的开源小程序UI框架</a></p>\n<h4 id=\"关于部署上线\"><a href=\"#关于部署上线\" class=\"headerlink\" title=\"关于部署上线\"></a>关于部署上线</h4><p>最后一点，不管是开发还是审核部署，小程序强烈依赖微信运行环境，被封禁和能否上线的话语权（例如小程序中有游戏广告之类的，通常就会被封禁）并非掌握在自己手里，需要做好被封禁时的准备，域名同理。</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><ul>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/\" target=\"_blank\" rel=\"noopener\">小程序开发文档</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/106267803?isappinstalled=0\" target=\"_blank\" rel=\"noopener\">小程序登录授权及获取用户信息API详解</a></li>\n<li><a href=\"https://www.jianshu.com/p/de0976045bdb\" target=\"_blank\" rel=\"noopener\">多途径唤起小程序/APP</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>入职一年的时间，大部分都在与它打交道，在此记录一下相关知识。<br></p>","more":"<p></p>\n<h2 id=\"与H5相比，孰优孰劣\"><a href=\"#与H5相比，孰优孰劣\" class=\"headerlink\" title=\"与H5相比，孰优孰劣\"></a>与H5相比，孰优孰劣</h2><h3 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h3><ul>\n<li>运行环境<ul>\n<li>​网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应；</li>\n<li>在小程序中，二者是分开的，分别运行在不同的线程中。</li>\n</ul>\n</li>\n<li>开发差异<ul>\n<li>小程序原生写法很像前端框架中的 Vue，也是 MVVM 模式，但是写法上没有完全照抄，都可以用类似虚拟 DOM 的形式能保证你的数据变化自动响应到模板；</li>\n<li>小程序里不能使用任何 window 下的属性和方法；</li>\n<li>小程序不可以过虚拟 DOM 来操作 DOM，不能使用任何 DOM 和 BOM 相关API；<ul>\n<li>这是因为：小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 DOM API 和 BOM API；</li>\n</ul>\n</li>\n<li>小程序提供了很多 SDK 方法，几乎涵盖了 APP 能赋予 H5 的所有能力；</li>\n<li>小程序类似于离线包，只要用户访问过，就会把主包代码下载到本地。</li>\n</ul>\n</li>\n<li>维护成本<ul>\n<li>​<strong>网页开发者需要面对各式的浏览器兼容</strong>：如 PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对 Safari、Chrome以及 iOS、Android 系统中的各式 WebView，<strong>开发时只需要常用的编辑器和浏览器即可</strong>;</li>\n<li><strong>小程序开发过程中需要面对的是两大操作系统</strong> iOS 和 Android <strong>的微信客户端</strong>，以及用于辅助开发的小程序开发者工具；小程序的 <strong>开发者需要经过申请小程序帐号、安装小程序开发者工具、配置项目</strong> 等等过程才可进行小程序开发。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"开发前准备\"><a href=\"#开发前准备\" class=\"headerlink\" title=\"开发前准备\"></a>开发前准备</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/wxopen/waregister?action=step1\" target=\"_blank\" rel=\"noopener\">申请小程序账号</a></li>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html\" target=\"_blank\" rel=\"noopener\">安装开发者工具</a></li>\n<li>将 AppId 填入开发者工具，新建/导入项目即可<br>（若无 AppId，可去注册新账号，或者使用<a href=\"https://developers.weixin.qq.com/miniprogram/dev/devtools/sandbox.html\" target=\"_blank\" rel=\"noopener\">测试号</a>）</li>\n</ul>\n<h3 id=\"账号相关权限\"><a href=\"#账号相关权限\" class=\"headerlink\" title=\"账号相关权限\"></a>账号相关权限</h3><p>开发者和测试相关的权限需要在微信后台添加；权限分为项目成员和体验成员，都有数量限制。<br>一般将开发者添加为 <strong>项目成员</strong>，将测试人员或者 PM 添加为 <strong>体验成员</strong>。</p>\n<h2 id=\"开发上手\"><a href=\"#开发上手\" class=\"headerlink\" title=\"开发上手\"></a>开发上手</h2><h3 id=\"相关文档\"><a href=\"#相关文档\" class=\"headerlink\" title=\"相关文档\"></a>相关文档</h3><ul>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/\" target=\"_blank\" rel=\"noopener\">小程序开发文档</a></li>\n<li><a href=\"https://mp.weixin.qq.com/?token=&amp;lang=zh_CN\" target=\"_blank\" rel=\"noopener\">微信管理后台</a></li>\n</ul>\n<h3 id=\"项目目录\"><a href=\"#项目目录\" class=\"headerlink\" title=\"项目目录\"></a>项目目录</h3><p>一个小程序主体部分由三个文件组成，必须放在项目的根目录：</p>\n<table>\n<thead>\n<tr>\n<th>文件</th>\n<th>必须</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html\" target=\"_blank\" rel=\"noopener\">app.js</a></td>\n<td>是</td>\n<td>小程序逻辑：调用小程序实例、小程序生命周期 hook</td>\n</tr>\n<tr>\n<td><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/config.html\" target=\"_blank\" rel=\"noopener\">app.json</a></td>\n<td>是</td>\n<td>全局配置：决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等</td>\n</tr>\n<tr>\n<td>app.wxss</td>\n<td>否</td>\n<td>小程序公共样式表</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h3><h4 id=\"基础库\"><a href=\"#基础库\" class=\"headerlink\" title=\"基础库\"></a><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/client-lib/version.html\" target=\"_blank\" rel=\"noopener\">基础库</a></h4><p>小程序的能力需要微信客户端来支撑，每一个基础库都只能在对应的客户端版本上运行，高版本的基础库无法兼容低版本的微信客户端。<br><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/client-lib/version.html\" target=\"_blank\" rel=\"noopener\">基础库版本分布</a></p>\n<h4 id=\"分包\"><a href=\"#分包\" class=\"headerlink\" title=\"分包\"></a><a href=\"https://w.cnblogs.com/fsg6/p/13655175.html\" target=\"_blank\" rel=\"noopener\">分包</a></h4><p>某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。这样做可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作。<br>在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。</p>\n<p>目前小程序分包大小有以下限制：</p>\n<ul>\n<li>整个小程序所有分包大小不超过 20M</li>\n<li>单个分包/主包大小不能超过 2M</li>\n</ul>\n<p>开发者通过在 app.json subpackages 字段声明项目分包结构：<br>写成 subPackages 也支持：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"pages\"</span>:[</span><br><span class=\"line\">    <span class=\"string\">\"pages/index\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"pages/logs\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">\"subpackages\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"root\"</span>: <span class=\"string\">\"packageA\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"pages\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"pages/cat\"</span>,</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">      <span class=\"string\">\"root\"</span>: <span class=\"string\">\"packageB\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"name\"</span>: <span class=\"string\">\"pack2\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"pages\"</span>: [</span><br><span class=\"line\">        <span class=\"string\">\"pages/apple\"</span>,</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>打包原则</strong></p>\n<ul>\n<li>声明 subpackages 后，将按 subpackages 配置路径进行打包，<strong>subpackages 配置路径外的目录将被打包到 app（主包）中</strong>；</li>\n<li>app（主包）也可以有自己的 pages（即最外层的 pages 字段）；</li>\n<li>subpackage 的根目录不能是另外一个 subpackage 内的子目录；</li>\n<li>tabBar 页面必须在 app（主包）内。</li>\n</ul>\n<p><strong>引用原则</strong></p>\n<ul>\n<li>packageA 无法 require packageB JS 文件，但可以 require app、自己 package 内的 JS 文件；</li>\n<li>packageA 无法 import packageB 的 template，但可以 require app、自己 package 内的 template；</li>\n<li>packageA 无法使用 packageB 的资源，但可以使用 app、自己 package 内的资源。</li>\n</ul>\n<p>例如：nodemodules 包中引用的代码会打包到主包中，因为该文件路径在 subPages 之外。</p>\n<h3 id=\"常用-API-及能力\"><a href=\"#常用-API-及能力\" class=\"headerlink\" title=\"常用 API 及能力\"></a><a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/\" target=\"_blank\" rel=\"noopener\">常用 API 及能力</a></h3><ul>\n<li>常用事件如 Tap、longPress 参照：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#%E4%BA%8B%E4%BB%B6%E5%88%86%E7%B1%BB\" target=\"_blank\" rel=\"noopener\">WXML的冒泡事件列表</a></li>\n<li><p>getApp()：获取全局的应用实例，全局数据可以在 App 中设置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.js</span></span><br><span class=\"line\">App(&#123;</span><br><span class=\"line\">  globalData: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = getApp()</span><br><span class=\"line\">app.globalData++</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>授权相关信息</p>\n<ul>\n<li><p>获取用户手机号</p>\n<ul>\n<li>需要将 <code>&lt;button&gt;</code> 组件 open-type 的值设置为 getPhoneNumber，当用户点击同意之后，可以通过 bindgetphonenumber 事件回调获取到微信服务器返回的加密数据；<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button open-type=<span class=\"string\">\"getPhoneNumber\"</span> bindgetphonenumber=<span class=\"string\">\"getPhoneNumber\"</span>&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>wx.getSetting() 获取用户当前权限配置，常可以用来在调用某项系统功能时，查看用户是否授权（例如保存存图片到相册）</p>\n</li>\n<li><p>wx.authorize() 向用户发起授权请求，调用后会立即弹窗询问用户是否同意授权小程序使用某项功能（<strong>如果用户之前已经同意授权，则不会出现弹窗</strong>）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下边这段代码就是上两个 API 的应用</span></span><br><span class=\"line\">wx.getSetting(&#123;</span><br><span class=\"line\">  success: <span class=\"function\">(<span class=\"params\">res?: any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否已经授权</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!res[<span class=\"string\">'scope.writePhotosAlbum'</span>]) &#123;</span><br><span class=\"line\">      wx.authorize(&#123;</span><br><span class=\"line\">        scope: <span class=\"string\">'scope.writePhotosAlbum'</span>,</span><br><span class=\"line\">        success: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 存储图片</span></span><br><span class=\"line\">          wx.saveImageToPhotosAlbum(...) </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 调起客户端小程序设置界面，返回用户设置的操作结果</span></span><br><span class=\"line\">      wx.openSetting()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若想取消当前用户授权，可【点击小程序右上角三个点】-&gt;【设置】-&gt;【用户信息】一项里取消授权</p>\n</li>\n</ul>\n</li>\n<li><p>生成小程序二维码</p>\n<ul>\n<li>wxacode.createQRCode：获取小程序二维码，适用于需要的码数量较少的业务场景。通过该接口生成的小程序码，永久有效，有数量限制；</li>\n</ul>\n</li>\n<li>小程序运行版本的区分<ul>\n<li>__wxConfig.envVersion：会返回当前小程序运行版本<ul>\n<li>develop - 开发版</li>\n<li>trial - 体验版</li>\n<li>release - 正式版</li>\n</ul>\n</li>\n<li>注：此方法没有在官方文档上注明，只是挂在在全局 this 下，使用时注意该对象是否存在。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>与其他第三方应用进行交互</strong><ul>\n<li>跳转第三方小程序：需要将被调用的第三方小程序的 AppId 加入到小程序项目白名单中，正式版只能打开正式版；<ul>\n<li>wx.navigateToMiniProgram</li>\n<li>wx.navigateBackMiniProgram</li>\n</ul>\n</li>\n<li>小程序内关注公众号：<ul>\n<li><code>&lt;official-account&gt;</code> 原生组件，只能关注与小程序主体相同的公众号（后台配置），且样式不允许自定义，使用场景受限（扫码）；</li>\n</ul>\n</li>\n<li>小程序唤起 app：<ul>\n<li>直接唤起：否；</li>\n<li>由 app 直接调起小程序，然后小程序可以通过操作再调起 app；</li>\n<li>从 app 分享出去的小程序，可以调起 app：需要将 <code>&lt;button&gt;</code> 组件 open-type 的值设置为 launchApp（<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/launchApp.html\" target=\"_blank\" rel=\"noopener\">详情</a>）</li>\n</ul>\n</li>\n<li>小程序内访问 H5：<ul>\n<li><code>&lt;web-view&gt;</code> 原生组件，个人类型的小程序暂不支持使用，需要在微信后台将域名加入白名单；</li>\n</ul>\n</li>\n<li>小程序内打开公众号文章：<ul>\n<li>使用 <code>&lt;web-view&gt;</code> 组件即可打开相关联的公众号文章，非关联的公众号则提示“无法打开图文消息”;</li>\n<li>在微信管理后台：设置 -&gt; 关联设置 中可以看到“关联的公众号”，（需要到公众号中关联小程序）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>第三方应用与小程序的交互</strong><ul>\n<li>APP 调起微信小程序（只能调用与当前APP相关联的小程序） <a href=\"https://www.jianshu.com/p/abe336ca2fed\" target=\"_blank\" rel=\"noopener\">参考</a><ul>\n<li>在微信管理后台：设置 -&gt; 关联设置 中可以看到“关联的移动应用”；</li>\n<li>可跳转到指定页面</li>\n<li><a href=\"https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Launching_a_Mini_Program/Launching_a_Mini_Program.html\" target=\"_blank\" rel=\"noopener\">限制</a>：  <ul>\n<li>APP和小程序相同主体：如果在同一个主体下，不存在调用个数限制；</li>\n<li>APP和小程序不同主体：如果不在同一个主体下，一个app最多只能关联3个小程序。也就是说，非相同主体的小程序最多拉起3个；</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>外部 H5 调起微信小程序<ul>\n<li>直接调用：否；</li>\n<li>可根原生同学协商，使用 APP 提供的 SDK 方法调用；</li>\n</ul>\n</li>\n<li>短信跳转小程序  <ul>\n<li>直接调用：否；</li>\n<li>使用微信云开发能力，打开M页跳转小程序（待调研）；</li>\n</ul>\n</li>\n<li>公众号打开小程序（只能调用与当前公众号相关联的小程序）<a href=\"https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html#22\" target=\"_blank\" rel=\"noopener\">参考</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常见的兼容问题\"><a href=\"#常见的兼容问题\" class=\"headerlink\" title=\"常见的兼容问题\"></a>常见的兼容问题</h3><ul>\n<li><a href=\"https://blog.csdn.net/c5211314963/article/details/80323443\" target=\"_blank\" rel=\"noopener\">微信小程序之 1rpx 的边框在部分机型上展示不全</a></li>\n</ul>\n<h3 id=\"项目测试\"><a href=\"#项目测试\" class=\"headerlink\" title=\"项目测试\"></a>项目测试</h3><h4 id=\"可以从-H5-直接进入小程序体验版\"><a href=\"#可以从-H5-直接进入小程序体验版\" class=\"headerlink\" title=\"可以从 H5 直接进入小程序体验版\"></a>可以从 H5 直接进入小程序体验版</h4><p>在移动端打开：</p>\n<p><code>https://open.weixin.qq.com/sns/getexpappinfo?appid={AppId}&amp;path={pagesPath}.html</code></p>\n<p>即可访问小程序体验版，并跳转到对应路径（注意：此链接只能在移动端微信中打开）.</p>\n<p>也可以，通过判断微信版本，自己写一个测试/入口构造页面来作为测试入口。</p>\n<h4 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h4><p>小程序的所有缓存数据上线为 10MB，像 storage 中的数据，除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。<br>清除缓存：</p>\n<ul>\n<li>发现-小程序-在列表中删除掉测试的小程序；</li>\n<li>微信-我-设置-通用-存储空间；</li>\n<li>安卓在私信聊天页输入 <a href=\"debugx5.qq.com\">debugx5.qq.com</a> ，利用腾讯的工具清理 cookie；</li>\n<li>退出登录，重新登录。</li>\n</ul>\n<h4 id=\"Android\"><a href=\"#Android\" class=\"headerlink\" title=\"Android\"></a>Android</h4><p>由于安卓9的安全限制，无法信任用户自行安装的证书，正常状态连代理打开小程序会报错“获取运行环境失败”；<br>将手机 root 后，解决证书信任问题后才能访问。</p>\n<h4 id=\"IOS\"><a href=\"#IOS\" class=\"headerlink\" title=\"IOS\"></a>IOS</h4><p>直接连代理，访问小程序即可。</p>\n<h3 id=\"框架对比\"><a href=\"#框架对比\" class=\"headerlink\" title=\"框架对比\"></a>框架对比</h3><p>业内知常见小程序框架：wepy、mpvue、uni-app、taro、chameleon。<br>主流框架对比：<a href=\"https://juejin.cn/post/6844904118901817351\" target=\"_blank\" rel=\"noopener\">详情</a><br>主流框架性能对比：<a href=\"https://dashen.zhuanspirit.com/pages/viewpage.action?pageId=44424143\" target=\"_blank\" rel=\"noopener\">详情</a></p>\n<h3 id=\"个人偏见\"><a href=\"#个人偏见\" class=\"headerlink\" title=\"个人偏见\"></a>个人偏见</h3><h4 id=\"关于功能开发\"><a href=\"#关于功能开发\" class=\"headerlink\" title=\"关于功能开发\"></a>关于功能开发</h4><p>从一个开发者的角度，我并不希听到产品说“这个功能和页面要和APP保持一致”。<br>个人认为 APP 承载的功能是核心且重的，也是在用户体验上最优的一端，若将 H5 和小程序的功能完全与 APP 拉齐，不仅开发周期长，维护难度高，同时会让小程序和 H5 失去本身的轻量优势。<br>小程序 和 H5 应该承载更多引流的功能，而不是一整套完备的 APP，当然了，这句话是针对公司有核心 APP 的情况；若是主要产品就是小程序方向，就看功能利弊的权衡了，只是个人认为“小程序”不应该变成一个庞然大物，就像是不要把AK当成加特林用…</p>\n<h4 id=\"关于设计还原\"><a href=\"#关于设计还原\" class=\"headerlink\" title=\"关于设计还原\"></a>关于设计还原</h4><p>由于小程序提供的通用的原生组件有的时候，是不允许开发者更改某些样式的，此时要跟设计同学及时反馈；若要自己开发某些组件，记得增加工期。<br>用现有的框架也可以：<a href=\"https://zhuanlan.zhihu.com/p/204245080?utm_source=qq\" target=\"_blank\" rel=\"noopener\">汇总9款优秀的开源小程序UI框架</a></p>\n<h4 id=\"关于部署上线\"><a href=\"#关于部署上线\" class=\"headerlink\" title=\"关于部署上线\"></a>关于部署上线</h4><p>最后一点，不管是开发还是审核部署，小程序强烈依赖微信运行环境，被封禁和能否上线的话语权（例如小程序中有游戏广告之类的，通常就会被封禁）并非掌握在自己手里，需要做好被封禁时的准备，域名同理。</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><ul>\n<li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/\" target=\"_blank\" rel=\"noopener\">小程序开发文档</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/106267803?isappinstalled=0\" target=\"_blank\" rel=\"noopener\">小程序登录授权及获取用户信息API详解</a></li>\n<li><a href=\"https://www.jianshu.com/p/de0976045bdb\" target=\"_blank\" rel=\"noopener\">多途径唤起小程序/APP</a></li>\n</ul>"},{"title":"微信授权流程","date":"2019-05-30T04:01:13.000Z","_content":"在公司制作H5页面的时候，有这样一个场景：在微信打开H5页面，已经绑定微信的用户直接免密登录，未绑定的用户使用传统账号密码的登录方式。其中免密登录的核心一环就是走一个微信授权流程，原理不难，弄懂它的流程比较重要。\n<!--more-->\n### [微信网页授权官方文档](https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842)\n当用户在微信中访问第三方网页的时候，公众号可以通过微信网页授权机制来获取用户基本信息。在授权过程中，`openid`作为用户的唯一标识，同一个用户不同公众号的`openid`不同，反之亦然。\n* 在发起授权前，需要到微信公众平台开发的官网设置授权回调的域名；\n* openid: 用户唯一标识；\n* code: `code`作为换取`access_token`的票据，每次用户授权带上的`code`将不一样，`code`只能使用一次，5分钟未被使用自动过期；\n* access_token: 网页授权接口调用凭证；\n* scope：用户授权的作用域；\n  * 以`snsapi_base`为`scope`发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页（往往是业务页面）。用户无感知。\n  * 以`snsapi_userinfo`为`scope`发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。\n  \n### 微信免密登录流程图\n![微信免密登录流程图](/flowChart.png)","source":"_posts/微信授权流程.md","raw":"---\ntitle: 微信授权流程\ndate: 2019-05-30 12:01:13\ntags: [微信授权]\ncategories: 其他小结\n---\n在公司制作H5页面的时候，有这样一个场景：在微信打开H5页面，已经绑定微信的用户直接免密登录，未绑定的用户使用传统账号密码的登录方式。其中免密登录的核心一环就是走一个微信授权流程，原理不难，弄懂它的流程比较重要。\n<!--more-->\n### [微信网页授权官方文档](https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842)\n当用户在微信中访问第三方网页的时候，公众号可以通过微信网页授权机制来获取用户基本信息。在授权过程中，`openid`作为用户的唯一标识，同一个用户不同公众号的`openid`不同，反之亦然。\n* 在发起授权前，需要到微信公众平台开发的官网设置授权回调的域名；\n* openid: 用户唯一标识；\n* code: `code`作为换取`access_token`的票据，每次用户授权带上的`code`将不一样，`code`只能使用一次，5分钟未被使用自动过期；\n* access_token: 网页授权接口调用凭证；\n* scope：用户授权的作用域；\n  * 以`snsapi_base`为`scope`发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页（往往是业务页面）。用户无感知。\n  * 以`snsapi_userinfo`为`scope`发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。\n  \n### 微信免密登录流程图\n![微信免密登录流程图](/flowChart.png)","slug":"微信授权流程","published":1,"updated":"2020-11-04T08:29:30.881Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo12001e7vvu86oeomlq","content":"<p>在公司制作H5页面的时候，有这样一个场景：在微信打开H5页面，已经绑定微信的用户直接免密登录，未绑定的用户使用传统账号密码的登录方式。其中免密登录的核心一环就是走一个微信授权流程，原理不难，弄懂它的流程比较重要。<br><a id=\"more\"></a></p>\n<h3 id=\"微信网页授权官方文档\"><a href=\"#微信网页授权官方文档\" class=\"headerlink\" title=\"微信网页授权官方文档\"></a><a href=\"https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842\" target=\"_blank\" rel=\"noopener\">微信网页授权官方文档</a></h3><p>当用户在微信中访问第三方网页的时候，公众号可以通过微信网页授权机制来获取用户基本信息。在授权过程中，<code>openid</code>作为用户的唯一标识，同一个用户不同公众号的<code>openid</code>不同，反之亦然。</p>\n<ul>\n<li>在发起授权前，需要到微信公众平台开发的官网设置授权回调的域名；</li>\n<li>openid: 用户唯一标识；</li>\n<li>code: <code>code</code>作为换取<code>access_token</code>的票据，每次用户授权带上的<code>code</code>将不一样，<code>code</code>只能使用一次，5分钟未被使用自动过期；</li>\n<li>access_token: 网页授权接口调用凭证；</li>\n<li>scope：用户授权的作用域；<ul>\n<li>以<code>snsapi_base</code>为<code>scope</code>发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页（往往是业务页面）。用户无感知。</li>\n<li>以<code>snsapi_userinfo</code>为<code>scope</code>发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"微信免密登录流程图\"><a href=\"#微信免密登录流程图\" class=\"headerlink\" title=\"微信免密登录流程图\"></a>微信免密登录流程图</h3><p><img src=\"/2019/05/30/微信授权流程/flowChart.png\" alt=\"微信免密登录流程图\"></p>\n","site":{"data":{}},"excerpt":"<p>在公司制作H5页面的时候，有这样一个场景：在微信打开H5页面，已经绑定微信的用户直接免密登录，未绑定的用户使用传统账号密码的登录方式。其中免密登录的核心一环就是走一个微信授权流程，原理不难，弄懂它的流程比较重要。<br></p>","more":"<p></p>\n<h3 id=\"微信网页授权官方文档\"><a href=\"#微信网页授权官方文档\" class=\"headerlink\" title=\"微信网页授权官方文档\"></a><a href=\"https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842\" target=\"_blank\" rel=\"noopener\">微信网页授权官方文档</a></h3><p>当用户在微信中访问第三方网页的时候，公众号可以通过微信网页授权机制来获取用户基本信息。在授权过程中，<code>openid</code>作为用户的唯一标识，同一个用户不同公众号的<code>openid</code>不同，反之亦然。</p>\n<ul>\n<li>在发起授权前，需要到微信公众平台开发的官网设置授权回调的域名；</li>\n<li>openid: 用户唯一标识；</li>\n<li>code: <code>code</code>作为换取<code>access_token</code>的票据，每次用户授权带上的<code>code</code>将不一样，<code>code</code>只能使用一次，5分钟未被使用自动过期；</li>\n<li>access_token: 网页授权接口调用凭证；</li>\n<li>scope：用户授权的作用域；<ul>\n<li>以<code>snsapi_base</code>为<code>scope</code>发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页（往往是业务页面）。用户无感知。</li>\n<li>以<code>snsapi_userinfo</code>为<code>scope</code>发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"微信免密登录流程图\"><a href=\"#微信免密登录流程图\" class=\"headerlink\" title=\"微信免密登录流程图\"></a>微信免密登录流程图</h3><p><img src=\"/2019/05/30/微信授权流程/flowChart.png\" alt=\"微信免密登录流程图\"></p>"},{"title":"正则表达式学习笔记","date":"2019-04-13T04:18:36.000Z","_content":"把2017年的笔记整理一下，方便查找。记录了js正则表达式常用的概念、字符、以及方法。\n<!--more--> \n\n### 一、RegExp对象\nJavaScript通过通过内置对象RegExp支持正则表达式，有两种方法实例化RegExp对象：\n1. 字面量：`var reg = /文本/g`\n2. 构造函数：`var reg = new RegExp(\"\\\\bis\\\\b\\\", 'g')`\n\n### 二、修饰符\n| 修饰符 | 含义 |\n| ---- | ----|\n| g: glogbal | 全文搜索（默认搜索到第一个匹配停止）|\n| i: ignore case | 忽略大小写（默认大小写敏感）|\n| m: multiple lines | 多行搜索 |\n\n### 三、[元字符](https://www.runoob.com/regexp/regexp-metachar.html)\n如（*+$^.|\\(){}[]）等，指在正则表达式中有特殊含义的非字母字符。一般情况下正则表达式的一个字符对应字符串的一个字符。\n__匹配`+`等特殊字符，可先转义，再匹配，如`string.replace(/[\\+]/g, \"\")`__\n\n1. 普通类`[]`\n若要对应多个字符，可用元字符`[]`来构建一个简单的类，所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符。  \n````javascript\n'a1b2c3d4'.replace(/[abc]/gi, 'X') //\"X1X2X3X4\"\n````\n2. 反向类`[^xx]`\n`[^..]`使用元字符`^`创建反向类，即不属于某类的内容。  \n````javascript\n'a1b2c3d4'.replace(/[^abc]/gi, 'X') //\"aXbXcXXX\"\n````\n3. 范围类`[x-x]`\n使用`[a-z]`来连接两个字符，表示从a到z的任意字符 （包含a，z本身）。在`[]`组成类的内部可以连写`[a-zA-Z]`\n4. 预定义类\n正则表达式提供预定义类来匹配常见字符类\n\n| 字符 | 等价类 | 含义 |\n| -- | -- | -- |\n| . | [^\\r\\n] | 除回车符和换行符之外的所有字符 |\n| \\d | [0-9] | 数字字符 |\n| \\D | [^0-9] | 非数字字符 |\n| \\s | [\\t\\n\\f\\r] | 空白符 |\n| \\S | [^\\t\\n\\f\\r] | 非空白符 |\n| \\w | [a-zA-Z_0-9] | 单词字符(字母、数字、下划线) |\n| \\W | [^a-zA-Z_0-9] | 非单词字符 |\n5. 边界\n常见的边界匹配字符如下\n\n| 字符 | 含义 |\n| -- | -- |\n| ^ | 以xxx开始（注意`^`要写在字符前面） |\n| $ | 以xxx结束（注意`$`要写在字符后面） |\n| \\b | 单词边界 |\n| \\B | 非单词边界 |\n````javascript\n'@123@abc@'.replace('^@', 'Q'); //\"Q123@abc@\" \n'@123@abc@'.replace('@$', 'Q'); //\"Q123@abcQ\" \n````\n6. 量词\n匹配连续出现多次的字符串（仅作用于紧挨着它的字符）\n\n| 字符 | 含义 |\n| -- | -- |\n| ? | 出现零或一次（最多出现一次）|\n| + | 出现一次或多次（至少出现一次） |\n| * | 出现零次或多次（任意次）|\n| {n} | 出现n次 |\n| {n,m} | 出现n到m次 |\n| {n,} | 至少出现n次 |\n| {0,m} | 至多出现m次 | \n* 贪婪模式\n尽可能多的匹配，直到匹配失败\n````javascript\n'12345678'.replace(/\\d{3,6}/g,'X'); //\"X78\"\n````\n* 非贪婪模式（在量词后边加`?`）\n尽可能少的匹配，一旦匹配成功，不再继续尝试；匹配前面的子表达式零次或一次，等价于 {0,1}\n````javascript\n'12345678'.replace(/\\d{3,6}？/g, 'X'); //\"XX78\"\n````\n7. 分组\n使用`()`可以达到分组的功能，使量词作用于分组\n````javascript\n'a1b2c3d4'.replace(/([a-z]\\d{3})g/, 'X') //\"Xd4\"\n````\n8. 反向引用\n使用`$1、$2、$3...`来表示和捕获分组后的内容\n````javascript\n'17741881234'.replace(/(.{3})(.{4})(.{4})/, '$1****$3') //\"177****1234\"\n````\n9. 忽略分组\n不希望捕获某些分组，只需要在分组内加上`?:`即可\n10. 或\n使用`|`可以达到或的效果\n11. 前瞻\n正则表达式从文本头部向文本尾部开始解析。 __文本尾部的方向，称为“前”，文本头部称为“后”。__ 前瞻就是在正则表达式匹配规则的时候，向前检查是否符合断言（条件），后顾/后瞻方向相反。JavaScirpt不支持后顾。__符合/不符合__ 特定断言称为 __肯定/正向匹配__ 和 __否定/负向匹配__。\n\n### 四、RegExp对象方法\n* __RegExp.prototype.test(str)__\n用于测试字符串参数中是否存在匹配正则表达式的字符串，若存在返回true，否则返回false\n* __RegExp.prototype.exec(str)__\n使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果。如果没有匹配的文本则返回null，否则返回一个结果数组。\n\n### 五、String对象方法\n* __String.prototype.search(reg)__\n用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。方法返回第一个匹配结果的index，查找不到返回-1。search()方法不执行全局匹配，它将忽略标志g，并且总是从字符串的开始进行检索。\n* __String.prototype.match(reg)__\n用于检索字符串，以找到一个或者多个与正则表达式匹配的文本。如果匹配到了一个或多个字符串，则返回一个数组，若没有匹配到，则返回null。它不会忽略全局标志g。\n* __String.prototype.split(reg)__\n使用split方法把字符串分割为字符数组。\n* __String.prototype.replace(str/reg, str)__\n用于替换字符串中匹配正则表达式或字符串的文本。\n\n### 六、常用的正则表达式记录\n* [https://www.cnblogs.com/Kuro-P/p/8971349.html](https://www.cnblogs.com/Kuro-P/p/8971349.html)\n\n* [常用的元字符](https://www.runoob.com/regexp/regexp-metachar.html)","source":"_posts/正则表达式学习笔记.md","raw":"---\ntitle: 正则表达式学习笔记\ndate: 2019-04-13 12:18:36\ntags: [JavaScript]\ncategories: [前端, JavaScript]\n---\n把2017年的笔记整理一下，方便查找。记录了js正则表达式常用的概念、字符、以及方法。\n<!--more--> \n\n### 一、RegExp对象\nJavaScript通过通过内置对象RegExp支持正则表达式，有两种方法实例化RegExp对象：\n1. 字面量：`var reg = /文本/g`\n2. 构造函数：`var reg = new RegExp(\"\\\\bis\\\\b\\\", 'g')`\n\n### 二、修饰符\n| 修饰符 | 含义 |\n| ---- | ----|\n| g: glogbal | 全文搜索（默认搜索到第一个匹配停止）|\n| i: ignore case | 忽略大小写（默认大小写敏感）|\n| m: multiple lines | 多行搜索 |\n\n### 三、[元字符](https://www.runoob.com/regexp/regexp-metachar.html)\n如（*+$^.|\\(){}[]）等，指在正则表达式中有特殊含义的非字母字符。一般情况下正则表达式的一个字符对应字符串的一个字符。\n__匹配`+`等特殊字符，可先转义，再匹配，如`string.replace(/[\\+]/g, \"\")`__\n\n1. 普通类`[]`\n若要对应多个字符，可用元字符`[]`来构建一个简单的类，所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符。  \n````javascript\n'a1b2c3d4'.replace(/[abc]/gi, 'X') //\"X1X2X3X4\"\n````\n2. 反向类`[^xx]`\n`[^..]`使用元字符`^`创建反向类，即不属于某类的内容。  \n````javascript\n'a1b2c3d4'.replace(/[^abc]/gi, 'X') //\"aXbXcXXX\"\n````\n3. 范围类`[x-x]`\n使用`[a-z]`来连接两个字符，表示从a到z的任意字符 （包含a，z本身）。在`[]`组成类的内部可以连写`[a-zA-Z]`\n4. 预定义类\n正则表达式提供预定义类来匹配常见字符类\n\n| 字符 | 等价类 | 含义 |\n| -- | -- | -- |\n| . | [^\\r\\n] | 除回车符和换行符之外的所有字符 |\n| \\d | [0-9] | 数字字符 |\n| \\D | [^0-9] | 非数字字符 |\n| \\s | [\\t\\n\\f\\r] | 空白符 |\n| \\S | [^\\t\\n\\f\\r] | 非空白符 |\n| \\w | [a-zA-Z_0-9] | 单词字符(字母、数字、下划线) |\n| \\W | [^a-zA-Z_0-9] | 非单词字符 |\n5. 边界\n常见的边界匹配字符如下\n\n| 字符 | 含义 |\n| -- | -- |\n| ^ | 以xxx开始（注意`^`要写在字符前面） |\n| $ | 以xxx结束（注意`$`要写在字符后面） |\n| \\b | 单词边界 |\n| \\B | 非单词边界 |\n````javascript\n'@123@abc@'.replace('^@', 'Q'); //\"Q123@abc@\" \n'@123@abc@'.replace('@$', 'Q'); //\"Q123@abcQ\" \n````\n6. 量词\n匹配连续出现多次的字符串（仅作用于紧挨着它的字符）\n\n| 字符 | 含义 |\n| -- | -- |\n| ? | 出现零或一次（最多出现一次）|\n| + | 出现一次或多次（至少出现一次） |\n| * | 出现零次或多次（任意次）|\n| {n} | 出现n次 |\n| {n,m} | 出现n到m次 |\n| {n,} | 至少出现n次 |\n| {0,m} | 至多出现m次 | \n* 贪婪模式\n尽可能多的匹配，直到匹配失败\n````javascript\n'12345678'.replace(/\\d{3,6}/g,'X'); //\"X78\"\n````\n* 非贪婪模式（在量词后边加`?`）\n尽可能少的匹配，一旦匹配成功，不再继续尝试；匹配前面的子表达式零次或一次，等价于 {0,1}\n````javascript\n'12345678'.replace(/\\d{3,6}？/g, 'X'); //\"XX78\"\n````\n7. 分组\n使用`()`可以达到分组的功能，使量词作用于分组\n````javascript\n'a1b2c3d4'.replace(/([a-z]\\d{3})g/, 'X') //\"Xd4\"\n````\n8. 反向引用\n使用`$1、$2、$3...`来表示和捕获分组后的内容\n````javascript\n'17741881234'.replace(/(.{3})(.{4})(.{4})/, '$1****$3') //\"177****1234\"\n````\n9. 忽略分组\n不希望捕获某些分组，只需要在分组内加上`?:`即可\n10. 或\n使用`|`可以达到或的效果\n11. 前瞻\n正则表达式从文本头部向文本尾部开始解析。 __文本尾部的方向，称为“前”，文本头部称为“后”。__ 前瞻就是在正则表达式匹配规则的时候，向前检查是否符合断言（条件），后顾/后瞻方向相反。JavaScirpt不支持后顾。__符合/不符合__ 特定断言称为 __肯定/正向匹配__ 和 __否定/负向匹配__。\n\n### 四、RegExp对象方法\n* __RegExp.prototype.test(str)__\n用于测试字符串参数中是否存在匹配正则表达式的字符串，若存在返回true，否则返回false\n* __RegExp.prototype.exec(str)__\n使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果。如果没有匹配的文本则返回null，否则返回一个结果数组。\n\n### 五、String对象方法\n* __String.prototype.search(reg)__\n用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。方法返回第一个匹配结果的index，查找不到返回-1。search()方法不执行全局匹配，它将忽略标志g，并且总是从字符串的开始进行检索。\n* __String.prototype.match(reg)__\n用于检索字符串，以找到一个或者多个与正则表达式匹配的文本。如果匹配到了一个或多个字符串，则返回一个数组，若没有匹配到，则返回null。它不会忽略全局标志g。\n* __String.prototype.split(reg)__\n使用split方法把字符串分割为字符数组。\n* __String.prototype.replace(str/reg, str)__\n用于替换字符串中匹配正则表达式或字符串的文本。\n\n### 六、常用的正则表达式记录\n* [https://www.cnblogs.com/Kuro-P/p/8971349.html](https://www.cnblogs.com/Kuro-P/p/8971349.html)\n\n* [常用的元字符](https://www.runoob.com/regexp/regexp-metachar.html)","slug":"正则表达式学习笔记","published":1,"updated":"2020-11-04T08:29:30.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmkbbo13001h7vvup3yz76mf","content":"<p>把2017年的笔记整理一下，方便查找。记录了js正则表达式常用的概念、字符、以及方法。<br><a id=\"more\"></a> </p>\n<h3 id=\"一、RegExp对象\"><a href=\"#一、RegExp对象\" class=\"headerlink\" title=\"一、RegExp对象\"></a>一、RegExp对象</h3><p>JavaScript通过通过内置对象RegExp支持正则表达式，有两种方法实例化RegExp对象：</p>\n<ol>\n<li>字面量：<code>var reg = /文本/g</code></li>\n<li>构造函数：<code>var reg = new RegExp(&quot;\\\\bis\\\\b\\&quot;, &#39;g&#39;)</code></li>\n</ol>\n<h3 id=\"二、修饰符\"><a href=\"#二、修饰符\" class=\"headerlink\" title=\"二、修饰符\"></a>二、修饰符</h3><table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>g: glogbal</td>\n<td>全文搜索（默认搜索到第一个匹配停止）</td>\n</tr>\n<tr>\n<td>i: ignore case</td>\n<td>忽略大小写（默认大小写敏感）</td>\n</tr>\n<tr>\n<td>m: multiple lines</td>\n<td>多行搜索</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"三、元字符\"><a href=\"#三、元字符\" class=\"headerlink\" title=\"三、元字符\"></a>三、<a href=\"https://www.runoob.com/regexp/regexp-metachar.html\" target=\"_blank\" rel=\"noopener\">元字符</a></h3><p>如（*+$^.|(){}[]）等，指在正则表达式中有特殊含义的非字母字符。一般情况下正则表达式的一个字符对应字符串的一个字符。<br><strong>匹配<code>+</code>等特殊字符，可先转义，再匹配，如<code>string.replace(/[\\+]/g, &quot;&quot;)</code></strong></p>\n<ol>\n<li><p>普通类<code>[]</code><br>若要对应多个字符，可用元字符<code>[]</code>来构建一个简单的类，所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符。  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'a1b2c3d4'</span>.replace(<span class=\"regexp\">/[abc]/gi</span>, <span class=\"string\">'X'</span>) <span class=\"comment\">//\"X1X2X3X4\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>反向类<code>[^xx]</code><br><code>[^..]</code>使用元字符<code>^</code>创建反向类，即不属于某类的内容。  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'a1b2c3d4'</span>.replace(<span class=\"regexp\">/[^abc]/gi</span>, <span class=\"string\">'X'</span>) <span class=\"comment\">//\"aXbXcXXX\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>范围类<code>[x-x]</code><br>使用<code>[a-z]</code>来连接两个字符，表示从a到z的任意字符 （包含a，z本身）。在<code>[]</code>组成类的内部可以连写<code>[a-zA-Z]</code></p>\n</li>\n<li>预定义类<br>正则表达式提供预定义类来匹配常见字符类</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>等价类</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td>[^\\r\\n]</td>\n<td>除回车符和换行符之外的所有字符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>[0-9]</td>\n<td>数字字符</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>[^0-9]</td>\n<td>非数字字符</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>[\\t\\n\\f\\r]</td>\n<td>空白符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>[^\\t\\n\\f\\r]</td>\n<td>非空白符</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>[a-zA-Z_0-9]</td>\n<td>单词字符(字母、数字、下划线)</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>[^a-zA-Z_0-9]</td>\n<td>非单词字符</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"5\">\n<li>边界<br>常见的边界匹配字符如下</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>^</td>\n<td>以xxx开始（注意<code>^</code>要写在字符前面）</td>\n</tr>\n<tr>\n<td>$</td>\n<td>以xxx结束（注意<code>$</code>要写在字符后面）</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>单词边界</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>非单词边界</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'@123@abc@'</span>.replace(<span class=\"string\">'^@'</span>, <span class=\"string\">'Q'</span>); <span class=\"comment\">//\"Q123@abc@\" </span></span><br><span class=\"line\"><span class=\"string\">'@123@abc@'</span>.replace(<span class=\"string\">'@$'</span>, <span class=\"string\">'Q'</span>); <span class=\"comment\">//\"Q123@abcQ\"</span></span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>量词<br>匹配连续出现多次的字符串（仅作用于紧挨着它的字符）</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>?</td>\n<td>出现零或一次（最多出现一次）</td>\n</tr>\n<tr>\n<td>+</td>\n<td>出现一次或多次（至少出现一次）</td>\n</tr>\n<tr>\n<td>*</td>\n<td>出现零次或多次（任意次）</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>出现n次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>出现n到m次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>至少出现n次</td>\n</tr>\n<tr>\n<td>{0,m}</td>\n<td>至多出现m次</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>贪婪模式<br>尽可能多的匹配，直到匹配失败</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'12345678'</span>.replace(<span class=\"regexp\">/\\d&#123;3,6&#125;/g</span>,<span class=\"string\">'X'</span>); <span class=\"comment\">//\"X78\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>非贪婪模式（在量词后边加<code>?</code>）<br>尽可能少的匹配，一旦匹配成功，不再继续尝试；匹配前面的子表达式零次或一次，等价于 {0,1}</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'12345678'</span>.replace(<span class=\"regexp\">/\\d&#123;3,6&#125;？/g</span>, <span class=\"string\">'X'</span>); <span class=\"comment\">//\"XX78\"</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"7\">\n<li><p>分组<br>使用<code>()</code>可以达到分组的功能，使量词作用于分组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'a1b2c3d4'</span>.replace(<span class=\"regexp\">/([a-z]\\d&#123;3&#125;)g/</span>, <span class=\"string\">'X'</span>) <span class=\"comment\">//\"Xd4\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>反向引用<br>使用<code>$1、$2、$3...</code>来表示和捕获分组后的内容</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'17741881234'</span>.replace(<span class=\"regexp\">/(.&#123;3&#125;)(.&#123;4&#125;)(.&#123;4&#125;)/</span>, <span class=\"string\">'$1****$3'</span>) <span class=\"comment\">//\"177****1234\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>忽略分组<br>不希望捕获某些分组，只需要在分组内加上<code>?:</code>即可</p>\n</li>\n<li>或<br>使用<code>|</code>可以达到或的效果</li>\n<li>前瞻<br>正则表达式从文本头部向文本尾部开始解析。 <strong>文本尾部的方向，称为“前”，文本头部称为“后”。</strong> 前瞻就是在正则表达式匹配规则的时候，向前检查是否符合断言（条件），后顾/后瞻方向相反。JavaScirpt不支持后顾。<strong>符合/不符合</strong> 特定断言称为 <strong>肯定/正向匹配</strong> 和 <strong>否定/负向匹配</strong>。</li>\n</ol>\n<h3 id=\"四、RegExp对象方法\"><a href=\"#四、RegExp对象方法\" class=\"headerlink\" title=\"四、RegExp对象方法\"></a>四、RegExp对象方法</h3><ul>\n<li><strong>RegExp.prototype.test(str)</strong><br>用于测试字符串参数中是否存在匹配正则表达式的字符串，若存在返回true，否则返回false</li>\n<li><strong>RegExp.prototype.exec(str)</strong><br>使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果。如果没有匹配的文本则返回null，否则返回一个结果数组。</li>\n</ul>\n<h3 id=\"五、String对象方法\"><a href=\"#五、String对象方法\" class=\"headerlink\" title=\"五、String对象方法\"></a>五、String对象方法</h3><ul>\n<li><strong>String.prototype.search(reg)</strong><br>用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。方法返回第一个匹配结果的index，查找不到返回-1。search()方法不执行全局匹配，它将忽略标志g，并且总是从字符串的开始进行检索。</li>\n<li><strong>String.prototype.match(reg)</strong><br>用于检索字符串，以找到一个或者多个与正则表达式匹配的文本。如果匹配到了一个或多个字符串，则返回一个数组，若没有匹配到，则返回null。它不会忽略全局标志g。</li>\n<li><strong>String.prototype.split(reg)</strong><br>使用split方法把字符串分割为字符数组。</li>\n<li><strong>String.prototype.replace(str/reg, str)</strong><br>用于替换字符串中匹配正则表达式或字符串的文本。</li>\n</ul>\n<h3 id=\"六、常用的正则表达式记录\"><a href=\"#六、常用的正则表达式记录\" class=\"headerlink\" title=\"六、常用的正则表达式记录\"></a>六、常用的正则表达式记录</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/Kuro-P/p/8971349.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Kuro-P/p/8971349.html</a></p>\n</li>\n<li><p><a href=\"https://www.runoob.com/regexp/regexp-metachar.html\" target=\"_blank\" rel=\"noopener\">常用的元字符</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>把2017年的笔记整理一下，方便查找。记录了js正则表达式常用的概念、字符、以及方法。<br></p>","more":"<p></p>\n<h3 id=\"一、RegExp对象\"><a href=\"#一、RegExp对象\" class=\"headerlink\" title=\"一、RegExp对象\"></a>一、RegExp对象</h3><p>JavaScript通过通过内置对象RegExp支持正则表达式，有两种方法实例化RegExp对象：</p>\n<ol>\n<li>字面量：<code>var reg = /文本/g</code></li>\n<li>构造函数：<code>var reg = new RegExp(&quot;\\\\bis\\\\b\\&quot;, &#39;g&#39;)</code></li>\n</ol>\n<h3 id=\"二、修饰符\"><a href=\"#二、修饰符\" class=\"headerlink\" title=\"二、修饰符\"></a>二、修饰符</h3><table>\n<thead>\n<tr>\n<th>修饰符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>g: glogbal</td>\n<td>全文搜索（默认搜索到第一个匹配停止）</td>\n</tr>\n<tr>\n<td>i: ignore case</td>\n<td>忽略大小写（默认大小写敏感）</td>\n</tr>\n<tr>\n<td>m: multiple lines</td>\n<td>多行搜索</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"三、元字符\"><a href=\"#三、元字符\" class=\"headerlink\" title=\"三、元字符\"></a>三、<a href=\"https://www.runoob.com/regexp/regexp-metachar.html\" target=\"_blank\" rel=\"noopener\">元字符</a></h3><p>如（*+$^.|(){}[]）等，指在正则表达式中有特殊含义的非字母字符。一般情况下正则表达式的一个字符对应字符串的一个字符。<br><strong>匹配<code>+</code>等特殊字符，可先转义，再匹配，如<code>string.replace(/[\\+]/g, &quot;&quot;)</code></strong></p>\n<ol>\n<li><p>普通类<code>[]</code><br>若要对应多个字符，可用元字符<code>[]</code>来构建一个简单的类，所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符。  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'a1b2c3d4'</span>.replace(<span class=\"regexp\">/[abc]/gi</span>, <span class=\"string\">'X'</span>) <span class=\"comment\">//\"X1X2X3X4\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>反向类<code>[^xx]</code><br><code>[^..]</code>使用元字符<code>^</code>创建反向类，即不属于某类的内容。  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'a1b2c3d4'</span>.replace(<span class=\"regexp\">/[^abc]/gi</span>, <span class=\"string\">'X'</span>) <span class=\"comment\">//\"aXbXcXXX\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>范围类<code>[x-x]</code><br>使用<code>[a-z]</code>来连接两个字符，表示从a到z的任意字符 （包含a，z本身）。在<code>[]</code>组成类的内部可以连写<code>[a-zA-Z]</code></p>\n</li>\n<li>预定义类<br>正则表达式提供预定义类来匹配常见字符类</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>等价类</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.</td>\n<td>[^\\r\\n]</td>\n<td>除回车符和换行符之外的所有字符</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>[0-9]</td>\n<td>数字字符</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>[^0-9]</td>\n<td>非数字字符</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>[\\t\\n\\f\\r]</td>\n<td>空白符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>[^\\t\\n\\f\\r]</td>\n<td>非空白符</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>[a-zA-Z_0-9]</td>\n<td>单词字符(字母、数字、下划线)</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>[^a-zA-Z_0-9]</td>\n<td>非单词字符</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"5\">\n<li>边界<br>常见的边界匹配字符如下</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>^</td>\n<td>以xxx开始（注意<code>^</code>要写在字符前面）</td>\n</tr>\n<tr>\n<td>$</td>\n<td>以xxx结束（注意<code>$</code>要写在字符后面）</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>单词边界</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>非单词边界</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'@123@abc@'</span>.replace(<span class=\"string\">'^@'</span>, <span class=\"string\">'Q'</span>); <span class=\"comment\">//\"Q123@abc@\" </span></span><br><span class=\"line\"><span class=\"string\">'@123@abc@'</span>.replace(<span class=\"string\">'@$'</span>, <span class=\"string\">'Q'</span>); <span class=\"comment\">//\"Q123@abcQ\"</span></span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>量词<br>匹配连续出现多次的字符串（仅作用于紧挨着它的字符）</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>?</td>\n<td>出现零或一次（最多出现一次）</td>\n</tr>\n<tr>\n<td>+</td>\n<td>出现一次或多次（至少出现一次）</td>\n</tr>\n<tr>\n<td>*</td>\n<td>出现零次或多次（任意次）</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>出现n次</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td>出现n到m次</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td>至少出现n次</td>\n</tr>\n<tr>\n<td>{0,m}</td>\n<td>至多出现m次</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>贪婪模式<br>尽可能多的匹配，直到匹配失败</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'12345678'</span>.replace(<span class=\"regexp\">/\\d&#123;3,6&#125;/g</span>,<span class=\"string\">'X'</span>); <span class=\"comment\">//\"X78\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>非贪婪模式（在量词后边加<code>?</code>）<br>尽可能少的匹配，一旦匹配成功，不再继续尝试；匹配前面的子表达式零次或一次，等价于 {0,1}</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'12345678'</span>.replace(<span class=\"regexp\">/\\d&#123;3,6&#125;？/g</span>, <span class=\"string\">'X'</span>); <span class=\"comment\">//\"XX78\"</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"7\">\n<li><p>分组<br>使用<code>()</code>可以达到分组的功能，使量词作用于分组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'a1b2c3d4'</span>.replace(<span class=\"regexp\">/([a-z]\\d&#123;3&#125;)g/</span>, <span class=\"string\">'X'</span>) <span class=\"comment\">//\"Xd4\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>反向引用<br>使用<code>$1、$2、$3...</code>来表示和捕获分组后的内容</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'17741881234'</span>.replace(<span class=\"regexp\">/(.&#123;3&#125;)(.&#123;4&#125;)(.&#123;4&#125;)/</span>, <span class=\"string\">'$1****$3'</span>) <span class=\"comment\">//\"177****1234\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>忽略分组<br>不希望捕获某些分组，只需要在分组内加上<code>?:</code>即可</p>\n</li>\n<li>或<br>使用<code>|</code>可以达到或的效果</li>\n<li>前瞻<br>正则表达式从文本头部向文本尾部开始解析。 <strong>文本尾部的方向，称为“前”，文本头部称为“后”。</strong> 前瞻就是在正则表达式匹配规则的时候，向前检查是否符合断言（条件），后顾/后瞻方向相反。JavaScirpt不支持后顾。<strong>符合/不符合</strong> 特定断言称为 <strong>肯定/正向匹配</strong> 和 <strong>否定/负向匹配</strong>。</li>\n</ol>\n<h3 id=\"四、RegExp对象方法\"><a href=\"#四、RegExp对象方法\" class=\"headerlink\" title=\"四、RegExp对象方法\"></a>四、RegExp对象方法</h3><ul>\n<li><strong>RegExp.prototype.test(str)</strong><br>用于测试字符串参数中是否存在匹配正则表达式的字符串，若存在返回true，否则返回false</li>\n<li><strong>RegExp.prototype.exec(str)</strong><br>使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果。如果没有匹配的文本则返回null，否则返回一个结果数组。</li>\n</ul>\n<h3 id=\"五、String对象方法\"><a href=\"#五、String对象方法\" class=\"headerlink\" title=\"五、String对象方法\"></a>五、String对象方法</h3><ul>\n<li><strong>String.prototype.search(reg)</strong><br>用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。方法返回第一个匹配结果的index，查找不到返回-1。search()方法不执行全局匹配，它将忽略标志g，并且总是从字符串的开始进行检索。</li>\n<li><strong>String.prototype.match(reg)</strong><br>用于检索字符串，以找到一个或者多个与正则表达式匹配的文本。如果匹配到了一个或多个字符串，则返回一个数组，若没有匹配到，则返回null。它不会忽略全局标志g。</li>\n<li><strong>String.prototype.split(reg)</strong><br>使用split方法把字符串分割为字符数组。</li>\n<li><strong>String.prototype.replace(str/reg, str)</strong><br>用于替换字符串中匹配正则表达式或字符串的文本。</li>\n</ul>\n<h3 id=\"六、常用的正则表达式记录\"><a href=\"#六、常用的正则表达式记录\" class=\"headerlink\" title=\"六、常用的正则表达式记录\"></a>六、常用的正则表达式记录</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/Kuro-P/p/8971349.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Kuro-P/p/8971349.html</a></p>\n</li>\n<li><p><a href=\"https://www.runoob.com/regexp/regexp-metachar.html\" target=\"_blank\" rel=\"noopener\">常用的元字符</a></p>\n</li>\n</ul>"}],"PostAsset":[{"_id":"source/_posts/Linux命令行与shell脚本学习/file-permissions.png","post":"ckmkbbo0g000a7vvucaoqnvsg","slug":"file-permissions.png","modified":1,"renderable":1},{"_id":"source/_posts/PWA-Service-Worker-小结（二）实践/Service-Worker-Lifecycle.png","post":"ckmkbbo0n000f7vvuel4i9vjy","slug":"Service-Worker-Lifecycle.png","modified":1,"renderable":1},{"_id":"source/_posts/z-index小结/stacking-order.png","post":"ckmkbbo0t000n7vvuxdgvssz3","slug":"stacking-order.png","modified":1,"renderable":1},{"_id":"source/_posts/使用 Performance APi 进行前端性能监控/performance.png","post":"ckmkbbo0z00137vvukrfw569c","slug":"performance.png","modified":1,"renderable":1},{"_id":"source/_posts/微信授权流程/flowChart.png","slug":"flowChart.png","post":"ckmkbbo12001e7vvu86oeomlq","modified":1,"renderable":0},{"_id":"source/_posts/Prometheus监控应用性能/architecture.png","post":"ckmkbbo0p000i7vvu8n4jb82d","slug":"architecture.png","modified":1,"renderable":1},{"_id":"source/_posts/Prometheus监控应用性能/flowChart.png","post":"ckmkbbo0p000i7vvu8n4jb82d","slug":"flowChart.png","modified":1,"renderable":1},{"_id":"source/_posts/同时使用两个账号分别操作Github和Gitlab/enter-passphrase.png","post":"ckmkbbo10001a7vvuy0kowhyq","slug":"enter-passphrase.png","modified":1,"renderable":1},{"_id":"source/_posts/同时使用两个账号分别操作Github和Gitlab/test-ssh-connect.png","post":"ckmkbbo10001a7vvuy0kowhyq","slug":"test-ssh-connect.png","modified":1,"renderable":1},{"_id":"source/_posts/PWA-Service-Worker-小结（一）各类缓存对比/CDN&&Nginx.jpg","post":"ckmkbbo0s000l7vvuq19jmoef","slug":"CDN&&Nginx.jpg","modified":1,"renderable":1},{"_id":"source/_posts/PWA-Service-Worker-小结（一）各类缓存对比/web应用缓存位置图.png","post":"ckmkbbo0s000l7vvuq19jmoef","slug":"web应用缓存位置图.png","modified":1,"renderable":1},{"_id":"source/_posts/PWA-Service-Worker-小结（一）各类缓存对比/协商缓存命中过程.png","post":"ckmkbbo0s000l7vvuq19jmoef","slug":"协商缓存命中过程.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ckmkbbo0a00047vvunwqob8q6","category_id":"ckmkbbo0e00077vvu7cv11czo","_id":"ckmkbbo0r000j7vvud1o7b4vm"},{"post_id":"ckmkbbo0b00057vvucrn2kbuy","category_id":"ckmkbbo0n000e7vvumslyz8h4","_id":"ckmkbbo0u000o7vvueyp4nw9j"},{"post_id":"ckmkbbo0f00097vvuatrazhdu","category_id":"ckmkbbo0r000k7vvug1iakyzv","_id":"ckmkbbo0x000v7vvu0hje5ydy"},{"post_id":"ckmkbbo0g000a7vvucaoqnvsg","category_id":"ckmkbbo0r000k7vvug1iakyzv","_id":"ckmkbbo0z00117vvuam1bwk7y"},{"post_id":"ckmkbbo0w000s7vvuaz3i3c1l","category_id":"ckmkbbo0r000k7vvug1iakyzv","_id":"ckmkbbo0z00147vvuvrxxfjd2"},{"post_id":"ckmkbbo0m000d7vvu2n3chatg","category_id":"ckmkbbo0n000e7vvumslyz8h4","_id":"ckmkbbo1000177vvuzd65yaa0"},{"post_id":"ckmkbbo0z00137vvukrfw569c","category_id":"ckmkbbo0y00107vvup9r7rpn9","_id":"ckmkbbo11001c7vvud4wuyutl"},{"post_id":"ckmkbbo11001b7vvuruzpiggr","category_id":"ckmkbbo0y00107vvup9r7rpn9","_id":"ckmkbbo14001j7vvuqtyrvfpm"},{"post_id":"ckmkbbo0p000i7vvu8n4jb82d","category_id":"ckmkbbo1000187vvu33qkzn4t","_id":"ckmkbbo14001m7vvud7i7sdla"},{"post_id":"ckmkbbo12001e7vvu86oeomlq","category_id":"ckmkbbo0n000e7vvumslyz8h4","_id":"ckmkbbo14001o7vvuh4e41ril"},{"post_id":"ckmkbbo0v000q7vvuauomikgq","category_id":"ckmkbbo14001p7vvusshgkpz7","_id":"ckmkbbo15001v7vvu3pdpee1z"},{"post_id":"ckmkbbo0x000w7vvuaqtylenm","category_id":"ckmkbbo15001s7vvu541bb0cc","_id":"ckmkbbo16001z7vvunw7d6sm6"},{"post_id":"ckmkbbo0y000z7vvu2hjw3g0g","category_id":"ckmkbbo15001w7vvuoegdg2i5","_id":"ckmkbbo1600237vvu8nv1eg2f"},{"post_id":"ckmkbbo0n000f7vvuel4i9vjy","category_id":"ckmkbbo0y00107vvup9r7rpn9","_id":"ckmkbbo1700277vvult2tm5aj"},{"post_id":"ckmkbbo0n000f7vvuel4i9vjy","category_id":"ckmkbbo1600207vvupln9ha2l","_id":"ckmkbbo17002a7vvue9g23h4s"},{"post_id":"ckmkbbo0z00157vvubfjuoi34","category_id":"ckmkbbo0y00107vvup9r7rpn9","_id":"ckmkbbo18002c7vvu5d28gn5d"},{"post_id":"ckmkbbo0z00157vvubfjuoi34","category_id":"ckmkbbo1600247vvu5mkmi07e","_id":"ckmkbbo18002f7vvuxafy4lj1"},{"post_id":"ckmkbbo10001a7vvuy0kowhyq","category_id":"ckmkbbo1700287vvu0zdtbeyn","_id":"ckmkbbo19002i7vvux4f6eilu"},{"post_id":"ckmkbbo13001h7vvup3yz76mf","category_id":"ckmkbbo0y00107vvup9r7rpn9","_id":"ckmkbbo1a002m7vvuz5qlmu5v"},{"post_id":"ckmkbbo13001h7vvup3yz76mf","category_id":"ckmkbbo1600247vvu5mkmi07e","_id":"ckmkbbo1a002o7vvuqci1fpng"},{"post_id":"ckmkbbo0s000l7vvuq19jmoef","category_id":"ckmkbbo0y00107vvup9r7rpn9","_id":"ckmkbbo1a002q7vvusnjc8xrw"},{"post_id":"ckmkbbo0s000l7vvuq19jmoef","category_id":"ckmkbbo1600207vvupln9ha2l","_id":"ckmkbbo1a002s7vvurm62vm19"},{"post_id":"ckmkbbo0t000n7vvuxdgvssz3","category_id":"ckmkbbo0y00107vvup9r7rpn9","_id":"ckmkbbo1a002u7vvu4cyqhsgq"},{"post_id":"ckmkbbo0t000n7vvuxdgvssz3","category_id":"ckmkbbo19002l7vvuhud75lvz","_id":"ckmkbbo1b002w7vvuaylrw78y"}],"PostTag":[{"post_id":"ckmkbbo0300007vvundulmx8m","tag_id":"ckmkbbo0800027vvuez6ciia7","_id":"ckmkbbo0f00087vvutvol5qww"},{"post_id":"ckmkbbo0600017vvun1gd9b7q","tag_id":"ckmkbbo0800027vvuez6ciia7","_id":"ckmkbbo0m000c7vvupuzvoe8h"},{"post_id":"ckmkbbo0900037vvunl01h9xr","tag_id":"ckmkbbo0800027vvuez6ciia7","_id":"ckmkbbo0p000h7vvub6u5ui90"},{"post_id":"ckmkbbo0a00047vvunwqob8q6","tag_id":"ckmkbbo0o000g7vvu3xdgk2h4","_id":"ckmkbbo0w000t7vvuyw3d48ko"},{"post_id":"ckmkbbo0a00047vvunwqob8q6","tag_id":"ckmkbbo0s000m7vvu6lktmeck","_id":"ckmkbbo0y000x7vvu02sbk810"},{"post_id":"ckmkbbo0b00057vvucrn2kbuy","tag_id":"ckmkbbo0v000r7vvuoks2nmrn","_id":"ckmkbbo0z00127vvup4kpojq0"},{"post_id":"ckmkbbo0f00097vvuatrazhdu","tag_id":"ckmkbbo0y000y7vvuwlsft916","_id":"ckmkbbo1000197vvuvj60unnw"},{"post_id":"ckmkbbo0g000a7vvucaoqnvsg","tag_id":"ckmkbbo1000167vvu07tlfrqd","_id":"ckmkbbo12001g7vvu6o7yazfr"},{"post_id":"ckmkbbo0m000d7vvu2n3chatg","tag_id":"ckmkbbo12001d7vvuvptiv4py","_id":"ckmkbbo14001l7vvuiyu8704s"},{"post_id":"ckmkbbo0n000f7vvuel4i9vjy","tag_id":"ckmkbbo13001i7vvuhquwdnko","_id":"ckmkbbo15001q7vvu7zk0u6gz"},{"post_id":"ckmkbbo0p000i7vvu8n4jb82d","tag_id":"ckmkbbo14001n7vvukkt3ys7m","_id":"ckmkbbo15001t7vvu8dg2pfo4"},{"post_id":"ckmkbbo0s000l7vvuq19jmoef","tag_id":"ckmkbbo13001i7vvuhquwdnko","_id":"ckmkbbo16001x7vvu4c6rpr2n"},{"post_id":"ckmkbbo0t000n7vvuxdgvssz3","tag_id":"ckmkbbo15001u7vvujv127o98","_id":"ckmkbbo1600217vvugmecg783"},{"post_id":"ckmkbbo0v000q7vvuauomikgq","tag_id":"ckmkbbo16001y7vvu0xxmhtf7","_id":"ckmkbbo1700257vvudbfqf6fa"},{"post_id":"ckmkbbo0w000s7vvuaz3i3c1l","tag_id":"ckmkbbo0y000y7vvuwlsft916","_id":"ckmkbbo1700297vvu2lo6w1mh"},{"post_id":"ckmkbbo0x000w7vvuaqtylenm","tag_id":"ckmkbbo1700267vvuyswooh4i","_id":"ckmkbbo18002e7vvu9q17d9da"},{"post_id":"ckmkbbo0y000z7vvu2hjw3g0g","tag_id":"ckmkbbo18002b7vvut89ediwu","_id":"ckmkbbo19002j7vvucjifiutr"},{"post_id":"ckmkbbo0z00137vvukrfw569c","tag_id":"ckmkbbo14001n7vvukkt3ys7m","_id":"ckmkbbo1a002n7vvusmtul942"},{"post_id":"ckmkbbo0z00157vvubfjuoi34","tag_id":"ckmkbbo18002b7vvut89ediwu","_id":"ckmkbbo1a002r7vvuegzy932l"},{"post_id":"ckmkbbo10001a7vvuy0kowhyq","tag_id":"ckmkbbo1a002p7vvu41th62fe","_id":"ckmkbbo1a002v7vvu7uhet994"},{"post_id":"ckmkbbo11001b7vvuruzpiggr","tag_id":"ckmkbbo1a002t7vvuic744ynt","_id":"ckmkbbo1b002z7vvuzc18er7m"},{"post_id":"ckmkbbo11001b7vvuruzpiggr","tag_id":"ckmkbbo1b002x7vvuvbdofyz0","_id":"ckmkbbo1b00307vvuzctu7fxn"},{"post_id":"ckmkbbo12001e7vvu86oeomlq","tag_id":"ckmkbbo1b002y7vvuh82wusnq","_id":"ckmkbbo1c00327vvue7fplkya"},{"post_id":"ckmkbbo13001h7vvup3yz76mf","tag_id":"ckmkbbo18002b7vvut89ediwu","_id":"ckmkbbo1c00337vvubn8o63hj"}],"Tag":[{"name":"年度总结","_id":"ckmkbbo0800027vvuez6ciia7"},{"name":"大数据","_id":"ckmkbbo0o000g7vvu3xdgk2h4"},{"name":"流处理","_id":"ckmkbbo0s000m7vvu6lktmeck"},{"name":"Hexo","_id":"ckmkbbo0v000r7vvuoks2nmrn"},{"name":"计算机网络","_id":"ckmkbbo0y000y7vvuwlsft916"},{"name":"Linux&shell","_id":"ckmkbbo1000167vvu07tlfrqd"},{"name":"Markdown","_id":"ckmkbbo12001d7vvuvptiv4py"},{"name":"Service Worker","_id":"ckmkbbo13001i7vvuhquwdnko"},{"name":"性能监控","_id":"ckmkbbo14001n7vvukkt3ys7m"},{"name":"CSS","_id":"ckmkbbo15001u7vvujv127o98"},{"name":"读书小结","_id":"ckmkbbo16001y7vvu0xxmhtf7"},{"name":"NodeJS","_id":"ckmkbbo1700267vvuyswooh4i"},{"name":"JavaScript","_id":"ckmkbbo18002b7vvut89ediwu"},{"name":"git","_id":"ckmkbbo1a002p7vvu41th62fe"},{"name":"微信","_id":"ckmkbbo1a002t7vvuic744ynt"},{"name":"小程序","_id":"ckmkbbo1b002x7vvuvbdofyz0"},{"name":"微信授权","_id":"ckmkbbo1b002y7vvuh82wusnq"}]}}